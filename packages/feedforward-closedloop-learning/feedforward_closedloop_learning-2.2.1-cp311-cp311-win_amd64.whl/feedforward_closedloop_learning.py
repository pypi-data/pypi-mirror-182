# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""Feedforward Closedloop Learning"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _feedforward_closedloop_learning
else:
    import _feedforward_closedloop_learning

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _feedforward_closedloop_learning.delete_SwigPyIterator

    def value(self):
        return _feedforward_closedloop_learning.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _feedforward_closedloop_learning.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _feedforward_closedloop_learning.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _feedforward_closedloop_learning.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _feedforward_closedloop_learning.SwigPyIterator_equal(self, x)

    def copy(self):
        return _feedforward_closedloop_learning.SwigPyIterator_copy(self)

    def next(self):
        return _feedforward_closedloop_learning.SwigPyIterator_next(self)

    def __next__(self):
        return _feedforward_closedloop_learning.SwigPyIterator___next__(self)

    def previous(self):
        return _feedforward_closedloop_learning.SwigPyIterator_previous(self)

    def advance(self, n):
        return _feedforward_closedloop_learning.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _feedforward_closedloop_learning.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _feedforward_closedloop_learning.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _feedforward_closedloop_learning.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _feedforward_closedloop_learning.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _feedforward_closedloop_learning.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _feedforward_closedloop_learning.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.SwigPyIterator_swigregister(SwigPyIterator)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _feedforward_closedloop_learning.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _feedforward_closedloop_learning.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _feedforward_closedloop_learning.DoubleVector___bool__(self)

    def __len__(self):
        return _feedforward_closedloop_learning.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _feedforward_closedloop_learning.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _feedforward_closedloop_learning.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _feedforward_closedloop_learning.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _feedforward_closedloop_learning.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _feedforward_closedloop_learning.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _feedforward_closedloop_learning.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _feedforward_closedloop_learning.DoubleVector_pop(self)

    def append(self, x):
        return _feedforward_closedloop_learning.DoubleVector_append(self, x)

    def empty(self):
        return _feedforward_closedloop_learning.DoubleVector_empty(self)

    def size(self):
        return _feedforward_closedloop_learning.DoubleVector_size(self)

    def swap(self, v):
        return _feedforward_closedloop_learning.DoubleVector_swap(self, v)

    def begin(self):
        return _feedforward_closedloop_learning.DoubleVector_begin(self)

    def end(self):
        return _feedforward_closedloop_learning.DoubleVector_end(self)

    def rbegin(self):
        return _feedforward_closedloop_learning.DoubleVector_rbegin(self)

    def rend(self):
        return _feedforward_closedloop_learning.DoubleVector_rend(self)

    def clear(self):
        return _feedforward_closedloop_learning.DoubleVector_clear(self)

    def get_allocator(self):
        return _feedforward_closedloop_learning.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _feedforward_closedloop_learning.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _feedforward_closedloop_learning.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _feedforward_closedloop_learning.DoubleVector_swiginit(self, _feedforward_closedloop_learning.new_DoubleVector(*args))

    def push_back(self, x):
        return _feedforward_closedloop_learning.DoubleVector_push_back(self, x)

    def front(self):
        return _feedforward_closedloop_learning.DoubleVector_front(self)

    def back(self):
        return _feedforward_closedloop_learning.DoubleVector_back(self)

    def assign(self, n, x):
        return _feedforward_closedloop_learning.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _feedforward_closedloop_learning.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _feedforward_closedloop_learning.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _feedforward_closedloop_learning.DoubleVector_reserve(self, n)

    def capacity(self):
        return _feedforward_closedloop_learning.DoubleVector_capacity(self)
    __swig_destroy__ = _feedforward_closedloop_learning.delete_DoubleVector

# Register DoubleVector in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.DoubleVector_swigregister(DoubleVector)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _feedforward_closedloop_learning.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _feedforward_closedloop_learning.IntVector___nonzero__(self)

    def __bool__(self):
        return _feedforward_closedloop_learning.IntVector___bool__(self)

    def __len__(self):
        return _feedforward_closedloop_learning.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _feedforward_closedloop_learning.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _feedforward_closedloop_learning.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _feedforward_closedloop_learning.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _feedforward_closedloop_learning.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _feedforward_closedloop_learning.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _feedforward_closedloop_learning.IntVector___setitem__(self, *args)

    def pop(self):
        return _feedforward_closedloop_learning.IntVector_pop(self)

    def append(self, x):
        return _feedforward_closedloop_learning.IntVector_append(self, x)

    def empty(self):
        return _feedforward_closedloop_learning.IntVector_empty(self)

    def size(self):
        return _feedforward_closedloop_learning.IntVector_size(self)

    def swap(self, v):
        return _feedforward_closedloop_learning.IntVector_swap(self, v)

    def begin(self):
        return _feedforward_closedloop_learning.IntVector_begin(self)

    def end(self):
        return _feedforward_closedloop_learning.IntVector_end(self)

    def rbegin(self):
        return _feedforward_closedloop_learning.IntVector_rbegin(self)

    def rend(self):
        return _feedforward_closedloop_learning.IntVector_rend(self)

    def clear(self):
        return _feedforward_closedloop_learning.IntVector_clear(self)

    def get_allocator(self):
        return _feedforward_closedloop_learning.IntVector_get_allocator(self)

    def pop_back(self):
        return _feedforward_closedloop_learning.IntVector_pop_back(self)

    def erase(self, *args):
        return _feedforward_closedloop_learning.IntVector_erase(self, *args)

    def __init__(self, *args):
        _feedforward_closedloop_learning.IntVector_swiginit(self, _feedforward_closedloop_learning.new_IntVector(*args))

    def push_back(self, x):
        return _feedforward_closedloop_learning.IntVector_push_back(self, x)

    def front(self):
        return _feedforward_closedloop_learning.IntVector_front(self)

    def back(self):
        return _feedforward_closedloop_learning.IntVector_back(self)

    def assign(self, n, x):
        return _feedforward_closedloop_learning.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _feedforward_closedloop_learning.IntVector_resize(self, *args)

    def insert(self, *args):
        return _feedforward_closedloop_learning.IntVector_insert(self, *args)

    def reserve(self, n):
        return _feedforward_closedloop_learning.IntVector_reserve(self, n)

    def capacity(self):
        return _feedforward_closedloop_learning.IntVector_capacity(self)
    __swig_destroy__ = _feedforward_closedloop_learning.delete_IntVector

# Register IntVector in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.IntVector_swigregister(IntVector)
class FeedforwardClosedloopLearning(object):
    r"""Proxy of C++ FeedforwardClosedloopLearning class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, num_input, num_of_neurons_per_layer):
        r"""
        __init__(FeedforwardClosedloopLearning self, int const num_input, IntVector num_of_neurons_per_layer) -> FeedforwardClosedloopLearning

        Parameters
        ----------
        num_input: int const
        num_of_neurons_per_layer: std::vector< int,std::allocator< int > > const &

        """
        _feedforward_closedloop_learning.FeedforwardClosedloopLearning_swiginit(self, _feedforward_closedloop_learning.new_FeedforwardClosedloopLearning(num_input, num_of_neurons_per_layer))
    __swig_destroy__ = _feedforward_closedloop_learning.delete_FeedforwardClosedloopLearning

    def doStep(self, input, error):
        r"""
        doStep(FeedforwardClosedloopLearning self, DoubleVector input, DoubleVector error)

        Parameters
        ----------
        input: std::vector< double,std::allocator< double > > const &
        error: std::vector< double,std::allocator< double > > const &

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_doStep(self, input, error)

    def getOutput(self, index):
        r"""
        getOutput(FeedforwardClosedloopLearning self, int index) -> double

        Parameters
        ----------
        index: int

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getOutput(self, index)

    def setLearningRate(self, learningRate):
        r"""
        setLearningRate(FeedforwardClosedloopLearning self, double learningRate)

        Parameters
        ----------
        learningRate: double

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setLearningRate(self, learningRate)

    def setLearningRateDiscountFactor(self, _learningRateDiscountFactor):
        r"""
        setLearningRateDiscountFactor(FeedforwardClosedloopLearning self, double _learningRateDiscountFactor)

        Parameters
        ----------
        _learningRateDiscountFactor: double

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setLearningRateDiscountFactor(self, _learningRateDiscountFactor)

    def setDecay(self, decay):
        r"""
        setDecay(FeedforwardClosedloopLearning self, double decay)

        Parameters
        ----------
        decay: double

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setDecay(self, decay)

    def setMomentum(self, momentum):
        r"""
        setMomentum(FeedforwardClosedloopLearning self, double momentum)

        Parameters
        ----------
        momentum: double

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setMomentum(self, momentum)

    def setActivationFunction(self, _activationFunction):
        r"""
        setActivationFunction(FeedforwardClosedloopLearning self, FCLNeuron::ActivationFunction _activationFunction)

        Parameters
        ----------
        _activationFunction: enum FCLNeuron::ActivationFunction

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setActivationFunction(self, _activationFunction)

    def initWeights(self, *args):
        r"""
        initWeights(FeedforwardClosedloopLearning self, double max=0.001, int initBias=1, FCLNeuron::WeightInitMethod weightInitMethod=MAX_OUTPUT_RANDOM)

        Parameters
        ----------
        max: double
        initBias: int
        weightInitMethod: enum FCLNeuron::WeightInitMethod

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_initWeights(self, *args)

    def seedRandom(self, s):
        r"""
        seedRandom(FeedforwardClosedloopLearning self, int s)

        Parameters
        ----------
        s: int

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_seedRandom(self, s)

    def setBias(self, _bias):
        r"""
        setBias(FeedforwardClosedloopLearning self, double _bias)

        Parameters
        ----------
        _bias: double

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_setBias(self, _bias)

    def getNumLayers(self):
        r"""getNumLayers(FeedforwardClosedloopLearning self) -> int"""
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getNumLayers(self)

    def getLayer(self, i):
        r"""
        getLayer(FeedforwardClosedloopLearning self, unsigned int i) -> FCLLayer

        Parameters
        ----------
        i: unsigned int

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getLayer(self, i)

    def getOutputLayer(self):
        r"""getOutputLayer(FeedforwardClosedloopLearning self) -> FCLLayer"""
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getOutputLayer(self)

    def getNumInputs(self):
        r"""getNumInputs(FeedforwardClosedloopLearning self) -> int"""
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getNumInputs(self)

    def getLayers(self):
        r"""getLayers(FeedforwardClosedloopLearning self) -> FCLLayer **"""
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_getLayers(self)

    def saveModel(self, name):
        r"""
        saveModel(FeedforwardClosedloopLearning self, char const * name) -> bool

        Parameters
        ----------
        name: char const *

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_saveModel(self, name)

    def loadModel(self, name):
        r"""
        loadModel(FeedforwardClosedloopLearning self, char const * name) -> bool

        Parameters
        ----------
        name: char const *

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearning_loadModel(self, name)

# Register FeedforwardClosedloopLearning in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.FeedforwardClosedloopLearning_swigregister(FeedforwardClosedloopLearning)
class FeedforwardClosedloopLearningWithFilterbank(FeedforwardClosedloopLearning):
    r"""Proxy of C++ FeedforwardClosedloopLearningWithFilterbank class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, num_of_inputs, num_of_neurons_per_layer, num_filtersInput, minT, maxT):
        r"""
        __init__(FeedforwardClosedloopLearningWithFilterbank self, int const num_of_inputs, IntVector num_of_neurons_per_layer, int const num_filtersInput, double const minT, double const maxT) -> FeedforwardClosedloopLearningWithFilterbank

        Parameters
        ----------
        num_of_inputs: int const
        num_of_neurons_per_layer: std::vector< int,std::allocator< int > > const &
        num_filtersInput: int const
        minT: double const
        maxT: double const

        """
        _feedforward_closedloop_learning.FeedforwardClosedloopLearningWithFilterbank_swiginit(self, _feedforward_closedloop_learning.new_FeedforwardClosedloopLearningWithFilterbank(num_of_inputs, num_of_neurons_per_layer, num_filtersInput, minT, maxT))
    __swig_destroy__ = _feedforward_closedloop_learning.delete_FeedforwardClosedloopLearningWithFilterbank

    def doStep(self, input, error):
        r"""
        doStep(FeedforwardClosedloopLearningWithFilterbank self, DoubleVector input, DoubleVector error)

        Parameters
        ----------
        input: std::vector< double,std::allocator< double > > const &
        error: std::vector< double,std::allocator< double > > const &

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearningWithFilterbank_doStep(self, input, error)

    def getFilterOutput(self, inputIdx, filterIdx):
        r"""
        getFilterOutput(FeedforwardClosedloopLearningWithFilterbank self, int inputIdx, int filterIdx) -> double

        Parameters
        ----------
        inputIdx: int
        filterIdx: int

        """
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearningWithFilterbank_getFilterOutput(self, inputIdx, filterIdx)

    def getNFiltersPerInput(self):
        r"""getNFiltersPerInput(FeedforwardClosedloopLearningWithFilterbank self) -> int"""
        return _feedforward_closedloop_learning.FeedforwardClosedloopLearningWithFilterbank_getNFiltersPerInput(self)

# Register FeedforwardClosedloopLearningWithFilterbank in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.FeedforwardClosedloopLearningWithFilterbank_swigregister(FeedforwardClosedloopLearningWithFilterbank)
NUM_THREADS = _feedforward_closedloop_learning.NUM_THREADS

class LayerThread(object):
    r"""Proxy of C++ LayerThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _feedforward_closedloop_learning.delete_LayerThread

    def addNeuron(self, neuron):
        r"""
        addNeuron(LayerThread self, FCLNeuron neuron)

        Parameters
        ----------
        neuron: FCLNeuron *

        """
        return _feedforward_closedloop_learning.LayerThread_addNeuron(self, neuron)

    def start(self):
        r"""start(LayerThread self)"""
        return _feedforward_closedloop_learning.LayerThread_start(self)

    def join(self):
        r"""join(LayerThread self)"""
        return _feedforward_closedloop_learning.LayerThread_join(self)

    def run(self):
        r"""run(LayerThread self)"""
        return _feedforward_closedloop_learning.LayerThread_run(self)

# Register LayerThread in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.LayerThread_swigregister(LayerThread)
class CalcOutputThread(LayerThread):
    r"""Proxy of C++ CalcOutputThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _feedforward_closedloop_learning.delete_CalcOutputThread

# Register CalcOutputThread in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.CalcOutputThread_swigregister(CalcOutputThread)
class LearningThread(LayerThread):
    r"""Proxy of C++ LearningThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _feedforward_closedloop_learning.delete_LearningThread

# Register LearningThread in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.LearningThread_swigregister(LearningThread)
class MaxDetThread(LayerThread):
    r"""Proxy of C++ MaxDetThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _feedforward_closedloop_learning.delete_MaxDetThread

# Register MaxDetThread in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.MaxDetThread_swigregister(MaxDetThread)
class FCLLayer(object):
    r"""Proxy of C++ FCLLayer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _nNeurons, _nInputs):
        r"""
        __init__(FCLLayer self, int _nNeurons, int _nInputs) -> FCLLayer

        Parameters
        ----------
        _nNeurons: int
        _nInputs: int

        """
        _feedforward_closedloop_learning.FCLLayer_swiginit(self, _feedforward_closedloop_learning.new_FCLLayer(_nNeurons, _nInputs))
    __swig_destroy__ = _feedforward_closedloop_learning.delete_FCLLayer
    WEIGHT_NORM_NONE = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_NONE
    
    WEIGHT_NORM_LAYER_EUCLEDIAN = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_LAYER_EUCLEDIAN
    
    WEIGHT_NORM_NEURON_EUCLEDIAN = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_NEURON_EUCLEDIAN
    
    WEIGHT_NORM_LAYER_MANHATTAN = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_LAYER_MANHATTAN
    
    WEIGHT_NORM_NEURON_MANHATTAN = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_NEURON_MANHATTAN
    
    WEIGHT_NORM_LAYER_INFINITY = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_LAYER_INFINITY
    
    WEIGHT_NORM_NEURON_INFINITY = _feedforward_closedloop_learning.FCLLayer_WEIGHT_NORM_NEURON_INFINITY
    

    def calcOutputs(self):
        r"""calcOutputs(FCLLayer self)"""
        return _feedforward_closedloop_learning.FCLLayer_calcOutputs(self)

    def doLearning(self):
        r"""doLearning(FCLLayer self)"""
        return _feedforward_closedloop_learning.FCLLayer_doLearning(self)

    def setError(self, *args):
        r"""
        setError(FCLLayer self, double _error)

        Parameters
        ----------
        _error: double

        setError(FCLLayer self, int i, double _error)

        Parameters
        ----------
        i: int
        _error: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setError(self, *args)

    def setErrors(self, _errors):
        r"""
        setErrors(FCLLayer self, double * _errors)

        Parameters
        ----------
        _errors: double *

        """
        return _feedforward_closedloop_learning.FCLLayer_setErrors(self, _errors)

    def getError(self, i):
        r"""
        getError(FCLLayer self, int i) -> double

        Parameters
        ----------
        i: int

        """
        return _feedforward_closedloop_learning.FCLLayer_getError(self, i)

    def setBias(self, _bias):
        r"""
        setBias(FCLLayer self, double _bias)

        Parameters
        ----------
        _bias: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setBias(self, _bias)

    def setInput(self, inputIndex, input):
        r"""
        setInput(FCLLayer self, int inputIndex, double input)

        Parameters
        ----------
        inputIndex: int
        input: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setInput(self, inputIndex, input)

    def setInputs(self, _inputs):
        r"""
        setInputs(FCLLayer self, double const * _inputs)

        Parameters
        ----------
        _inputs: double const *

        """
        return _feedforward_closedloop_learning.FCLLayer_setInputs(self, _inputs)

    def setLearningRate(self, _learningRate):
        r"""
        setLearningRate(FCLLayer self, double _learningRate)

        Parameters
        ----------
        _learningRate: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setLearningRate(self, _learningRate)

    def setActivationFunction(self, _activationFunction):
        r"""
        setActivationFunction(FCLLayer self, FCLNeuron::ActivationFunction _activationFunction)

        Parameters
        ----------
        _activationFunction: enum FCLNeuron::ActivationFunction

        """
        return _feedforward_closedloop_learning.FCLLayer_setActivationFunction(self, _activationFunction)

    def setMomentum(self, _momentum):
        r"""
        setMomentum(FCLLayer self, double _momentum)

        Parameters
        ----------
        _momentum: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setMomentum(self, _momentum)

    def setDecay(self, _decay):
        r"""
        setDecay(FCLLayer self, double _decay)

        Parameters
        ----------
        _decay: double

        """
        return _feedforward_closedloop_learning.FCLLayer_setDecay(self, _decay)

    def initWeights(self, *args):
        r"""
        initWeights(FCLLayer self, double _max=1, int initBiasWeight=1, FCLNeuron::WeightInitMethod weightInitMethod=MAX_OUTPUT_RANDOM)

        Parameters
        ----------
        _max: double
        initBiasWeight: int
        weightInitMethod: enum FCLNeuron::WeightInitMethod

        """
        return _feedforward_closedloop_learning.FCLLayer_initWeights(self, *args)

    def getOutput(self, index):
        r"""
        getOutput(FCLLayer self, int index) -> double

        Parameters
        ----------
        index: int

        """
        return _feedforward_closedloop_learning.FCLLayer_getOutput(self, index)

    def getNeuron(self, index):
        r"""
        getNeuron(FCLLayer self, int index) -> FCLNeuron

        Parameters
        ----------
        index: int

        """
        return _feedforward_closedloop_learning.FCLLayer_getNeuron(self, index)

    def getNneurons(self):
        r"""getNneurons(FCLLayer self) -> int"""
        return _feedforward_closedloop_learning.FCLLayer_getNneurons(self)

    def getNinputs(self):
        r"""getNinputs(FCLLayer self) -> int"""
        return _feedforward_closedloop_learning.FCLLayer_getNinputs(self)

    def setConvolution(self, *args):
        r"""
        setConvolution(FCLLayer self, int width, int height)

        Parameters
        ----------
        width: int
        height: int

        setConvolution(FCLLayer self, int width)

        Parameters
        ----------
        width: int

        """
        return _feedforward_closedloop_learning.FCLLayer_setConvolution(self, *args)

    def setMaxDetLayer(self, _m):
        r"""
        setMaxDetLayer(FCLLayer self, int _m)

        Parameters
        ----------
        _m: int

        """
        return _feedforward_closedloop_learning.FCLLayer_setMaxDetLayer(self, _m)

    def setNormaliseWeights(self, _normaliseWeights):
        r"""
        setNormaliseWeights(FCLLayer self, FCLLayer::WeightNormalisation _normaliseWeights)

        Parameters
        ----------
        _normaliseWeights: enum FCLLayer::WeightNormalisation

        """
        return _feedforward_closedloop_learning.FCLLayer_setNormaliseWeights(self, _normaliseWeights)

    def setDebugInfo(self, layerIndex):
        r"""
        setDebugInfo(FCLLayer self, int layerIndex)

        Parameters
        ----------
        layerIndex: int

        """
        return _feedforward_closedloop_learning.FCLLayer_setDebugInfo(self, layerIndex)

    def setStep(self, step):
        r"""
        setStep(FCLLayer self, long step)

        Parameters
        ----------
        step: long

        """
        return _feedforward_closedloop_learning.FCLLayer_setStep(self, step)

    def getWeightDistanceFromInitialWeights(self):
        r"""getWeightDistanceFromInitialWeights(FCLLayer self) -> double"""
        return _feedforward_closedloop_learning.FCLLayer_getWeightDistanceFromInitialWeights(self)

    def doNormaliseWeights(self):
        r"""doNormaliseWeights(FCLLayer self)"""
        return _feedforward_closedloop_learning.FCLLayer_doNormaliseWeights(self)

    def setUseThreads(self, _useThreads):
        r"""
        setUseThreads(FCLLayer self, int _useThreads)

        Parameters
        ----------
        _useThreads: int

        """
        return _feedforward_closedloop_learning.FCLLayer_setUseThreads(self, _useThreads)

    def saveWeightMatrix(self, filename):
        r"""
        saveWeightMatrix(FCLLayer self, char * filename) -> int

        Parameters
        ----------
        filename: char *

        """
        return _feedforward_closedloop_learning.FCLLayer_saveWeightMatrix(self, filename)

# Register FCLLayer in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.FCLLayer_swigregister(FCLLayer)
class FCLNeuron(object):
    r"""Proxy of C++ FCLNeuron class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _nInputs):
        r"""
        __init__(FCLNeuron self, int _nInputs) -> FCLNeuron

        Parameters
        ----------
        _nInputs: int

        """
        _feedforward_closedloop_learning.FCLNeuron_swiginit(self, _feedforward_closedloop_learning.new_FCLNeuron(_nInputs))
    __swig_destroy__ = _feedforward_closedloop_learning.delete_FCLNeuron

    def calcOutput(self):
        r"""calcOutput(FCLNeuron self)"""
        return _feedforward_closedloop_learning.FCLNeuron_calcOutput(self)

    @staticmethod
    def calcOutputThread(object):
        r"""
        calcOutputThread(void * object) -> void *

        Parameters
        ----------
        object: void *

        """
        return _feedforward_closedloop_learning.FCLNeuron_calcOutputThread(object)

    def doLearning(self):
        r"""doLearning(FCLNeuron self)"""
        return _feedforward_closedloop_learning.FCLNeuron_doLearning(self)

    @staticmethod
    def doLearningThread(object):
        r"""
        doLearningThread(void * object) -> void *

        Parameters
        ----------
        object: void *

        """
        return _feedforward_closedloop_learning.FCLNeuron_doLearningThread(object)

    def doMaxDet(self):
        r"""doMaxDet(FCLNeuron self)"""
        return _feedforward_closedloop_learning.FCLNeuron_doMaxDet(self)

    @staticmethod
    def doMaxDetThread(object):
        r"""
        doMaxDetThread(void * object) -> void *

        Parameters
        ----------
        object: void *

        """
        return _feedforward_closedloop_learning.FCLNeuron_doMaxDetThread(object)
    MAX_OUTPUT_RANDOM = _feedforward_closedloop_learning.FCLNeuron_MAX_OUTPUT_RANDOM
    
    MAX_WEIGHT_RANDOM = _feedforward_closedloop_learning.FCLNeuron_MAX_WEIGHT_RANDOM
    
    MAX_OUTPUT_CONST = _feedforward_closedloop_learning.FCLNeuron_MAX_OUTPUT_CONST
    
    CONST_WEIGHTS = _feedforward_closedloop_learning.FCLNeuron_CONST_WEIGHTS
    

    def initWeights(self, *args):
        r"""
        initWeights(FCLNeuron self, double _max=1, int initBias=1, FCLNeuron::WeightInitMethod _wm=MAX_OUTPUT_RANDOM)

        Parameters
        ----------
        _max: double
        initBias: int
        _wm: enum FCLNeuron::WeightInitMethod

        """
        return _feedforward_closedloop_learning.FCLNeuron_initWeights(self, *args)
    LINEAR = _feedforward_closedloop_learning.FCLNeuron_LINEAR
    
    TANH = _feedforward_closedloop_learning.FCLNeuron_TANH
    
    RELU = _feedforward_closedloop_learning.FCLNeuron_RELU
    
    REMAXLU = _feedforward_closedloop_learning.FCLNeuron_REMAXLU
    
    TANHLIMIT = _feedforward_closedloop_learning.FCLNeuron_TANHLIMIT
    

    def setActivationFunction(self, _activationFunction):
        r"""
        setActivationFunction(FCLNeuron self, FCLNeuron::ActivationFunction _activationFunction)

        Parameters
        ----------
        _activationFunction: enum FCLNeuron::ActivationFunction

        """
        return _feedforward_closedloop_learning.FCLNeuron_setActivationFunction(self, _activationFunction)

    def dActivation(self):
        r"""dActivation(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_dActivation(self)

    def getMinWeightValue(self):
        r"""getMinWeightValue(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getMinWeightValue(self)

    def getMaxWeightValue(self):
        r"""getMaxWeightValue(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getMaxWeightValue(self)

    def getWeightDistanceFromInitialWeights(self):
        r"""getWeightDistanceFromInitialWeights(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getWeightDistanceFromInitialWeights(self)

    def getOutput(self):
        r"""getOutput(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getOutput(self)

    def getSum(self):
        r"""getSum(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getSum(self)

    def getWeight(self, _index):
        r"""
        getWeight(FCLNeuron self, int _index) -> double

        Parameters
        ----------
        _index: int

        """
        return _feedforward_closedloop_learning.FCLNeuron_getWeight(self, _index)

    def setWeight(self, _index, _weight):
        r"""
        setWeight(FCLNeuron self, int _index, double _weight)

        Parameters
        ----------
        _index: int
        _weight: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setWeight(self, _index, _weight)

    def setError(self, _error):
        r"""
        setError(FCLNeuron self, double _error)

        Parameters
        ----------
        _error: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setError(self, _error)

    def getError(self):
        r"""getError(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getError(self)

    def setInput(self, _index, _value):
        r"""
        setInput(FCLNeuron self, int _index, double _value)

        Parameters
        ----------
        _index: int
        _value: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setInput(self, _index, _value)

    def getInput(self, _index):
        r"""
        getInput(FCLNeuron self, int _index) -> double

        Parameters
        ----------
        _index: int

        """
        return _feedforward_closedloop_learning.FCLNeuron_getInput(self, _index)

    def getBiasWeight(self):
        r"""getBiasWeight(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getBiasWeight(self)

    def setBiasWeight(self, _biasweight):
        r"""
        setBiasWeight(FCLNeuron self, double _biasweight)

        Parameters
        ----------
        _biasweight: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setBiasWeight(self, _biasweight)

    def setBias(self, _bias):
        r"""
        setBias(FCLNeuron self, double _bias)

        Parameters
        ----------
        _bias: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setBias(self, _bias)

    def setLearningRate(self, _learningrate):
        r"""
        setLearningRate(FCLNeuron self, double _learningrate)

        Parameters
        ----------
        _learningrate: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setLearningRate(self, _learningrate)

    def setMomentum(self, _momentum):
        r"""
        setMomentum(FCLNeuron self, double _momentum)

        Parameters
        ----------
        _momentum: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setMomentum(self, _momentum)

    def setDecay(self, _decay):
        r"""
        setDecay(FCLNeuron self, double _decay)

        Parameters
        ----------
        _decay: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_setDecay(self, _decay)

    def getDecay(self):
        r"""getDecay(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getDecay(self)

    def getNinputs(self):
        r"""getNinputs(FCLNeuron self) -> int"""
        return _feedforward_closedloop_learning.FCLNeuron_getNinputs(self)

    def setGeometry(self, _width, _height):
        r"""
        setGeometry(FCLNeuron self, int _width, int _height)

        Parameters
        ----------
        _width: int
        _height: int

        """
        return _feedforward_closedloop_learning.FCLNeuron_setGeometry(self, _width, _height)

    def setMask(self, *args):
        r"""
        setMask(FCLNeuron self, int x, int y, unsigned char c)

        Parameters
        ----------
        x: int
        y: int
        c: unsigned char

        setMask(FCLNeuron self, int const x, unsigned char const c)

        Parameters
        ----------
        x: int const
        c: unsigned char const

        setMask(FCLNeuron self, unsigned char c)

        Parameters
        ----------
        c: unsigned char

        """
        return _feedforward_closedloop_learning.FCLNeuron_setMask(self, *args)

    def getMask(self, *args):
        r"""
        getMask(FCLNeuron self, int x, int y) -> unsigned char

        Parameters
        ----------
        x: int
        y: int

        getMask(FCLNeuron self, int index) -> unsigned char

        Parameters
        ----------
        index: int

        """
        return _feedforward_closedloop_learning.FCLNeuron_getMask(self, *args)

    def getSumOfSquaredWeightVector(self):
        r"""getSumOfSquaredWeightVector(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getSumOfSquaredWeightVector(self)

    def getEuclideanNormOfWeightVector(self):
        r"""getEuclideanNormOfWeightVector(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getEuclideanNormOfWeightVector(self)

    def getManhattanNormOfWeightVector(self):
        r"""getManhattanNormOfWeightVector(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getManhattanNormOfWeightVector(self)

    def getInfinityNormOfWeightVector(self):
        r"""getInfinityNormOfWeightVector(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getInfinityNormOfWeightVector(self)

    def getAverageOfWeightVector(self):
        r"""getAverageOfWeightVector(FCLNeuron self) -> double"""
        return _feedforward_closedloop_learning.FCLNeuron_getAverageOfWeightVector(self)

    def normaliseWeights(self, norm):
        r"""
        normaliseWeights(FCLNeuron self, double norm)

        Parameters
        ----------
        norm: double

        """
        return _feedforward_closedloop_learning.FCLNeuron_normaliseWeights(self, norm)

    def saveInitialWeights(self):
        r"""saveInitialWeights(FCLNeuron self)"""
        return _feedforward_closedloop_learning.FCLNeuron_saveInitialWeights(self)

    def setDebugInfo(self, _layerIndex, _neuronIndex):
        r"""
        setDebugInfo(FCLNeuron self, int _layerIndex, int _neuronIndex)

        Parameters
        ----------
        _layerIndex: int
        _neuronIndex: int

        """
        return _feedforward_closedloop_learning.FCLNeuron_setDebugInfo(self, _layerIndex, _neuronIndex)

    def setStep(self, _step):
        r"""
        setStep(FCLNeuron self, long _step)

        Parameters
        ----------
        _step: long

        """
        return _feedforward_closedloop_learning.FCLNeuron_setStep(self, _step)

# Register FCLNeuron in _feedforward_closedloop_learning:
_feedforward_closedloop_learning.FCLNeuron_swigregister(FCLNeuron)

