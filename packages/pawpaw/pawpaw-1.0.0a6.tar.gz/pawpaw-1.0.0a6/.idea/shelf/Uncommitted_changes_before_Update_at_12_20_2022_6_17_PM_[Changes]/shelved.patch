Index: docs/6. Xml.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># XML\r\n\r\n## Introduction\r\n\r\nPawpaw provides offers enhanced XML processing capabilities in its ``xml`` namespace.  Functionality is present in two main classes:\r\n\r\n* ``XmlParser``\r\n* ``XmlHelper``\r\n\r\n## XmlParser\r\n\r\nPawpaw's ``XmlParser`` is a drop-in replacement for Python's ``ElementTree.XmlParser``.  Both return identical graphs of ``Element``\r\nobjects, however, the ``Element`` objects produced by the Pawpaw parser are decorated with an additional ``.ito`` attribute that\r\nreturns a corresponding ``Ito`` corresponding to the substring the ``Element`` was extracted from.  These ``Ito`` objects, in turn, have\r\ntheir ``.value`` method overriden to return their associated ``Element`` objects.  All of the ``Ito`` objects are fully hierarchical\r\nwith one another back to the topmost (root) node of the overall XML document, and have children corresponding to tags, attributes,\r\nand text.\r\n\r\nUsing the PawPaw parser results in two, parallel datastructures that are cross-linked to each other at every element.  This allows\r\nyou to use *either* data structure where convenient.  You can even swtich back and forth as needed.\r\n\r\n```python\r\n>>> root.find('*').ito.find(f'*[d:{xml.descriptors.TEXT}]')  # Get untransformed text of element\r\n```\r\n\r\n## Usage\r\n\r\nPawpaw's ``XmlParser`` dervies from ``xml.ElementTree.XmlParser``, which by default, uses a C implementation.  However, in order to hook\r\ncertain methods, the Python implementation must be used instead.  This can be achieved by adding the following statements to you\r\nimport section before any references are made to ``xml.ElementTree``:\r\n\r\n```python\r\n>>> import sys\r\n>>> # Force Python XML parser, not faster C version so that we can hook methods\r\n>>> sys.modules['_elementtree'] = None\r\n```\r\n\r\nFrom here, using Pawpaw's XmlParser is straightforward:\r\n\r\n```python\r\n>>> import xml.etree.ElementTree as ET\r\n>>> from pawpaw import xml\r\n>>> \r\n>>> text = \"\"\"<?xml version=\"1.0\"?>\r\n... <music xmlns:mb=\"http://musicbrainz.org/ns/mmd-1.0#\" xmlns=\"http://mymusic.org/xml/\">\r\n...     <album genre=\"R&amp;B\" mb:id=\"123-456-789-0\">\r\n...         Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->\r\n...     </album>\r\n... </music>\"\"\"\r\n>>> \r\n>>> root = ET.fromstring(text, parser=xml.XmlParser())\r\n```\r\n\r\nAt this point root is a *normal* ``ElementTree.Element``[^f_str_expr]:\r\n\r\n```python\r\n>>> f'{type(root)=}'\r\n\"type(root)=<class 'xml.etree.ElementTree.Element'>\"\r\n>>> f'{root=}'\r\n\"type(root)=<class 'xml.etree.ElementTree.Element'>\"\r\n```\r\n\r\nAnd it also has an additional ``.ito`` attribute:\r\n\r\n```python\r\n>>> from pawpaw.visualization import pepo\r\n>>> print(pepo.Tree().dumps(root.ito))\r\n(22, 244) 'element' : '<music xmlns:mb=\"http://musicbrainz.or…\r\n├──(22, 107) 'start_tag' : '<music xmlns:mb=\"http://musicbrainz.or…\r\n│  ├──(23, 28) 'tag' : 'music'\r\n│  │  └──(23, 28) 'name' : 'music'\r\n│  ├──(29, 74) 'attribute' : 'xmlns:mb=\"http://musicbrainz.org/ns/mm…\r\n│  │  ├──(29, 34) 'namespace' : 'xmlns'\r\n│  │  ├──(35, 37) 'name' : 'mb'\r\n│  │  └──(39, 73) 'value' : 'http://musicbrainz.org/ns/mmd-1.0#'\r\n│  └──(75, 106) 'attribute' : 'xmlns=\"http://mymusic.org/xml/\"'\r\n│     ├──(75, 80) 'name' : 'xmlns'\r\n│     └──(82, 105) 'value' : 'http://mymusic.org/xml/'\r\n├──(112, 235) 'element' : '<album genre=\"R&amp;B\" mb:id=\"123-456-…\r\n│  ├──(112, 157) 'start_tag' : '<album genre=\"R&amp;B\" mb:id=\"123-456-…\r\n│  │  ├──(113, 118) 'tag' : 'album'\r\n│  │  │  └──(113, 118) 'name' : 'album'\r\n│  │  ├──(119, 134) 'attribute' : 'genre=\"R&amp;B\"'\r\n│  │  │  ├──(119, 124) 'name' : 'genre'\r\n│  │  │  └──(126, 133) 'value' : 'R&amp;B'\r\n│  │  └──(135, 156) 'attribute' : 'mb:id=\"123-456-789-0\"'\r\n│  │     ├──(135, 137) 'namespace' : 'mb'\r\n│  │     ├──(138, 140) 'name' : 'id'\r\n│  │     └──(142, 155) 'value' : '123-456-789-0'\r\n│  ├──(157, 227) 'text' : '\\n        Robson Jorge &amp; Lincoln O…\r\n│  │  └──(202, 222) 'comment' : '<!-- 1982, Vinyl -->'\r\n│  │     └──(206, 219) 'value' : ' 1982, Vinyl '\r\n│  └──(227, 235) 'end_tag' : '</album>'\r\n└──(236, 244) 'end_tag' : '</music>'\r\n```\r\n\r\nThe descriptors for the Ito tree are defined in pawpaw.xml.descriptors:\r\n\r\n```python\r\nATTRIBUTE: str = 'attribute'\r\nCOMMENT: str = 'comment'\r\nELEMENT: str = 'element'\r\nEND_TAG: str = 'end_tag'\r\nNAME: str = 'name'\r\nNAMESPACE: str = 'namespace'\r\nSTART_TAG: str = 'start_tag'\r\nTAG: str = 'tag'\r\nTEXT: str = 'text'\r\nVALUE: str = 'value'\r\n```\r\n\r\nYou can use the literals or constants in your code.\r\n\r\n```python\r\n>>> str(root.ito.find('*[d:end_tag]'))\r\n'</music>'\r\n>>> str(root.ito.find(f'*[d:{xml.descriptors.END_TAG}]'))\r\n'</music>'\r\n```\r\n\r\nNote that XmlParsers are *transformational*, i.e., the resulting ``Element`` objects have text that may be altered from the original, underlying xml:\r\n\r\n* xmlns attributes are removed\r\n* Namespace keys for entity tags & attribute names are replaced with full-namespace values\r\n  - 'mb:id' -> '{ht<span>tp://</span>musicbrainz.org/ns/mmd-1.0#}id'\r\n* Entity references converted to characters\r\n  - '&amp;' -> '&'\r\n* Comments and processing instructions removed[^TreeBuilder]\r\n  - 'Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->' -> 'Robson Jorge &amp; Lincoln Olivetti'\r\n\r\nMost of the time, these types of transformations are exactly what you need.  However, in some cases you may need access to the original underlying text\r\n(or even just the offsets.)  This is where Pawpaw comes in.  For example, let's say you need to access the xml comment:\r\n\r\n```python\r\n>>> child = root[0]  # First and only child\r\n>>>\r\n>>> child.text  # Element.text has entities converted and comments stripped\r\n'\\n        Robson Jorge & Lincoln Olivetti \\n    '\r\n>>>\r\n>>> i = child.ito.find(f'*[d:{xml.descriptors.TEXT}]')  # Plumule query to find element's text\r\n>>> str(i)  # Show text as it appears in actual xml\r\n'\\n        Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->\\n    '\r\n>>>\r\n>>> c = i.find(f'*[d:{xml.descriptors.COMMENT}]')  # Get comment\r\n>>> f'{c:%span %substr!r}  # Display comment (show span and substr repr)\r\n\"(223, 242) '<!-- 1982 Vinyl -->'\"\r\n```\r\n\r\nXmlHelper\r\n=========\r\n\r\nPawpaw's ``XmlHelper`` offers a variety of useful methods for working with Element data.\r\n\r\n* ``get_qualified_name``\r\n* ``get_xmlns``\r\n* ``get_prefix_map`` : Builds a prefix dict suitable for passing to ET methods such as Element.find('foo:goo', prefix_map); keys & values are suitable for passing to xml.etree.ElementTree.register_namespace``, ``.find``, or ``.findall methods``\r\n* ``get_default_namespace``\r\n* ``get_element_text_if_found``\r\n* ``get_local_name``\r\n* ``get_namespace``\r\n* ``find_all_descendants_by_local_name``\r\n* ``find_descendant_by_local_name``\r\n* ``reverse_find``\r\n\r\n[^f_str_expr]: If this format string looks strange to you, note that as of Python 3.8, format strings support `self-documenting expressions <https://docs.python.org/3/whatsnew/3.8.html#f-strings-support-for-self-documenting-expressions-and-debugging>`_.\r\n\r\n[^TreeBuilder]: As of Python 3.8, you can pass a reference to a ``TreeBuilder`` to ``ElementTree.XmlParser`` to define how you want comments and processing\r\ninstructions handled.  However, this behavior results in additional ``Element`` objects containing the comments and/or processing instructions, which\r\nresults in an awkward tree structure that has less correspondance to the underlying XML document\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/6. Xml.md b/docs/6. Xml.md
--- a/docs/6. Xml.md	(revision 72d83f4d3a0ab80c95b3bcab0ccc69843c097091)
+++ b/docs/6. Xml.md	(date 1671288929384)
@@ -41,8 +41,7 @@
 >>> import xml.etree.ElementTree as ET
 >>> from pawpaw import xml
 >>> 
->>> text = """<?xml version="1.0"?>
-... <music xmlns:mb="http://musicbrainz.org/ns/mmd-1.0#" xmlns="http://mymusic.org/xml/">
+>>> text = """<music xmlns:mb="http://musicbrainz.org/ns/mmd-1.0#" xmlns="http://mymusic.org/xml/">
 ...     <album genre="R&amp;B" mb:id="123-456-789-0">
 ...         Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->
 ...     </album>
@@ -60,7 +59,7 @@
 "type(root)=<class 'xml.etree.ElementTree.Element'>"
 ```
 
-And it also has an additional ``.ito`` attribute:
+And it also has an additional ``.ito`` attribute, which itself is the root of a Tree corresponding to the xml:
 
 ```python
 >>> from pawpaw.visualization import pepo
@@ -94,7 +93,7 @@
 └──(236, 244) 'end_tag' : '</music>'
 ```
 
-The descriptors for the Ito tree are defined in pawpaw.xml.descriptors:
+The descriptors used for the tree elements are defined in pawpaw.xml.descriptors:
 
 ```python
 ATTRIBUTE: str = 'attribute'
@@ -109,7 +108,7 @@
 VALUE: str = 'value'
 ```
 
-You can use the literals or constants in your code.
+You can use either these named constants or their associated literals in your code:
 
 ```python
 >>> str(root.ito.find('*[d:end_tag]'))
@@ -118,17 +117,19 @@
 '</music>'
 ```
 
-Note that XmlParsers are *transformational*, i.e., the resulting ``Element`` objects have text that may be altered from the original, underlying xml:
+Note that ``ElementTree.XmlParser`` is *non-complete* and *transformational*, i.e., not all text in the underlying xml has is mapped
+to the resulting ``Element``  objects, and some text is altered:
 
 * xmlns attributes are removed
 * Namespace keys for entity tags & attribute names are replaced with full-namespace values
   - 'mb:id' -> '{ht<span>tp://</span>musicbrainz.org/ns/mmd-1.0#}id'
 * Entity references converted to characters
   - '&amp;' -> '&'
+* Whitespace-only text is not added to ``.text`` or ``.tail``
 * Comments and processing instructions removed[^TreeBuilder]
   - 'Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->' -> 'Robson Jorge &amp; Lincoln Olivetti'
 
-Most of the time, these types of transformations are exactly what you need.  However, in some cases you may need access to the original underlying text
+Most of the time, this behavior is exactly what you want.  However, in some cases you may need access to the original underlying text
 (or even just the offsets.)  This is where Pawpaw comes in.  For example, let's say you need to access the xml comment:
 
 ```python
Index: tinker.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\n# Force Python XML parser, not faster C version so that we can hook methods\r\nsys.modules['_elementtree'] = None\r\nimport xml.etree.ElementTree as ET\r\nfrom dataclasses import dataclass, field\r\n\r\nimport regex\r\nimport pawpaw\r\nfrom pawpaw import Ito\r\nfrom pawpaw.visualization import sgr, Highlighter, pepo\r\n\r\n\r\nimport xml.etree.ElementTree as ET\r\nfrom pawpaw import xml\r\ntext = \"\"\"<?xml version=\"1.0\"?>\r\n<music xmlns:mb=\"http://musicbrainz.org/ns/mmd-1.0#\" xmlns=\"http://mymusic.org/xml/\">\r\n    <album genre=\"R&amp;B\" mb:id=\"123-456-789-0\">\r\n        Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->\r\n    </album>\r\n</music>\"\"\"\r\nroot = ET.fromstring(text, parser=xml.XmlParser())\r\nprint(f'{type(root)=}')\r\nprint()\r\n\r\nfrom pawpaw.visualization import pepo\r\nprint(pepo.Tree().dumps(root.ito))\r\nexit(0)\r\n\r\n\r\n\r\nv_compact = pepo.Compact()\r\nv_tree = pepo.Tree()\r\nv_xml = pepo.Xml()\r\nv_json = pepo.Json()\r\n\r\n\r\nimport requests\r\nimport pawpaw\r\n\r\nsleepy_hollow = 'https://www.gutenberg.org/ebooks/41.txt.utf-8'\r\nwith requests.get(sleepy_hollow) as r:\r\n    root = pawpaw.nlp.SimpleNlp().from_text(r.text)\r\nfor para in root.children[-10:]:\r\n    print(pawpaw.visualization.pepo.Tree().dumps(para))\r\nexit(0)\r\n\r\n\r\n\r\n\r\ns = ' The quick brown fox. '\r\ni = Ito(s, 1, -1)\r\ni.children.add(*i.str_split())\r\n# for c in i.children:\r\n#     c.children.add(*c)\r\n\r\nfor result in i.find_all('*([s:The] | ~[s:quick]) & [s:brown]'):\r\n    print(v_compact.dumps(result))\r\nexit(0)\r\n\r\n# TODO: Make query tests for:\r\n# even/odd '~'\r\n# precedence\r\n# parens: '*([s:The] | ~[s:quick]) & [s:brown]' versus '*[s:The] | (~[s:quick]) & [s:brown])'\r\n# ensure '~' in 'A & (~(B | C))' is considered against (B | C), not against B\r\n\r\nimport pawpaw.visualization.ascii_box as box\r\n\r\nboxer = box.Box(vertical_style=box.Style(count=box.Style.Count.PARALLEL))\r\nfor line in boxer.from_text('The quick\\nbrown fox\\njumped over the lazy\\ndogs.'):\r\n    print(line)\r\n\r\nexit(0)\r\n\r\nchars = set()\r\nfor orientation in box.Side.Orientation:\r\n    print(f'Orientation: {orientation}')\r\n    for count in box.Style.Count:\r\n        for weight in box.Style.Weight:\r\n            style = box.Style(weight, count)\r\n            try:\r\n                side = box.Side(style)\r\n                char = side[orientation]\r\n                chars.add(char)\r\n                print(f'\\t{char}')\r\n            except:\r\n                pass\r\n\r\nprint(f'Expected Side character count: {len(box.Side._characters):n}')\r\nprint(f'Actual Side character count: {len(chars):n}')\r\n\r\nprint()\r\n\r\nchars = set()\r\nfor orientation in box.Side.Orientation:\r\n    print(f'Orientation: {orientation}')\r\n    for hcount in box.Style.Count:\r\n        for hweight in box.Style.Weight:\r\n            hz_style = box.Style(hweight, hcount)\r\n            for vcount in box.Style.Count:\r\n                for vweight in box.Style.Weight:\r\n                    vt_style = box.Style(vweight, vcount)\r\n                    try:\r\n                        corner = box.Corner(hz_style, vt_style)\r\n                        char = corner[orientation]\r\n                        chars.add(char)\r\n                        print(f'\\t{char}')\r\n                    except:\r\n                        pass\r\n\r\nprint(f'Expected Corner character count: {len(box.Corner._characters):n}')\r\nprint(f'Actual Corner character count: {len(chars):n}')\r\n\r\nexit(0)\r\n\r\nimport nltk\r\n\r\ns = 'Here is one sentence.  Here is another.'\r\ni = Ito(s)\r\n\r\nnltk_tok = nltk.tokenize\r\nsent_itor = pawpaw.arborform.Wrap(lambda ito: ito.from_substrings(ito, *nltk_tok.sent_tokenize(str(ito))))\r\n\r\nword_itor = pawpaw.arborform.Wrap(lambda ito: ito.from_substrings(ito, *nltk_tok.word_tokenize(str(ito))))\r\nsent_itor.itor_children = word_itor\r\n\r\ni.children.add(*(sent_itor.traverse(i)))\r\nprint(v_tree.dumps(i))\r\nexit(0)\r\n\r\n\r\nws_tok = nltk.tokenize.WhitespaceTokenizer()\r\nsplitter = pawpaw.arborform.Split(regex.compile(ws_tok._pattern, ws_tok._flags))\r\ni = pawpaw.Ito('The quick brown fox.')\r\n[str(i) for i in splitter.traverse(i)]\r\n\r\n\r\n\r\n\r\n# # VERSION\r\n#\r\n# print(pawpaw.__version__)\r\n# print(pawpaw.__version__.major)\r\n# print(pawpaw.__version__.pre_release)\r\n# print(pawpaw.__version__._asdict())\r\n# exit(0)\r\n\r\nfrom pawpaw.arborform.itorator import Desc, Extract, Split, Wrap\r\n\r\ns = 'nine 9 ten 10 eleven 11 TWELVE 12 thirteen 13'\r\nre = regex.compile(r'(?P<phrase>(?P<word>(?P<char>\\w)+) (?P<number>(?P<digit>\\d)+)\\s*)+')\r\nmatch = re.fullmatch(s)\r\n\r\nroot = Ito.from_match_super2(match)\r\nprint(dump.Compact().dumps(root))\r\nexit(0)\r\n\r\nroot = next(Ito.from_match(re, s))\r\n# print(*root.find_all('**[d:digit]'), sep=', ')  # print all digits\r\n# print(*root.find_all('**[d:number]{</*[s:i]}'), sep=',')  # print numbers having leter 'i' in their names\r\n\r\n\r\nroot = Ito(s, desc='root')\r\n\r\nphrases = Split(regex.compile('(?<=\\d )'), desc='Phrase')\r\n\r\nwrds_nums = Extract(regex.compile(r'(?P<word>[a-z]+) (?P<number>\\d+)'))\r\nphrases.itor_children = wrds_nums\r\n\r\nchrs_digs = Extract(regex.compile(r'(?P<char>[a-z])+|(?P<digit>\\d)+'))\r\nwrds_nums.itor_children = chrs_digs\r\n\r\nroot.children.add(*phrases.traverse(root))\r\n\r\nprint(dump.Compact().dumps(root))\r\nexit(0)\r\n\r\n    \r\n# SGR    \r\n\r\nfor effect in sgr.Intensity, sgr.Italic, sgr.Underline, sgr.Blink, sgr.Invert, sgr.Conceal, sgr.Strike, sgr.Font, sgr.Fore, sgr.Back:\r\n    print(f'{effect.__name__.upper()}')\r\n    \r\n    if effect in (sgr.Fore, sgr.Back):\r\n        attrs = {nc.name: effect(nc) for nc in sgr.Colors.Named}\r\n    else:\r\n        names = filter(lambda n: n.isupper() and not n.startswith('_') and not n.startswith('RESET'), dir(effect))\r\n        attrs = {name: getattr(effect, name) for name in names}\r\n        \r\n    for name, attr in attrs.items():\r\n        print(f'\\t{name}: Before Sgr... {attr}Sgr applied!{effect.RESET} Sgr turned off.')\r\n    \r\n    print()\r\n\r\nfrom random import randint\r\n\r\nfor line in range(1, 50):\r\n    for color in sgr.Fore, sgr.Back:\r\n        for col in range(1, 120):\r\n            rgb = sgr.Colors.Rgb(randint(0, 255), randint(0, 255), randint(0, 255))\r\n            print(effect(rgb), end='')\r\n            print(chr(ord('A') + randint(0, 25)) + effect.RESET, end='')\r\n        print()\r\n\r\nexit()\r\n\r\n\r\n# HIGHLIGHTER\r\n\r\ns = 'The quick brown fox'\r\nito = pawpaw.Ito(s)\r\nito.children.add(*ito.split(regex.compile('\\s+')))\r\n\r\nhighlighter = Highlighter(\r\n    sgr.Colors.Named.BRIGHT_CYAN,\r\n    sgr.Colors.Named.CYAN,\r\n    sgr.Colors.Named.BRIGHT_BLUE,\r\n    sgr.Colors.Named.BLUE,\r\n    sgr.Colors.Named.MAGENTA,\r\n)\r\nhighlighter.print(ito)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tinker.py b/tinker.py
--- a/tinker.py	(revision 72d83f4d3a0ab80c95b3bcab0ccc69843c097091)
+++ b/tinker.py	(date 1671287426049)
@@ -14,6 +14,7 @@
 from pawpaw import xml
 text = """<?xml version="1.0"?>
 <music xmlns:mb="http://musicbrainz.org/ns/mmd-1.0#" xmlns="http://mymusic.org/xml/">
+    <?display table-view?>
     <album genre="R&amp;B" mb:id="123-456-789-0">
         Robson Jorge &amp; Lincoln Olivetti <!-- 1982, Vinyl -->
     </album>
