
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Developer guide &#8212; Bibulous 1.3.2 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Instructions on how to report a bug to the Bibulous development team" href="instructions_for_reporting_bugs.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/banner.svg" border="0" height=300 alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="instructions_for_reporting_bugs.html" title="Instructions on how to report a bug to the Bibulous development team"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo_small.svg" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Developer guide</a><ul>
<li><a class="reference internal" href="#guidelines-and-notes-for-python-coding-style">Guidelines and notes for Python coding style</a></li>
<li><a class="reference internal" href="#overall-project-strategy-and-code-structure">Overall project strategy and code structure</a></li>
<li><a class="reference internal" href="#parsing-bib-files">Parsing BIB files</a><ul>
<li><a class="reference internal" href="#parse-bibfile">parse_bibfile()</a></li>
<li><a class="reference internal" href="#parse-bibentry">parse_bibentry()</a></li>
<li><a class="reference internal" href="#parse-bibfield">parse_bibfield()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-aux-files">Parsing AUX files</a></li>
<li><a class="reference internal" href="#parsing-bst-files">Parsing BST files</a></li>
<li><a class="reference internal" href="#writing-the-bbl-file">Writing the BBL file</a></li>
<li><a class="reference internal" href="#name-formatting">Name formatting</a><ul>
<li><a class="reference internal" href="#create-namelist">create_namelist()</a></li>
<li><a class="reference internal" href="#format-namelist">format_namelist()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-sortkeys">Generating sortkeys</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#generating-the-documentation">Generating the documentation</a></li>
<li><a class="reference internal" href="#updating-the-pypi-package">Updating the PyPI package</a></li>
<li><a class="reference internal" href="#miscellaneous-notes">Miscellaneous notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="instructions_for_reporting_bugs.html"
                        title="previous chapter">Instructions on how to report a bug to the Bibulous development team</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">Examples</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/developer_guide.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="developer-guide">
<h1>Developer guide<a class="headerlink" href="#developer-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="guidelines-and-notes-for-python-coding-style">
<h2>Guidelines and notes for Python coding style<a class="headerlink" href="#guidelines-and-notes-for-python-coding-style" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Note that one can mix 8-bit Python strings (ASCII text) with UTF-8 encoded text as long as the 8-bit string contains only ASCII characters.</p>
</li>
<li><p class="first">Keep in mind when running into Unicode errors: reading a line of text from a file produces a line of bytes and not characters. To decode the bytes into a string of characters, you need to know the encoding.</p>
</li>
<li><p class="first">There are a couple of minor points where the Bibulous coding standards deviates from Python’s PEP8:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>A line width of 120 is the standard (not 80).</li>
<li>In general, statements that evaluate to a boolean are placed within parentheses (i.e. <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">b):</span></code> rather than <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b:</span></code>).</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Many developers prefer to spread out code among a large number of small files, but Bibulous is currently organized in a single large file. This is partly because there is no large block of code that fits by itself so that a separate file makes sense. (Parsing of <code class="docutils literal notranslate"><span class="pre">.bib</span></code> files, for example, only requires a couple hundred lines.</p>
</li>
</ol>
</div>
<div class="section" id="overall-project-strategy-and-code-structure">
<h2>Overall project strategy and code structure<a class="headerlink" href="#overall-project-strategy-and-code-structure" title="Permalink to this headline">¶</a></h2>
<p>The basic function of BibTeX is to accept an <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file as input and to produce a <code class="docutils literal notranslate"><span class="pre">.bbl</span></code> file as output. The <code class="docutils literal notranslate"><span class="pre">aux</span></code> file contains all of the citation information as well as the filenames for the bibliography database file (<code class="docutils literal notranslate"><span class="pre">.bib</span></code>) and the style file (<code class="docutils literal notranslate"><span class="pre">.bst</span></code>).</p>
<p>The basic program flow is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Read the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file and get the names of the bibliography databases (<code class="docutils literal notranslate"><span class="pre">.bib</span></code> files), the style templates (<code class="docutils literal notranslate"><span class="pre">.bst</span></code> files) to use, together with the entire set of citations.</li>
<li>Read in the Bibulous style template file as a dictionary (<code class="docutils literal notranslate"><span class="pre">bstdict</span></code>).</li>
<li>If the <code class="docutils literal notranslate"><span class="pre">use_citeextract</span></code> keyword is set to True, and if an “extracted” database file exists, then compare the citations in the extracted database against those in the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file. If there are any differences, then re-extract the database. Otherwise, use the extracted database rather than the full one specified in the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file.</li>
<li>Read in all of the bibliography database files into one long dictionary (<code class="docutils literal notranslate"><span class="pre">bibdata</span></code>), replacing any abbreviations with their full form. In an “extracted” database, all entries are parsed, whereas in any other type of database file, only those entries whose keywords are found in the citation list are actually parsed. All other entries have their data saved as unparsed strings. Cross-referenced data is <em>not</em> yet inserted at this point. That is delayed until the time of writing the BBL file in order to speed up parsing. It is only then that the cross-referenced entries have their data parsed into dictionary form.</li>
<li>Now that all the information is collected, we can generate the <code class="docutils literal notranslate"><span class="pre">.bbl</span></code> file. Create the list of sortkeys, then go through each corresponding citation key in turn, and find the corresponding entry key in <code class="docutils literal notranslate"><span class="pre">bibdata</span></code>. If there is crossref data, then fill in missing values here. Also create the “special variables” here. Finally, from the entry type, select a template from <code class="docutils literal notranslate"><span class="pre">bstdict</span></code> and begin inserting the variables one-by-one into the template.</li>
</ol>
</div></blockquote>
<p>Because the <code class="docutils literal notranslate"><span class="pre">.bib</span></code> file is highly structured, it is straightforward to write a parser by hand in Python: the <code class="docutils literal notranslate"><span class="pre">parse_bibfile()</span></code> method converts the <code class="docutils literal notranslate"><span class="pre">.bib</span></code> file contents into a Python dictionary (the <code class="docutils literal notranslate"><span class="pre">Bibdata</span></code> class’ <code class="docutils literal notranslate"><span class="pre">bibdata</span></code>). The <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file is even easier to parse, and the <code class="docutils literal notranslate"><span class="pre">parse_auxfile()</span></code> method converts the citation information into the <code class="docutils literal notranslate"><span class="pre">Bibdata</span></code> class’ <code class="docutils literal notranslate"><span class="pre">citedict</span></code> dictionary.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Bibdata</span></code> class thus holds all relevant information needed to operate on a bibliography and generate the output LaTeX-formatted <code class="docutils literal notranslate"><span class="pre">.bbl</span></code> file.</p>
</div>
<div class="section" id="parsing-bib-files">
<h2>Parsing BIB files<a class="headerlink" href="#parsing-bib-files" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parse-bibfile">
<h3>parse_bibfile()<a class="headerlink" href="#parse-bibfile" title="Permalink to this headline">¶</a></h3>
<p>The strategy for <code class="docutils literal notranslate"><span class="pre">parse_bibfile()</span></code> is to find each individual bibliography entry, determine its entry type, and save all of the text between the entry’s opening and closing braces as one long string, to be passed to <code class="docutils literal notranslate"><span class="pre">parse_bibentry()</span></code> for further parsing. To gather the entry data string, we first look for a line that starts with <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>. On that line, we look for a string after the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> followed by <code class="docutils literal notranslate"><span class="pre">{</span></code>, where the string gives the entry type. After we know the entry type, we look for the corresponding closing brace. If we don’t find it on the same line, then we read in the next line, and so forth, concatenating all of the lines into one long “entry string” until we encounter the corresponding closing brace. Once we have this extended “entry string” we feed it to <code class="docutils literal notranslate"><span class="pre">parse_bibentry()</span></code> to generate the bibliography data. Once we have come to the end of a given entry, we continue reading down the file looking for the next ‘&#64;’ and so on.</p>
<p>Although this approach effectively means that we have to pass twice through the same data, dealing with brace-matching can otherwise become a mess for the BibTeX format, since it allows nested delimiters, is not directly compatible with regular expressions.</p>
</div>
<div class="section" id="parse-bibentry">
<h3>parse_bibentry()<a class="headerlink" href="#parse-bibentry" title="Permalink to this headline">¶</a></h3>
<p>Because <code class="docutils literal notranslate"><span class="pre">parse_bibfile()</span></code> has already split the data by individual entry, <code class="docutils literal notranslate"><span class="pre">parse_bibentry()</span></code> only needs to worry about parsing a single entry, and there are five possible formats for the entry string passed to the function:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the entrytype is a <code class="docutils literal notranslate"><span class="pre">comment</span></code>, then skip everything, adding nothing to the database dictionary.</li>
<li>If the entrytype is a <code class="docutils literal notranslate"><span class="pre">preamble</span></code>, then treat the entire entry contents as a single fieldvalue. Append the string onto the <code class="docutils literal notranslate"><span class="pre">preamble</span></code> value in the <code class="docutils literal notranslate"><span class="pre">bibdata</span></code> dictionary.</li>
<li>If the entrytype is a <code class="docutils literal notranslate"><span class="pre">acronym</span></code>, then get the entrykey and copy it into the <code class="docutils literal notranslate"><span class="pre">name</span></code> field. The remainder of the string is a single field value (the full form of the acronym); copy that into the <code class="docutils literal notranslate"><span class="pre">description</span></code> field.</li>
<li>If the entrytype is a <code class="docutils literal notranslate"><span class="pre">string</span></code> (i.e. an abbreviation), then there is no entrykey. Get the fieldname (abbreviation key), and the remainder of the string is a single field value (the full form of the abbreviated string). Add this key-value pair to the <code class="docutils literal notranslate"><span class="pre">abbrevs</span></code> dictionary.</li>
<li>If the entry is any other type, then get the entrykey, and the remainder of the string is a <em>series</em> of field-value pairs.</li>
</ol>
</div></blockquote>
<p>Once it determines which of these four options to use, <code class="docutils literal notranslate"><span class="pre">parse_bibentry()</span></code> extracts the entry key (if present), it locates each individual field and separates out the string corresponding to the key-value pair for each field. It does not actually <em>parse</em> the individual fields. For that, it loops over each field with a call to <code class="docutils literal notranslate"><span class="pre">parse_bibfield()</span></code> to extract the field key-value pairs.</p>
</div>
<div class="section" id="parse-bibfield">
<h3>parse_bibfield()<a class="headerlink" href="#parse-bibfield" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">parse_bibfield()</span></code> is the workhorse function of the BIB parsing. And because of BibTeX’s method for allowing concatenation, use of abbreviation keys, and use of two different types of delimiters (<code class="docutils literal notranslate"><span class="pre">&quot;...&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">{...}</span></code>), this function is a little messy. However, for the format of a given field, there are four parsing possibilities:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the field begins with a double quote <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> then scan until you find the next unnested <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>. Add that to the result string. If the ending <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> is followed by a comma, then the field is done; return the result string. If the ending is followed by a <code class="docutils literal notranslate"><span class="pre">#</span></code> then expect another field string. Scan for it and append it to the current result string.</li>
<li>If the field begins with <code class="docutils literal notranslate"><span class="pre">{</span></code> then scan until you resolve the brace level. This should be followed by a comma, since no concatenation is allowed for brace-delimited fields. Otherwise issue a syntax error warning.</li>
<li>If the field begins with a <code class="docutils literal notranslate"><span class="pre">#</span></code> (concatenation operator) then skip whitespace to the next character set, where you should expect a quote-delimited field. Append that to the current result string.</li>
<li>If the field begins with anything else, then the substring up until the first whitespace character represents an abbreviation key. Locate it and substitute it in. If you don’t find the key in the <code class="docutils literal notranslate"><span class="pre">abbrevs</span></code> dictionary, give a warning and continue on.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="parsing-aux-files">
<h2>Parsing AUX files<a class="headerlink" href="#parsing-aux-files" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file contains the filenames of the <code class="docutils literal notranslate"><span class="pre">.bib</span></code> database file and the <code class="docutils literal notranslate"><span class="pre">.bst</span></code> style template file, as well as the citations. The <code class="docutils literal notranslate"><span class="pre">get_bibfilenames()</span></code> method scans through the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file and locates a line with <code class="docutils literal notranslate"><span class="pre">\bibdata{...}</span></code> which contains a filename or a comma-delimited list of filenames, giving the database files. Another line with <code class="docutils literal notranslate"><span class="pre">\bibstyle{...}</span></code> gives the filename or comma-delimited list of filenames for style templates. The filenames obtained are saved into the <code class="docutils literal notranslate"><span class="pre">filedict</span></code> attribute – a dictionary whose keys are the file extensions <code class="docutils literal notranslate"><span class="pre">aux</span></code>, <code class="docutils literal notranslate"><span class="pre">bbl</span></code>, <code class="docutils literal notranslate"><span class="pre">bib</span></code>, <code class="docutils literal notranslate"><span class="pre">bst</span></code>, or <code class="docutils literal notranslate"><span class="pre">tex</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">parse_auxfile()</span></code> method makes a second pass through the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file, this time looking for the citation information. (Auxiliary files are generally quite small, so taking multiple passes through them costs very little time.) Each line with <code class="docutils literal notranslate"><span class="pre">\citation{...}</span></code> contains a citation key or comma-delimited list of citation keys – each one is added into the citation dictionary (<code class="docutils literal notranslate"><span class="pre">citedict</span></code>), with a value corresponding to the citation order.</p>
</div>
<div class="section" id="parsing-bst-files">
<h2>Parsing BST files<a class="headerlink" href="#parsing-bst-files" title="Permalink to this headline">¶</a></h2>
<p>Parsing a <code class="docutils literal notranslate"><span class="pre">.bst</span></code> file basically involves looking for one of several syntactical structures.</p>
<blockquote>
<div><ol class="arabic simple">
<li>First, any <code class="docutils literal notranslate"><span class="pre">#</span></code> present in a line indicates a comment. All text following the <code class="docutils literal notranslate"><span class="pre">#</span></code> are ignored.</li>
<li>Any line containing all capital letters and ending in <code class="docutils literal notranslate"><span class="pre">:</span></code> indicates a section header. The sections recognized are: <code class="docutils literal notranslate"><span class="pre">TEMPLATES</span></code>, <code class="docutils literal notranslate"><span class="pre">SPECIAL-TEMPLATES</span></code>, <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code>, <code class="docutils literal notranslate"><span class="pre">VARIABLES</span></code>, and <code class="docutils literal notranslate"><span class="pre">DEFINITIONS</span></code>. The first three sections (<code class="docutils literal notranslate"><span class="pre">TEMPLATES</span></code>, <code class="docutils literal notranslate"><span class="pre">SPECIAL-TEMPLATES</span></code>, and <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code>) use template syntax, while the last two ( <code class="docutils literal notranslate"><span class="pre">VARIABLES</span></code> and <code class="docutils literal notranslate"><span class="pre">DEFINITIONS</span></code>) use Python syntax.</li>
<li>In the TEMPLATES, SPECIAL-TEMPLATES, or OPTIONS sections of the file, any line ending in an ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) means that the following line is a continuation. Thus, the following line is appended to the current one.</li>
<li>For each <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">definition</span></code> pair found in the <code class="docutils literal notranslate"><span class="pre">VARIABLES</span></code> section of the file, the code creates a new entry in the <code class="docutils literal notranslate"><span class="pre">user_variables</span></code> dictionary, with value equal to the given definition.</li>
<li>For each <code class="docutils literal notranslate"><span class="pre">entrytype</span> <span class="pre">=</span> <span class="pre">template</span></code> pair found in the <code class="docutils literal notranslate"><span class="pre">TEMPLATES</span></code> section of the file, the code creates a corresponding entry in <code class="docutils literal notranslate"><span class="pre">bstdict</span></code>, with the key given by the <code class="docutils literal notranslate"><span class="pre">entrytype</span></code> and value given by the <code class="docutils literal notranslate"><span class="pre">template</span></code>. The code next examines the template definition to see if it contains a nested options block. If so, it adds it to the list of nested templates.</li>
<li>For each <code class="docutils literal notranslate"><span class="pre">keyword</span> <span class="pre">=</span> <span class="pre">value</span></code> pair found in the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> section of the file, the code creates a new entry in the <code class="docutils literal notranslate"><span class="pre">options</span></code> dictionary, with the dictionary key being the keyword itself, and the value copied from the right hand side of the option definition.</li>
<li>For each <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">definition</span></code> pair found in the <code class="docutils literal notranslate"><span class="pre">SPECIAL-TEMPLATES</span></code> section of the file, the code has to do a little more work than elsewhere. First it creates a new entry in the <code class="docutils literal notranslate"><span class="pre">specials</span></code> dictionary, with the dictionary key given by the <code class="docutils literal notranslate"><span class="pre">var</span></code>, and the value given by the <code class="docutils literal notranslate"><span class="pre">definition</span></code>. It then appens the key to the <code class="docutils literal notranslate"><span class="pre">specials_list</span></code>. (Since a dictionary is not ordered, we need an order-preserving means of iterating through the list of specials to make sure that one can always be defined before another that depends on it.) Next it examines the template definition to see if it contains a nested options block. If so, it adds it to the list of nested templates. It also looks to see if there is an ellipsis representing an implicit loop. If so, it adds the template key to the list of “looped templates”. Finally it looks to see if the template’s key represents an inmplicitly-indexed variable. If so, it adds the key to the list of implicitly indexed variables.</li>
</ol>
</div></blockquote>
<p>Once the initial parsing is done, there are several steps in which it analyzes the results:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Iterating through each of the regular templates, the code looks to see if any of the templates are defined as copies of other templates, as, for example, <code class="docutils literal notranslate"><span class="pre">inbook</span> <span class="pre">=</span> <span class="pre">incollection</span></code>. If it finds this kind of definition, then it copies the template from the one (<code class="docutils literal notranslate"><span class="pre">incollection</span></code> here) to the other (<code class="docutils literal notranslate"><span class="pre">inbook</span></code> here).</li>
<li>The code looks at the functions defined in the <code class="docutils literal notranslate"><span class="pre">DEFINITIONS</span></code> section of the file. If the <code class="docutils literal notranslate"><span class="pre">allow_scripts</span></code> keyword is set to True, then it goes ahead and evaluates these function definitions so that they will be available during the process of formatting bibliography entries.</li>
<li>Finally, the code passes each template definition through the <code class="docutils literal notranslate"><span class="pre">validate_templatestr()</span></code> function to validate that the template has proper syntax.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="writing-the-bbl-file">
<h2>Writing the BBL file<a class="headerlink" href="#writing-the-bbl-file" title="Permalink to this headline">¶</a></h2>
<p>Now that all the information is available to Bibulous, we can begin writing the output BBL file. First we write a few lines to the preamble, including the <code class="docutils literal notranslate"><span class="pre">preamble</span></code> string obtained from the <code class="docutils literal notranslate"><span class="pre">.bib</span></code> database files. Then, for each citation key we found in the <code class="docutils literal notranslate"><span class="pre">.aux</span></code> file, we</p>
<blockquote>
<div><ol class="arabic simple">
<li>Insert any cross-reference data from any other database entries into the current one.</li>
<li>Define all of the “special variables”, including the <code class="docutils literal notranslate"><span class="pre">sortkey</span></code> and <code class="docutils literal notranslate"><span class="pre">citelabel</span></code>, as fields within the current entry.</li>
</ol>
</div></blockquote>
<p>Now that we have all of the sortkeys, we generate the <code class="docutils literal notranslate"><span class="pre">citation_list</span></code> — the thing we iterate through one by one to format the references in order. At each iteration, we call <code class="docutils literal notranslate"><span class="pre">format_bibitem()</span></code>, which does the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Write the line <code class="docutils literal notranslate"><span class="pre">\bibitem[citelabel]{citekey}</span></code> into the <code class="docutils literal notranslate"><span class="pre">.bbl</span></code> file.</li>
<li>Import the template corresponding to the current entry’s <code class="docutils literal notranslate"><span class="pre">entrytype</span></code>.</li>
<li>If there are any user-deefined variables (from the <code class="docutils literal notranslate"><span class="pre">VARIABLES</span></code> section of the file), then evaluate those variables now, so that they can be used inside the template.</li>
<li>For each option block in the template, go through and determine how to “simplify” the block. This amounts to locating the first cell in each block that has a defined value, and then replacing the <code class="docutils literal notranslate"><span class="pre">[...]</span></code> square-bracket-delimited block with its contents. At this point the template variables are still there; only the square brackets have been dropped.</li>
<li>Now that the optional pieces are all gone, go through each template variable and replace it with the corresponding field from the database entry.</li>
<li>If there are any nested <code class="docutils literal notranslate"><span class="pre">\textit{...\textit{...}...}</span></code> operators in the result, replace odd-level operators with <code class="docutils literal notranslate"><span class="pre">\textup{...}</span></code> in order to get the right behavior of flipping between italics and regular font.</li>
<li>If there are any nested <code class="docutils literal notranslate"><span class="pre">\textbf{...\textbf{...}...}</span></code> operators in the result, replace odd-level operators with <code class="docutils literal notranslate"><span class="pre">\textup{...}</span></code> in order to get the right behavior of flipping between bold and regular weight.</li>
<li>If there are any nested quotation marks in the result, then re-order them according to the American standard. This means having double-quotation-marks at the outermost level, single-quotation-marks inside that, then double inside that, single inside that, and so on. This is messy and difficult code, and so users should always be recommended to use the <code class="docutils literal notranslate"><span class="pre">\enquote{...}</span></code> LaTeX operator instead of manually-implemented quotation marks.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="name-formatting">
<h2>Name formatting<a class="headerlink" href="#name-formatting" title="Permalink to this headline">¶</a></h2>
<p>One of the more complex tasks needed for parsing BIB files is to resolve the elements of name lists (typically saved in the <code class="docutils literal notranslate"><span class="pre">author</span></code> and <code class="docutils literal notranslate"><span class="pre">editor</span></code> fields). In order to know how these should be inserted into a template, it is necessary to know which parts of a given person’s name correspond to the first name, the middle name(s), the “prefix” (or “von part”), the last name (or “surname”), and the “suffix” (such as “Jr.” or “III”). These five pieces or each person’s name are saved as a dictionary, so that a bibliography entry with five authors is represented in <code class="docutils literal notranslate"><span class="pre">&lt;authorlist&gt;</span></code> as a list of five dictionaries, and each dictionary having keys <code class="docutils literal notranslate"><span class="pre">first</span></code>, <code class="docutils literal notranslate"><span class="pre">middle</span></code>, <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">last</span></code>, and <code class="docutils literal notranslate"><span class="pre">suffix</span></code>.</p>
<p>In order to speed up parsing times, the actual mapping of the <code class="docutils literal notranslate"><span class="pre">author</span></code> or <code class="docutils literal notranslate"><span class="pre">editor</span></code> fields to <code class="docutils literal notranslate"><span class="pre">authorlist</span></code> or <code class="docutils literal notranslate"><span class="pre">editorlist</span></code> is not done until the loop over citation keys performed while writing out the BBL file. The function that product the list-of-dicts parsing result is <code class="docutils literal notranslate"><span class="pre">namestr_to_namedict(namestr)</span></code>.</p>
<p>The default formatting of a namelist into a string to be inserted into the template is performed by <code class="docutils literal notranslate"><span class="pre">format_namelist()</span></code>.</p>
<div class="section" id="create-namelist">
<h3>create_namelist()<a class="headerlink" href="#create-namelist" title="Permalink to this headline">¶</a></h3>
<p>A BibTeX “name” field can consist of three different formats of names:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A space-separated list: <code class="docutils literal notranslate"><span class="pre">[firstname</span> <span class="pre">middlenames</span> <span class="pre">suffix</span> <span class="pre">lastname]</span></code></li>
<li>A two-element comma-separated list: <code class="docutils literal notranslate"><span class="pre">[prefix</span> <span class="pre">lastname,</span> <span class="pre">firstname</span> <span class="pre">middlenames]</span></code></li>
<li>A three-element comma-separated list: <code class="docutils literal notranslate"><span class="pre">[prefix</span> <span class="pre">lastname,</span> <span class="pre">suffix,</span> <span class="pre">firstname</span> <span class="pre">middlenames]</span></code></li>
</ol>
</div></blockquote>
<p>So, an easy way to separate these three categories is by counting the number of commas that appear. The trickiest part here is that although we can use <code class="docutils literal notranslate"><span class="pre">and</span></code> as a name separator, we are only allowed to do so if <code class="docutils literal notranslate"><span class="pre">and</span></code> occurs at the top brace level.</p>
<p>In addition, in order to make name parsing more flexible for nonstandard names, Bibulous adds two more name formats to this list:</p>
<blockquote>
<div><ol class="arabic simple" start="4">
<li>A four-element comma-separated list: <code class="docutils literal notranslate"><span class="pre">[firstname,</span> <span class="pre">middlenames,</span> <span class="pre">prefix,</span> <span class="pre">lastname]</span></code></li>
<li>A five-element comma-separated list: <code class="docutils literal notranslate"><span class="pre">[firstname,</span> <span class="pre">middlenames,</span> <span class="pre">prefix,</span> <span class="pre">lastname,</span> <span class="pre">suffix]</span></code></li>
</ol>
</div></blockquote>
<p>For each name in the field, we parse the name tokens into a dictionary. We then compile all of the dictionaries into a list, ordered by the appearance of the names in the input field.</p>
</div>
<div class="section" id="format-namelist">
<h3>format_namelist()<a class="headerlink" href="#format-namelist" title="Permalink to this headline">¶</a></h3>
<p>Given a namelist (list of dictionaries), we glue the name elements together into a single string, incorporating all of the format options selected by the user in the template file. This includes calls to <code class="docutils literal notranslate"><span class="pre">namedict_to_formatted_namestr()</span></code>, and to <code class="docutils literal notranslate"><span class="pre">initialize_name()</span></code> if converting any name tokens to initials.</p>
</div>
</div>
<div class="section" id="generating-sortkeys">
<h2>Generating sortkeys<a class="headerlink" href="#generating-sortkeys" title="Permalink to this headline">¶</a></h2>
<p>If the user’s style template file selects the citation order to be <code class="docutils literal notranslate"><span class="pre">citenum</span></code> or <code class="docutils literal notranslate"><span class="pre">none</span></code>, then creating the ordered citation list is as simple as listing the citation keys in order of their citation appearance, which was recorded as the value in the citation dictionary. If the user instead chooses the citation order to be <code class="docutils literal notranslate"><span class="pre">citekey</span></code>, then all that is needed is to sort the citation keys alphabetically. Similar operations follow for the various citation order options, but the difficult lies in correctly sorting in the presence of non-ASCII languages, and especially in the presence of LaTeX markup of non-ASCII names. For a citation sorting order that requires using author names, any LaTeX markup needs to be converted to its Unicode equivalent prior to sorting. Using unicode allows the sorting to be done with any input languages, and allows the sorting order to be locale-dependent.</p>
<p><code class="docutils literal notranslate"><span class="pre">create_citation_list()</span></code> is the highest-level function for generating the citation list. For each citation key, it calls <code class="docutils literal notranslate"><span class="pre">generate_sortkey()</span></code>, which is the workhorse function for including all of the various options when generating the key to use for sorting the list. A key part of the function is a call to <code class="docutils literal notranslate"><span class="pre">purify_string()</span></code>, which removes unnecessary LaTeX markup elements and then calls <code class="docutils literal notranslate"><span class="pre">latex_to_utf8()</span></code> to convert LaTeX-markup non-ASCII characters to Unicode. It is only after all of these conversions that the final sorting is performed and the sorted citation list returned.</p>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>The suite of regression tests for Bibulous consist of various template definitions and database entries designed to test individual features of the program. The basic approach of the tests is as follows:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Once a change is made to the code (to fix a bug or add functionality), the developer also adds an entry to the <code class="docutils literal notranslate"><span class="pre">test/test1.bib</span></code> file, where the entry’s “entrytype” is named in such a way to give an indication of what the test is for. For example, the entry in the BIB file may be defined with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@initialize1</span><span class="p">{</span><span class="o">...</span>
</pre></div>
</div>
<p>where the developer provides an <code class="docutils literal notranslate"><span class="pre">author</span></code> field in the entry where one or more authors have names which are difficult to for generating initials correctly. The developer should also include at least a 1-line comment about the purpose of the entry as well. To make everything easy to find, use the entrytype as the entry’s key as well. Thus, the example above would use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@initialize1</span><span class="p">{</span><span class="n">initialize1</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">If the above new entry is something which can be checked with normal options settings, then the developer should add a corresponding line in the BST file defining how that new entrytype (i.e. <code class="docutils literal notranslate"><span class="pre">initialize1</span></code>) should be formatted. If <em>different</em> options settings are needed, then a new BST file is needed. Only a minimalist file is generally needed: the file can, for example, contain one line defining a new entrytype and one line to define the new option setting. You can define all of the other options if you want, but these are redundant and introduce a number of unnecessary “overwriting option value…” warning messages.</p>
</li>
<li><p class="first">Next, the developer should add a line <code class="docutils literal notranslate"><span class="pre">\citation{entrytype}</span></code> to the AUX file where the <code class="docutils literal notranslate"><span class="pre">entrytype</span></code> is the key given in the new entry of the BIB file you just put in (e.g. <code class="docutils literal notranslate"><span class="pre">initialize1</span></code>). This is the same as the entrytype to keep everything consistent.</p>
</li>
<li><p class="first">Next, the developer needs to add two lines to the <code class="docutils literal notranslate"><span class="pre">test1_target.bbl</span></code> file to say what the formatted result should look like. Take a look at other lines to get a feel for how these should look, and take in consideration the form of the template just added to the BST file.</p>
</li>
<li><p class="first">Finally, run <code class="docutils literal notranslate"><span class="pre">bibulous_test.py</span></code> to check the result. This script will load the modified BIB and BST files and will write out several formatted BBL file <code class="docutils literal notranslate"><span class="pre">test1.bbl</span></code> etc. It will then run a <code class="docutils literal notranslate"><span class="pre">diff</span></code> program on the output file versus the target BBL file to see if there are any differences between the target and actual output BBL files.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="generating-the-documentation">
<h2>Generating the documentation<a class="headerlink" href="#generating-the-documentation" title="Permalink to this headline">¶</a></h2>
<p>The documentation is written in reStructuredText (RST) and converted to HTML using Sphinx. Sphinx can also use LaTeX to convert the HTML files into a PDF.</p>
<p>From the bibulous repository <code class="docutils literal notranslate"><span class="pre">doc/</span></code> subfolder, run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">html</span></code> to generate the HTML documentation. The result can be found in <code class="docutils literal notranslate"><span class="pre">doc/_build/html/</span></code>, with <code class="docutils literal notranslate"><span class="pre">index.html</span></code> as the main file. To generate the PDF documentation, run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">latexpdf</span></code> from the <code class="docutils literal notranslate"><span class="pre">doc/</span></code> subfolder, with the result found at <code class="docutils literal notranslate"><span class="pre">doc/_build/latex/Bibulous.pdf</span></code>.</p>
<p>While the documentation is saved in the <code class="docutils literal notranslate"><span class="pre">doc/</span></code> folder on the main branch, this is not automatically converted into viewable, linked HTML on GitHub. To achieve that requires pushing the updated docs into the <code class="docutils literal notranslate"><span class="pre">gh-pages</span></code> branch. One way of doing this is the following. Make a local copy of the main branch’s <code class="docutils literal notranslate"><span class="pre">doc/_build/html/</span></code> folder. Switch to the <code class="docutils literal notranslate"><span class="pre">gh-pages</span></code> branch (i.e. <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">checkout</span> <span class="pre">gh-pages</span></code>) and replace everything there with the locally-copied <code class="docutils literal notranslate"><span class="pre">doc/_build/html/</span></code> folder contents. Then update: <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">-A</span></code> and <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">push</span> <span class="pre">origin</span> <span class="pre">gh-pages</span></code>. And switch back to the main branch, <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">checkout</span> <span class="pre">master</span></code>.</p>
</div>
<div class="section" id="updating-the-pypi-package">
<h2>Updating the PyPI package<a class="headerlink" href="#updating-the-pypi-package" title="Permalink to this headline">¶</a></h2>
<p>From the bibulous base folder, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">sdist</span> <span class="o">--</span><span class="n">formats</span><span class="o">=</span><span class="n">gztar</span><span class="p">,</span><span class="nb">zip</span>
</pre></div>
</div>
<p>to create the package locally, and then run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">sdist</span> <span class="n">upload</span>
</pre></div>
</div>
<p>to update the PIP package online.</p>
</div>
<div class="section" id="miscellaneous-notes">
<h2>Miscellaneous notes<a class="headerlink" href="#miscellaneous-notes" title="Permalink to this headline">¶</a></h2>
<p>The code includes two different variables, <code class="docutils literal notranslate"><span class="pre">citekey</span></code> and <code class="docutils literal notranslate"><span class="pre">entrykey</span></code> which for any given entry are always identical. So it would appear that they are redundant. But the keys in the <code class="docutils literal notranslate"><span class="pre">citedict</span></code> dictionary, and the keys specifying each entry in the database, belong to different sets. That is, the list of entry keys can be from every entry in the database, even entries that were not cited. The list of citation keys, however, contains only those keys that were cited, and so can be a much smaller list.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             >next</a> |</li>
        <li class="right" >
          <a href="instructions_for_reporting_bugs.html" title="Instructions on how to report a bug to the Bibulous development team"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, Bibulous developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>