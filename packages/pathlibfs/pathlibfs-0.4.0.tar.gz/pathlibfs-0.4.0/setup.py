# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['pathlibfs']

package_data = \
{'': ['*']}

install_requires = \
['fsspec>=2022.11.0,<2023.0.0']

setup_kwargs = {
    'name': 'pathlibfs',
    'version': '0.4.0',
    'description': 'pathlib 🤝 fsspec, manipulate remote filesystem paths.',
    'long_description': '# pathlibfs\n\n[![codecov](https://codecov.io/gh/roy-ht/pathlibfs/branch/main/graph/badge.svg?token=MX1DTY2CNG)](https://codecov.io/gh/roy-ht/pathlibfs)\n\npathlib 🤝 fsspec\n\nLike pathlib, Python standard library module, manipulate remote filesystem paths.\n\n# Installation\n\n```\npip install pathlibfs\n```\n\n# Getting Started\n\nIt only provide `Path` class:\n\n```python\nfrom pathlibfs import Path\n\np = Path(\'your/path.txt\')\np_s3 = Path(\'s3://bucket/key.txt\')\np_gcs = Path(\'gs://bucket/key.txt\')\n```\n\npathlibfs uses [fsspec](https://github.com/fsspec/filesystem_spec) as a backend filesystem.\nSo if you want to use some specific remote filesystem, you need to install extra dependencies such as `s3fs` or `gcsfs`.\n\nSee [known implementations](https://github.com/fsspec/filesystem_spec/blob/a8cfd9c52a20c930c67ff296b60dbcda89d64db9/fsspec/registry.py#L87)\nto check out supported protocols.\n\n# Special Environment Variables\n| name | description |\n|-|-|\n| PATHLIBFS_S3_SESSION_CACHE | If defined, store S3 session cache locally like [boto3-session-cache](https://github.com/mixja/boto3-session-cache) |\n\n# APIs\n\n`Path` class has many methods, and it\'s almost same as [pathlib](https://docs.python.org/3.10/library/pathlib.html) and [fsspec.AbstractFileSystem](https://filesystem-spec.readthedocs.io/en/latest/api.html#fsspec.spec.AbstractFileSystem)\n.\n\nFor example, like pathlib, you can join path with `/`:\n\n```\np = Path(\'some/dir\') / \'subdir\'  # -> Path(\'some/dir/subdir\')\n```\n\n## properties\n\nGotcha.\n\n| name | description |\n|-|-|\n| fs | backend filesystem of fsspec |\n| path | path without protocol. e.g. Path(\'s3://bucket/key\') == \'bucket/key\' |\n| fullpath | path with protocol. e.g. Path(\'a.txt\') == \'file://a.txt\' |\n| urlpath | path with full chain. e.g. Path(\'simplecache::s3://bucket/key\') == \'simplecache::s3://bucket/key\' |\n| drive | same as pathlib |\n| root | same as pathlib |\n| parts | same as pathlib |\n| anchor | same as pathlib |\n| parents | same as pathlib, return List[Path] |\n| parent | same as pathlib, return Path |\n| has_parent | same as `path.parent != path` |\n| name | same as pathlib |\n| suffix | same as pathlib |\n| suffixes | same as pathlib |\n| stem | same as pathlib |\n| sep | separator of backend filesystem, such as \'/\' |\n| protocol | backend protocol. e.g. \'s3\', \'gcs\' |\n\n\n## pathlib based operations\n\n| name | description |\n|-|-|\n| `as_posix()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `chmod(mode: int)` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `group()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_mount()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_symlink()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_socket()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_fifo()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_block_device()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `is_char_device()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `owner()` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `symlink_to(target: PathLike)` | only for local filesystem, otherwise raise an `PathlibfsException` |\n| `resolve()` | only for local filesystem, otherwise return `self` |\n| `is_absolute()` | only for local filesystem, otherwise return True |\n| `is_reserved()` | only for local filesystem, otherwise return False |\n| `joinpath(*p)` | same as pathlib |\n| `match(pattern: str)` | same as pathlib |\n| `with_name(name: str)` | same as pathlib |\n| `with_suffix(suffix: str)` | same as pathlib |\n| `read_bytes()` | same as pathlib |\n| `read_text()` | same as pathlib |\n| `write_text(data)` | same as pathlib |\n| `write_bytes(data)` | same as pathlib |\n| `is_dir()` | same as pathlib |\n| `is_file()` | same as pathlib |\n| `unlink()` | same as pathlib |\n| `relative_to(path: PathLike)` | same as pathlib, but **return str**. `path == other / path.relative_to(other)` |\n| `iterdir(**kwargs)` | same as pathlib. It\'s just an wrapper of ls(), **it\'s not efficient.** Use `ls()`. |\n| `stat()` | alias of info. **It\'s not same as pathlib**, but fsspec\'s `info()` |\n| `rglob(pattern, **kwargs)` | same meaning as pathlib, and accept fsspec\'s `glob()` |\n\n## fsspec based mathods\n\n| name | description |\n|-|-|\n| `ls(**kwargs)` | same as fsspec |\n| `listdir()` | alias of ls |\n| `find(maxdepth: Optional[int] = None, withdirs: bool = False, **kwargs)` | same as fsspec |\n| `glob(pattern, **kwargs)` | same as fsspec |\n| `expand_path(recursive: bool = False, maxdepth: Optional[int] = None, **kwargs)` | same as fsspec |\n| `walk(maxdepth: Optional[int] = None, **kwargs)` | same as `os.walk` and fsspec\'s `walk`, yield `(dirpath, dirnames, filenames)`. And `dirpath` is `Path` instance. |\n| `exists(**kwargs)` | same as fsspec |\n| `isdir()` | same as fsspec |\n| `isfile()` | same as fsspec |\n| `lexists()` | same as fsspec |\n| `ukey()` | same as fsspec |\n| `checksum()` | same as fsspec |\n| `sign(expiration: int = 100, **kwargs)` | same as fsspec |\n| `size()` | same as fsspec |\n| `created()` | same as fsspec |\n| `modified()` | same as fsspec |\n| `du(total: bool = True, maxdepth: Optional[int] = None, **kwargs)` | same as fsspec |\n| `disk_usage()` | alias of du |\n| `info(**kwargs)` | same as fsspec |\n| `open()` | same as fsspec |\n| `cat(recursive: bool = False, on_error: str = "raise", **kwargs)` | same as fsspec |\n| `read_block(offset: int, length: int, delimiter: Optional[bytes] = None)` | same as fsspec |\n| `head(size: int = 1024)` | same as fsspec |\n| `tail(size: int = 1024)` | same as fsspec |\n| `mkdir(parents: bool = False, exist_ok: bool = False, **kwargs)` | same as fsspec |\n| `makedir()` | alias of mkdir |\n| `makedirs(exist_ok: bool = False, **kwargs)` | same as `mkdir(parents=True)` |\n| `mkdirs()` | alias of makedirs |\n| `touch(mode: int = 0o666, exist_ok: bool = True, truncate: bool = False, **kwargs) | same as fsspec |\n| `pipe_file(data)` | same as fsspec |\n| `rm_file()` | same as fsspec |\n| `rm(recursive: bool = False, maxdepth: Optional[int] = None)` | same as fsspec |\n| `delete()` | alias of rm |\n| `invalidate_cache()` | same as fsspec |\n| `clear_instance_cache()` | same as fsspec |\n| `copy(dst: PathLike, recursive: bool = False, on_error: Optional[str] = None, **kwargs)` | copy the path to dst. `copy()` can handle any protocol combinations so you don\'t need to call `put()` or `get()` for almost all cases. |\n| `cp()` | alias of copy |\n| `move(dst: PathLike, recursive=False, maxdepth=None, **kwargs)` | similar to copy, but delete source path after copy. |\n| `mv()`, `rename()`, `replace() | alias of move |\n| `put(target: PathLike, recursive: bool = False, callback=fsspec.callbacks._DEFAULT_CALLBACK, **kwargs)` | Upload **local** target to the path. |\n| `upload()` | alias of put |\n| `get(arget: PathLike, recursive: bool = False, callback=fsspec.callbacks._DEFAULT_CALLBACK, **kwargs)` | Downalod the path into **local** target. |\n| `download()` | alias of get |\n\n## others\n\n| name | description |\n|-|-|\n| `islocal()` | True if protocol is local filesystem. |\n| `clone(path: Optional[str] = None)` | copy self instance with different path (optional). |\n| `samefile(target: PathLike)` | same as `self == target` |\n\n\n# How to test\n\nStart mock server for testing.\n\n```\ndocker-compose up -d\n```\n\nRun test:\n```\npytest\n```',
    'author': 'Hiroyuki "Roy" Tanaka',
    'author_email': 'aflc0x@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
