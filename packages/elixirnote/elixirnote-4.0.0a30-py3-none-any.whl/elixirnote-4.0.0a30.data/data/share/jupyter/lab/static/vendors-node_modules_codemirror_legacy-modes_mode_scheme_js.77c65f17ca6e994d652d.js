"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_scheme_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/scheme.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/scheme.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheme": () => (/* binding */ scheme)
/* harmony export */ });
var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
    SYMBOL = "symbol", ATOM = "atom", NUMBER = "number", BRACKET = "bracket";
var INDENT_WORD_SKIP = 2;

function makeKeywords(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = makeKeywords("Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?");
var indentKeys = makeKeywords("define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless");

function stateStack(indent, type, prev) { // represents a state stack object
  this.indent = indent;
  this.type = type;
  this.prev = prev;
}

function pushStack(state, indent, type) {
  state.indentStack = new stateStack(indent, type, state.indentStack);
}

function popStack(state) {
  state.indentStack = state.indentStack.prev;
}

var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\/[01]+#*)?i|[-+]?[01]+#*(?:\/[01]+#*)?@[-+]?[01]+#*(?:\/[01]+#*)?|[-+]?[01]+#*(?:\/[01]+#*)?[-+](?:[01]+#*(?:\/[01]+#*)?)?i|[-+]?[01]+#*(?:\/[01]+#*)?)(?=[()\s;"]|$)/i);
var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?)(?=[()\s;"]|$)/i);
var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\da-f]+#*(?:\/[\da-f]+#*)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?@[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?[-+](?:[\da-f]+#*(?:\/[\da-f]+#*)?)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?)(?=[()\s;"]|$)/i);
var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)i|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)@[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)?i|(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*))(?=[()\s;"]|$)/i);

function isBinaryNumber (stream) {
  return stream.match(binaryMatcher);
}

function isOctalNumber (stream) {
  return stream.match(octalMatcher);
}

function isDecimalNumber (stream, backup) {
  if (backup === true) {
    stream.backUp(1);
  }
  return stream.match(decimalMatcher);
}

function isHexNumber (stream) {
  return stream.match(hexMatcher);
}

function processEscapedSequence(stream, options) {
  var next, escaped = false;
  while ((next = stream.next()) != null) {
    if (next == options.token && !escaped) {
      options.state.mode = false;
      break;
    }
    escaped = !escaped && next == "\\";
  }
}

const scheme = {
  startState: function () {
    return {
      indentStack: null,
      indentation: 0,
      mode: false,
      sExprComment: false,
      sExprQuote: false
    };
  },

  token: function (stream, state) {
    if (state.indentStack == null && stream.sol()) {
      // update indentation, but only if indentStack is empty
      state.indentation = stream.indentation();
    }

    // skip spaces
    if (stream.eatSpace()) {
      return null;
    }
    var returnType = null;

    switch(state.mode){
    case "string": // multi-line string parsing mode
      processEscapedSequence(stream, {
        token: "\"",
        state: state
      });
      returnType = STRING; // continue on in scheme-string mode
      break;
    case "symbol": // escape symbol
      processEscapedSequence(stream, {
        token: "|",
        state: state
      });
      returnType = SYMBOL; // continue on in scheme-symbol mode
      break;
    case "comment": // comment parsing mode
      var next, maybeEnd = false;
      while ((next = stream.next()) != null) {
        if (next == "#" && maybeEnd) {

          state.mode = false;
          break;
        }
        maybeEnd = (next == "|");
      }
      returnType = COMMENT;
      break;
    case "s-expr-comment": // s-expr commenting mode
      state.mode = false;
      if(stream.peek() == "(" || stream.peek() == "["){
        // actually start scheme s-expr commenting mode
        state.sExprComment = 0;
      }else{
        // if not we just comment the entire of the next token
        stream.eatWhile(/[^\s\(\)\[\]]/); // eat symbol atom
        returnType = COMMENT;
        break;
      }
    default: // default parsing mode
      var ch = stream.next();

      if (ch == "\"") {
        state.mode = "string";
        returnType = STRING;

      } else if (ch == "'") {
        if (stream.peek() == "(" || stream.peek() == "["){
          if (typeof state.sExprQuote != "number") {
            state.sExprQuote = 0;
          } // else already in a quoted expression
          returnType = ATOM;
        } else {
          stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);
          returnType = ATOM;
        }
      } else if (ch == '|') {
        state.mode = "symbol";
        returnType = SYMBOL;
      } else if (ch == '#') {
        if (stream.eat("|")) {                    // Multi-line comment
          state.mode = "comment"; // toggle to comment mode
          returnType = COMMENT;
        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)
          returnType = ATOM;
        } else if (stream.eat(';')) {                // S-Expr comment
          state.mode = "s-expr-comment";
          returnType = COMMENT;
        } else {
          var numTest = null, hasExactness = false, hasRadix = true;
          if (stream.eat(/[ei]/i)) {
            hasExactness = true;
          } else {
            stream.backUp(1);       // must be radix specifier
          }
          if (stream.match(/^#b/i)) {
            numTest = isBinaryNumber;
          } else if (stream.match(/^#o/i)) {
            numTest = isOctalNumber;
          } else if (stream.match(/^#x/i)) {
            numTest = isHexNumber;
          } else if (stream.match(/^#d/i)) {
            numTest = isDecimalNumber;
          } else if (stream.match(/^[-+0-9.]/, false)) {
            hasRadix = false;
            numTest = isDecimalNumber;
            // re-consume the initial # if all matches failed
          } else if (!hasExactness) {
            stream.eat('#');
          }
          if (numTest != null) {
            if (hasRadix && !hasExactness) {
              // consume optional exactness after radix
              stream.match(/^#[ei]/i);
            }
            if (numTest(stream))
              returnType = NUMBER;
          }
        }
      } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal
        returnType = NUMBER;
      } else if (ch == ";") { // comment
        stream.skipToEnd(); // rest of the line is a comment
        returnType = COMMENT;
      } else if (ch == "(" || ch == "[") {
        var keyWord = ''; var indentTemp = stream.column(), letter;
        /**
           Either
           (indent-word ..
           (non-indent-word ..
           (;something else, bracket, etc.
        */

        while ((letter = stream.eat(/[^\s\(\[\;\)\]]/)) != null) {
          keyWord += letter;
        }

        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word

          pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);
        } else { // non-indent word
          // we continue eating the spaces
          stream.eatSpace();
          if (stream.eol() || stream.peek() == ";") {
            // nothing significant after
            // we restart indentation 1 space after
            pushStack(state, indentTemp + 1, ch);
          } else {
            pushStack(state, indentTemp + stream.current().length, ch); // else we match
          }
        }
        stream.backUp(stream.current().length - 1); // undo all the eating

        if(typeof state.sExprComment == "number") state.sExprComment++;
        if(typeof state.sExprQuote == "number") state.sExprQuote++;

        returnType = BRACKET;
      } else if (ch == ")" || ch == "]") {
        returnType = BRACKET;
        if (state.indentStack != null && state.indentStack.type == (ch == ")" ? "(" : "[")) {
          popStack(state);

          if(typeof state.sExprComment == "number"){
            if(--state.sExprComment == 0){
              returnType = COMMENT; // final closing bracket
              state.sExprComment = false; // turn off s-expr commenting mode
            }
          }
          if(typeof state.sExprQuote == "number"){
            if(--state.sExprQuote == 0){
              returnType = ATOM; // final closing bracket
              state.sExprQuote = false; // turn off s-expr quote mode
            }
          }
        }
      } else {
        stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);

        if (keywords && keywords.propertyIsEnumerable(stream.current())) {
          returnType = BUILTIN;
        } else returnType = "variable";
      }
    }
    return (typeof state.sExprComment == "number") ? COMMENT : ((typeof state.sExprQuote == "number") ? ATOM : returnType);
  },

  indent: function (state) {
    if (state.indentStack == null) return state.indentation;
    return state.indentStack.indent;
  },

  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", '"']},
    commentTokens: {line: ";;"}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9zY2hlbWVfanMuNzdjNjVmMTdjYTZlOTk0ZDY1MmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5TkFBeU47QUFDek4sb09BQW9PO0FBQ3BPLDBQQUEwUDtBQUMxUCx1aUJBQXVpQjs7QUFFdmlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRDtBQUNsRCxrQ0FBa0M7QUFDbEM7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBLFVBQVUsc0JBQXNCLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBa0U7QUFDMUU7QUFDQSxRQUFRLGlCQUFpQixLQUFLO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBLFFBQVE7QUFDUiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUEsOEVBQThFOztBQUU5RTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQix1QkFBdUIsUUFBUTtBQUNuRCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zY2hlbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEJVSUxUSU4gPSBcImJ1aWx0aW5cIiwgQ09NTUVOVCA9IFwiY29tbWVudFwiLCBTVFJJTkcgPSBcInN0cmluZ1wiLFxuICAgIFNZTUJPTCA9IFwic3ltYm9sXCIsIEFUT00gPSBcImF0b21cIiwgTlVNQkVSID0gXCJudW1iZXJcIiwgQlJBQ0tFVCA9IFwiYnJhY2tldFwiO1xudmFyIElOREVOVF9XT1JEX1NLSVAgPSAyO1xuXG5mdW5jdGlvbiBtYWtlS2V5d29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGtleXdvcmRzID0gbWFrZUtleXdvcmRzKFwizrsgY2FzZS1sYW1iZGEgY2FsbC9jYyBjbGFzcyBjb25kLWV4cGFuZCBkZWZpbmUtY2xhc3MgZGVmaW5lLXZhbHVlcyBleGl0LWhhbmRsZXIgZmllbGQgaW1wb3J0IGluaGVyaXQgaW5pdC1maWVsZCBpbnRlcmZhY2UgbGV0Ki12YWx1ZXMgbGV0LXZhbHVlcyBsZXQvZWMgbWl4aW4gb3B0LWxhbWJkYSBvdmVycmlkZSBwcm90ZWN0IHByb3ZpZGUgcHVibGljIHJlbmFtZSByZXF1aXJlIHJlcXVpcmUtZm9yLXN5bnRheCBzeW50YXggc3ludGF4LWNhc2Ugc3ludGF4LWVycm9yIHVuaXQvc2lnIHVubGVzcyB3aGVuIHdpdGgtc3ludGF4IGFuZCBiZWdpbiBjYWxsLXdpdGgtY3VycmVudC1jb250aW51YXRpb24gY2FsbC13aXRoLWlucHV0LWZpbGUgY2FsbC13aXRoLW91dHB1dC1maWxlIGNhc2UgY29uZCBkZWZpbmUgZGVmaW5lLXN5bnRheCBkZWZpbmUtbWFjcm8gZGVmbWFjcm8gZGVsYXkgZG8gZHluYW1pYy13aW5kIGVsc2UgZm9yLWVhY2ggaWYgbGFtYmRhIGxldCBsZXQqIGxldC1zeW50YXggbGV0cmVjIGxldHJlYy1zeW50YXggbWFwIG9yIHN5bnRheC1ydWxlcyBhYnMgYWNvcyBhbmdsZSBhcHBlbmQgYXBwbHkgYXNpbiBhc3NvYyBhc3NxIGFzc3YgYXRhbiBib29sZWFuPyBjYWFyIGNhZHIgY2FsbC13aXRoLWlucHV0LWZpbGUgY2FsbC13aXRoLW91dHB1dC1maWxlIGNhbGwtd2l0aC12YWx1ZXMgY2FyIGNkZGRhciBjZGRkZHIgY2RyIGNlaWxpbmcgY2hhci0+aW50ZWdlciBjaGFyLWFscGhhYmV0aWM/IGNoYXItY2k8PT8gY2hhci1jaTw/IGNoYXItY2k9PyBjaGFyLWNpPj0/IGNoYXItY2k+PyBjaGFyLWRvd25jYXNlIGNoYXItbG93ZXItY2FzZT8gY2hhci1udW1lcmljPyBjaGFyLXJlYWR5PyBjaGFyLXVwY2FzZSBjaGFyLXVwcGVyLWNhc2U/IGNoYXItd2hpdGVzcGFjZT8gY2hhcjw9PyBjaGFyPD8gY2hhcj0/IGNoYXI+PT8gY2hhcj4/IGNoYXI/IGNsb3NlLWlucHV0LXBvcnQgY2xvc2Utb3V0cHV0LXBvcnQgY29tcGxleD8gY29ucyBjb3MgY3VycmVudC1pbnB1dC1wb3J0IGN1cnJlbnQtb3V0cHV0LXBvcnQgZGVub21pbmF0b3IgZGlzcGxheSBlb2Ytb2JqZWN0PyBlcT8gZXF1YWw/IGVxdj8gZXZhbCBldmVuPyBleGFjdC0+aW5leGFjdCBleGFjdD8gZXhwIGV4cHQgI2YgZmxvb3IgZm9yY2UgZ2NkIGltYWctcGFydCBpbmV4YWN0LT5leGFjdCBpbmV4YWN0PyBpbnB1dC1wb3J0PyBpbnRlZ2VyLT5jaGFyIGludGVnZXI/IGludGVyYWN0aW9uLWVudmlyb25tZW50IGxjbSBsZW5ndGggbGlzdCBsaXN0LT5zdHJpbmcgbGlzdC0+dmVjdG9yIGxpc3QtcmVmIGxpc3QtdGFpbCBsaXN0PyBsb2FkIGxvZyBtYWduaXR1ZGUgbWFrZS1wb2xhciBtYWtlLXJlY3Rhbmd1bGFyIG1ha2Utc3RyaW5nIG1ha2UtdmVjdG9yIG1heCBtZW1iZXIgbWVtcSBtZW12IG1pbiBtb2R1bG8gbmVnYXRpdmU/IG5ld2xpbmUgbm90IG51bGwtZW52aXJvbm1lbnQgbnVsbD8gbnVtYmVyLT5zdHJpbmcgbnVtYmVyPyBudW1lcmF0b3Igb2RkPyBvcGVuLWlucHV0LWZpbGUgb3Blbi1vdXRwdXQtZmlsZSBvdXRwdXQtcG9ydD8gcGFpcj8gcGVlay1jaGFyIHBvcnQ/IHBvc2l0aXZlPyBwcm9jZWR1cmU/IHF1YXNpcXVvdGUgcXVvdGUgcXVvdGllbnQgcmF0aW9uYWw/IHJhdGlvbmFsaXplIHJlYWQgcmVhZC1jaGFyIHJlYWwtcGFydCByZWFsPyByZW1haW5kZXIgcmV2ZXJzZSByb3VuZCBzY2hlbWUtcmVwb3J0LWVudmlyb25tZW50IHNldCEgc2V0LWNhciEgc2V0LWNkciEgc2luIHNxcnQgc3RyaW5nIHN0cmluZy0+bGlzdCBzdHJpbmctPm51bWJlciBzdHJpbmctPnN5bWJvbCBzdHJpbmctYXBwZW5kIHN0cmluZy1jaTw9PyBzdHJpbmctY2k8PyBzdHJpbmctY2k9PyBzdHJpbmctY2k+PT8gc3RyaW5nLWNpPj8gc3RyaW5nLWNvcHkgc3RyaW5nLWZpbGwhIHN0cmluZy1sZW5ndGggc3RyaW5nLXJlZiBzdHJpbmctc2V0ISBzdHJpbmc8PT8gc3RyaW5nPD8gc3RyaW5nPT8gc3RyaW5nPj0/IHN0cmluZz4/IHN0cmluZz8gc3Vic3RyaW5nIHN5bWJvbC0+c3RyaW5nIHN5bWJvbD8gI3QgdGFuIHRyYW5zY3JpcHQtb2ZmIHRyYW5zY3JpcHQtb24gdHJ1bmNhdGUgdmFsdWVzIHZlY3RvciB2ZWN0b3ItPmxpc3QgdmVjdG9yLWZpbGwhIHZlY3Rvci1sZW5ndGggdmVjdG9yLXJlZiB2ZWN0b3Itc2V0ISB3aXRoLWlucHV0LWZyb20tZmlsZSB3aXRoLW91dHB1dC10by1maWxlIHdyaXRlIHdyaXRlLWNoYXIgemVybz9cIik7XG52YXIgaW5kZW50S2V5cyA9IG1ha2VLZXl3b3JkcyhcImRlZmluZSBsZXQgbGV0cmVjIGxldCogbGFtYmRhIGRlZmluZS1tYWNybyBkZWZtYWNybyBsZXQtc3ludGF4IGxldHJlYy1zeW50YXggbGV0LXZhbHVlcyBsZXQqLXZhbHVlcyBkZWZpbmUtc3ludGF4IHN5bnRheC1ydWxlcyBkZWZpbmUtdmFsdWVzIHdoZW4gdW5sZXNzXCIpO1xuXG5mdW5jdGlvbiBzdGF0ZVN0YWNrKGluZGVudCwgdHlwZSwgcHJldikgeyAvLyByZXByZXNlbnRzIGEgc3RhdGUgc3RhY2sgb2JqZWN0XG4gIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhY2soc3RhdGUsIGluZGVudCwgdHlwZSkge1xuICBzdGF0ZS5pbmRlbnRTdGFjayA9IG5ldyBzdGF0ZVN0YWNrKGluZGVudCwgdHlwZSwgc3RhdGUuaW5kZW50U3RhY2spO1xufVxuXG5mdW5jdGlvbiBwb3BTdGFjayhzdGF0ZSkge1xuICBzdGF0ZS5pbmRlbnRTdGFjayA9IHN0YXRlLmluZGVudFN0YWNrLnByZXY7XG59XG5cbnZhciBiaW5hcnlNYXRjaGVyID0gbmV3IFJlZ0V4cCgvXig/OlstK11pfFstK11bMDFdKyMqKD86XFwvWzAxXSsjKik/aXxbLStdP1swMV0rIyooPzpcXC9bMDFdKyMqKT9AWy0rXT9bMDFdKyMqKD86XFwvWzAxXSsjKik/fFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopP1stK10oPzpbMDFdKyMqKD86XFwvWzAxXSsjKik/KT9pfFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopPykoPz1bKClcXHM7XCJdfCQpL2kpO1xudmFyIG9jdGFsTWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdWzAtN10rIyooPzpcXC9bMC03XSsjKik/aXxbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP0BbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP3xbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP1stK10oPzpbMC03XSsjKig/OlxcL1swLTddKyMqKT8pP2l8Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT8pKD89WygpXFxzO1wiXXwkKS9pKTtcbnZhciBoZXhNYXRjaGVyID0gbmV3IFJlZ0V4cCgvXig/OlstK11pfFstK11bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT9pfFstK10/W1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/QFstK10/W1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/fFstK10/W1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/Wy0rXSg/OltcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopPyk/aXxbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopPykoPz1bKClcXHM7XCJdfCQpL2kpO1xudmFyIGRlY2ltYWxNYXRjaGVyID0gbmV3IFJlZ0V4cCgvXig/OlstK11pfFstK10oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKilpfFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopQFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopfFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopWy0rXSg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKT9pfCg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKSkoPz1bKClcXHM7XCJdfCQpL2kpO1xuXG5mdW5jdGlvbiBpc0JpbmFyeU51bWJlciAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0ubWF0Y2goYmluYXJ5TWF0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIGlzT2N0YWxOdW1iZXIgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLm1hdGNoKG9jdGFsTWF0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIGlzRGVjaW1hbE51bWJlciAoc3RyZWFtLCBiYWNrdXApIHtcbiAgaWYgKGJhY2t1cCA9PT0gdHJ1ZSkge1xuICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbS5tYXRjaChkZWNpbWFsTWF0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIGlzSGV4TnVtYmVyIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5tYXRjaChoZXhNYXRjaGVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VzY2FwZWRTZXF1ZW5jZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgdmFyIG5leHQsIGVzY2FwZWQgPSBmYWxzZTtcbiAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChuZXh0ID09IG9wdGlvbnMudG9rZW4gJiYgIWVzY2FwZWQpIHtcbiAgICAgIG9wdGlvbnMuc3RhdGUubW9kZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY2hlbWUgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZW50U3RhY2s6IG51bGwsXG4gICAgICBpbmRlbnRhdGlvbjogMCxcbiAgICAgIG1vZGU6IGZhbHNlLFxuICAgICAgc0V4cHJDb21tZW50OiBmYWxzZSxcbiAgICAgIHNFeHByUXVvdGU6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCAmJiBzdHJlYW0uc29sKCkpIHtcbiAgICAgIC8vIHVwZGF0ZSBpbmRlbnRhdGlvbiwgYnV0IG9ubHkgaWYgaW5kZW50U3RhY2sgaXMgZW1wdHlcbiAgICAgIHN0YXRlLmluZGVudGF0aW9uID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBzcGFjZXNcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuVHlwZSA9IG51bGw7XG5cbiAgICBzd2l0Y2goc3RhdGUubW9kZSl7XG4gICAgY2FzZSBcInN0cmluZ1wiOiAvLyBtdWx0aS1saW5lIHN0cmluZyBwYXJzaW5nIG1vZGVcbiAgICAgIHByb2Nlc3NFc2NhcGVkU2VxdWVuY2Uoc3RyZWFtLCB7XG4gICAgICAgIHRva2VuOiBcIlxcXCJcIixcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9KTtcbiAgICAgIHJldHVyblR5cGUgPSBTVFJJTkc7IC8vIGNvbnRpbnVlIG9uIGluIHNjaGVtZS1zdHJpbmcgbW9kZVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN5bWJvbFwiOiAvLyBlc2NhcGUgc3ltYm9sXG4gICAgICBwcm9jZXNzRXNjYXBlZFNlcXVlbmNlKHN0cmVhbSwge1xuICAgICAgICB0b2tlbjogXCJ8XCIsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm5UeXBlID0gU1lNQk9MOyAvLyBjb250aW51ZSBvbiBpbiBzY2hlbWUtc3ltYm9sIG1vZGVcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb21tZW50XCI6IC8vIGNvbW1lbnQgcGFyc2luZyBtb2RlXG4gICAgICB2YXIgbmV4dCwgbWF5YmVFbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gXCIjXCIgJiYgbWF5YmVFbmQpIHtcblxuICAgICAgICAgIHN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXliZUVuZCA9IChuZXh0ID09IFwifFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInMtZXhwci1jb21tZW50XCI6IC8vIHMtZXhwciBjb21tZW50aW5nIG1vZGVcbiAgICAgIHN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgIGlmKHN0cmVhbS5wZWVrKCkgPT0gXCIoXCIgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIltcIil7XG4gICAgICAgIC8vIGFjdHVhbGx5IHN0YXJ0IHNjaGVtZSBzLWV4cHIgY29tbWVudGluZyBtb2RlXG4gICAgICAgIHN0YXRlLnNFeHByQ29tbWVudCA9IDA7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gaWYgbm90IHdlIGp1c3QgY29tbWVudCB0aGUgZW50aXJlIG9mIHRoZSBuZXh0IHRva2VuXG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXChcXClcXFtcXF1dLyk7IC8vIGVhdCBzeW1ib2wgYXRvbVxuICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDogLy8gZGVmYXVsdCBwYXJzaW5nIG1vZGVcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAgIGlmIChjaCA9PSBcIlxcXCJcIikge1xuICAgICAgICBzdGF0ZS5tb2RlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgcmV0dXJuVHlwZSA9IFNUUklORztcblxuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIidcIikge1xuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIihcIiB8fCBzdHJlYW0ucGVlaygpID09IFwiW1wiKXtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlLnNFeHByUXVvdGUgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3RhdGUuc0V4cHJRdW90ZSA9IDA7XG4gICAgICAgICAgfSAvLyBlbHNlIGFscmVhZHkgaW4gYSBxdW90ZWQgZXhwcmVzc2lvblxuICAgICAgICAgIHJldHVyblR5cGUgPSBBVE9NO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19cXC0hJCUmKitcXC5cXC86PD0+P0BcXF5+XS8pO1xuICAgICAgICAgIHJldHVyblR5cGUgPSBBVE9NO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09ICd8Jykge1xuICAgICAgICBzdGF0ZS5tb2RlID0gXCJzeW1ib2xcIjtcbiAgICAgICAgcmV0dXJuVHlwZSA9IFNZTUJPTDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJyMnKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwifFwiKSkgeyAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktbGluZSBjb21tZW50XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFwiY29tbWVudFwiOyAvLyB0b2dnbGUgdG8gY29tbWVudCBtb2RlXG4gICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgvW3RmXS9pKSkgeyAgICAgICAgICAgIC8vICN0LyNmIChhdG9tKVxuICAgICAgICAgIHJldHVyblR5cGUgPSBBVE9NO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoJzsnKSkgeyAgICAgICAgICAgICAgICAvLyBTLUV4cHIgY29tbWVudFxuICAgICAgICAgIHN0YXRlLm1vZGUgPSBcInMtZXhwci1jb21tZW50XCI7XG4gICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG51bVRlc3QgPSBudWxsLCBoYXNFeGFjdG5lc3MgPSBmYWxzZSwgaGFzUmFkaXggPSB0cnVlO1xuICAgICAgICAgIGlmIChzdHJlYW0uZWF0KC9bZWldL2kpKSB7XG4gICAgICAgICAgICBoYXNFeGFjdG5lc3MgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAvLyBtdXN0IGJlIHJhZGl4IHNwZWNpZmllclxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eI2IvaSkpIHtcbiAgICAgICAgICAgIG51bVRlc3QgPSBpc0JpbmFyeU51bWJlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiNvL2kpKSB7XG4gICAgICAgICAgICBudW1UZXN0ID0gaXNPY3RhbE51bWJlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiN4L2kpKSB7XG4gICAgICAgICAgICBudW1UZXN0ID0gaXNIZXhOdW1iZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14jZC9pKSkge1xuICAgICAgICAgICAgbnVtVGVzdCA9IGlzRGVjaW1hbE51bWJlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlstKzAtOS5dLywgZmFsc2UpKSB7XG4gICAgICAgICAgICBoYXNSYWRpeCA9IGZhbHNlO1xuICAgICAgICAgICAgbnVtVGVzdCA9IGlzRGVjaW1hbE51bWJlcjtcbiAgICAgICAgICAgIC8vIHJlLWNvbnN1bWUgdGhlIGluaXRpYWwgIyBpZiBhbGwgbWF0Y2hlcyBmYWlsZWRcbiAgICAgICAgICB9IGVsc2UgaWYgKCFoYXNFeGFjdG5lc3MpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoJyMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bVRlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGhhc1JhZGl4ICYmICFoYXNFeGFjdG5lc3MpIHtcbiAgICAgICAgICAgICAgLy8gY29uc3VtZSBvcHRpb25hbCBleGFjdG5lc3MgYWZ0ZXIgcmFkaXhcbiAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eI1tlaV0vaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtVGVzdChzdHJlYW0pKVxuICAgICAgICAgICAgICByZXR1cm5UeXBlID0gTlVNQkVSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgvXlstKzAtOS5dLy50ZXN0KGNoKSAmJiBpc0RlY2ltYWxOdW1iZXIoc3RyZWFtLCB0cnVlKSkgeyAvLyBtYXRjaCBub24tcHJlZml4ZWQgbnVtYmVyLCBtdXN0IGJlIGRlY2ltYWxcbiAgICAgICAgcmV0dXJuVHlwZSA9IE5VTUJFUjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI7XCIpIHsgLy8gY29tbWVudFxuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7IC8vIHJlc3Qgb2YgdGhlIGxpbmUgaXMgYSBjb21tZW50XG4gICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIihcIiB8fCBjaCA9PSBcIltcIikge1xuICAgICAgICB2YXIga2V5V29yZCA9ICcnOyB2YXIgaW5kZW50VGVtcCA9IHN0cmVhbS5jb2x1bW4oKSwgbGV0dGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICAgRWl0aGVyXG4gICAgICAgICAgIChpbmRlbnQtd29yZCAuLlxuICAgICAgICAgICAobm9uLWluZGVudC13b3JkIC4uXG4gICAgICAgICAgICg7c29tZXRoaW5nIGVsc2UsIGJyYWNrZXQsIGV0Yy5cbiAgICAgICAgKi9cblxuICAgICAgICB3aGlsZSAoKGxldHRlciA9IHN0cmVhbS5lYXQoL1teXFxzXFwoXFxbXFw7XFwpXFxdXS8pKSAhPSBudWxsKSB7XG4gICAgICAgICAga2V5V29yZCArPSBsZXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5V29yZC5sZW5ndGggPiAwICYmIGluZGVudEtleXMucHJvcGVydHlJc0VudW1lcmFibGUoa2V5V29yZCkpIHsgLy8gaW5kZW50LXdvcmRcblxuICAgICAgICAgIHB1c2hTdGFjayhzdGF0ZSwgaW5kZW50VGVtcCArIElOREVOVF9XT1JEX1NLSVAsIGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm9uLWluZGVudCB3b3JkXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZWF0aW5nIHRoZSBzcGFjZXNcbiAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVvbCgpIHx8IHN0cmVhbS5wZWVrKCkgPT0gXCI7XCIpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgc2lnbmlmaWNhbnQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIHdlIHJlc3RhcnQgaW5kZW50YXRpb24gMSBzcGFjZSBhZnRlclxuICAgICAgICAgICAgcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnRUZW1wICsgMSwgY2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoU3RhY2soc3RhdGUsIGluZGVudFRlbXAgKyBzdHJlYW0uY3VycmVudCgpLmxlbmd0aCwgY2gpOyAvLyBlbHNlIHdlIG1hdGNoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggLSAxKTsgLy8gdW5kbyBhbGwgdGhlIGVhdGluZ1xuXG4gICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwckNvbW1lbnQgPT0gXCJudW1iZXJcIikgc3RhdGUuc0V4cHJDb21tZW50Kys7XG4gICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlID09IFwibnVtYmVyXCIpIHN0YXRlLnNFeHByUXVvdGUrKztcblxuICAgICAgICByZXR1cm5UeXBlID0gQlJBQ0tFVDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIpXCIgfHwgY2ggPT0gXCJdXCIpIHtcbiAgICAgICAgcmV0dXJuVHlwZSA9IEJSQUNLRVQ7XG4gICAgICAgIGlmIChzdGF0ZS5pbmRlbnRTdGFjayAhPSBudWxsICYmIHN0YXRlLmluZGVudFN0YWNrLnR5cGUgPT0gKGNoID09IFwiKVwiID8gXCIoXCIgOiBcIltcIikpIHtcbiAgICAgICAgICBwb3BTdGFjayhzdGF0ZSk7XG5cbiAgICAgICAgICBpZih0eXBlb2Ygc3RhdGUuc0V4cHJDb21tZW50ID09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgaWYoLS1zdGF0ZS5zRXhwckNvbW1lbnQgPT0gMCl7XG4gICAgICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UOyAvLyBmaW5hbCBjbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgc3RhdGUuc0V4cHJDb21tZW50ID0gZmFsc2U7IC8vIHR1cm4gb2ZmIHMtZXhwciBjb21tZW50aW5nIG1vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodHlwZW9mIHN0YXRlLnNFeHByUXVvdGUgPT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICBpZigtLXN0YXRlLnNFeHByUXVvdGUgPT0gMCl7XG4gICAgICAgICAgICAgIHJldHVyblR5cGUgPSBBVE9NOyAvLyBmaW5hbCBjbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgc3RhdGUuc0V4cHJRdW90ZSA9IGZhbHNlOyAvLyB0dXJuIG9mZiBzLWV4cHIgcXVvdGUgbW9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X1xcLSEkJSYqK1xcLlxcLzo8PT4/QFxcXn5dLyk7XG5cbiAgICAgICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgcmV0dXJuVHlwZSA9IEJVSUxUSU47XG4gICAgICAgIH0gZWxzZSByZXR1cm5UeXBlID0gXCJ2YXJpYWJsZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHR5cGVvZiBzdGF0ZS5zRXhwckNvbW1lbnQgPT0gXCJudW1iZXJcIikgPyBDT01NRU5UIDogKCh0eXBlb2Ygc3RhdGUuc0V4cHJRdW90ZSA9PSBcIm51bWJlclwiKSA/IEFUT00gOiByZXR1cm5UeXBlKTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5pbmRlbnRTdGFjayA9PSBudWxsKSByZXR1cm4gc3RhdGUuaW5kZW50YXRpb247XG4gICAgcmV0dXJuIHN0YXRlLmluZGVudFN0YWNrLmluZGVudDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCAnXCInXX0sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiOztcIn1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==