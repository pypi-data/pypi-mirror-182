"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_free-style_dist_es2015_index_js"],{

/***/ "../../node_modules/free-style/dist.es2015/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/free-style/dist.es2015/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => (/* binding */ Cache),
/* harmony export */   "FreeStyle": () => (/* binding */ FreeStyle),
/* harmony export */   "Rule": () => (/* binding */ Rule),
/* harmony export */   "Selector": () => (/* binding */ Selector),
/* harmony export */   "Style": () => (/* binding */ Style),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/**
 * The unique id is used for unique hashes.
 */
let uniqueId = 0;
/**
 * Quick dictionary lookup for unit-less numbers.
 */
const CSS_NUMBER = Object.create(null);
/**
 * CSS properties that are valid unit-less numbers.
 *
 * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js
 */
const CSS_NUMBER_KEYS = [
    "animation-iteration-count",
    "border-image-outset",
    "border-image-slice",
    "border-image-width",
    "box-flex",
    "box-flex-group",
    "box-ordinal-group",
    "column-count",
    "columns",
    "counter-increment",
    "counter-reset",
    "flex",
    "flex-grow",
    "flex-positive",
    "flex-shrink",
    "flex-negative",
    "flex-order",
    "font-weight",
    "grid-area",
    "grid-column",
    "grid-column-end",
    "grid-column-span",
    "grid-column-start",
    "grid-row",
    "grid-row-end",
    "grid-row-span",
    "grid-row-start",
    "line-clamp",
    "line-height",
    "opacity",
    "order",
    "orphans",
    "tab-size",
    "widows",
    "z-index",
    "zoom",
    // SVG properties.
    "fill-opacity",
    "flood-opacity",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width"
];
// Add vendor prefixes to all unit-less properties.
for (const property of CSS_NUMBER_KEYS) {
    for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
        CSS_NUMBER[prefix + property] = true;
    }
}
/**
 * Escape a CSS class name.
 */
function escape(str) {
    return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
/**
 * Transform a JavaScript property into a CSS property.
 */
function hyphenate(propertyName) {
    return propertyName
        .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)
        .replace(/^ms-/, "-ms-"); // Internet Explorer vendor prefix.
}
/**
 * Generate a hash value from a string.
 */
function stringHash(str) {
    let value = 5381;
    let len = str.length;
    while (len--)
        value = (value * 33) ^ str.charCodeAt(len);
    return (value >>> 0).toString(36);
}
/**
 * Transform a style string to a CSS string.
 */
function styleToString(key, value) {
    if (value && typeof value === "number" && !CSS_NUMBER[key]) {
        return `${key}:${value}px`;
    }
    return `${key}:${value}`;
}
/**
 * Sort an array of tuples by first value.
 */
function sortTuples(value) {
    return value.sort((a, b) => (a[0] > b[0] ? 1 : -1));
}
/**
 * Categorize user styles.
 */
function parseStyles(styles, hasNestedStyles) {
    const properties = [];
    const nestedStyles = [];
    // Sort keys before adding to styles.
    for (const key of Object.keys(styles)) {
        const name = key.trim();
        const value = styles[key];
        if (name.charCodeAt(0) !== 36 /* $ */ && value != null) {
            if (typeof value === "object" && !Array.isArray(value)) {
                nestedStyles.push([name, value]);
            }
            else {
                properties.push([hyphenate(name), value]);
            }
        }
    }
    return {
        style: stringifyProperties(sortTuples(properties)),
        nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
        isUnique: !!styles.$unique
    };
}
/**
 * Stringify an array of property tuples.
 */
function stringifyProperties(properties) {
    return properties
        .map(([name, value]) => {
        if (!Array.isArray(value))
            return styleToString(name, value);
        return value.map(x => styleToString(name, x)).join(";");
    })
        .join(";");
}
/**
 * Interpolate CSS selectors.
 */
function interpolate(selector, parent) {
    if (selector.indexOf("&") === -1)
        return `${parent} ${selector}`;
    return selector.replace(/&/g, parent);
}
/**
 * Recursive loop building styles with deferred selectors.
 */
function stylize(selector, styles, rulesList, stylesList, parent) {
    const { style, nested, isUnique } = parseStyles(styles, selector !== "");
    let pid = style;
    if (selector.charCodeAt(0) === 64 /* @ */) {
        const child = {
            selector,
            styles: [],
            rules: [],
            style: parent ? "" : style
        };
        rulesList.push(child);
        // Nested styles support (e.g. `.foo > @media > .bar`).
        if (style && parent) {
            child.styles.push({ selector: parent, style, isUnique });
        }
        for (const [name, value] of nested) {
            pid += name + stylize(name, value, child.rules, child.styles, parent);
        }
    }
    else {
        const key = parent ? interpolate(selector, parent) : selector;
        if (style)
            stylesList.push({ selector: key, style, isUnique });
        for (const [name, value] of nested) {
            pid += name + stylize(name, value, rulesList, stylesList, key);
        }
    }
    return pid;
}
/**
 * Transform `stylize` tree into style objects.
 */
function composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {
    for (const { selector, style, isUnique } of stylesList) {
        const key = isStyle ? interpolate(selector, className) : selector;
        const id = isUnique
            ? `u\0${(++uniqueId).toString(36)}`
            : `s\0${pid}\0${style}`;
        const item = new Style(style, id);
        item.add(new Selector(key, `k\0${pid}\0${key}`));
        cache.add(item);
    }
    for (const { selector, style, rules, styles } of rulesList) {
        const item = new Rule(selector, style, `r\0${pid}\0${selector}\0${style}`);
        composeStylize(item, pid, rules, styles, className, isStyle);
        cache.add(item);
    }
}
/**
 * Cache to list to styles.
 */
function join(arr) {
    let res = "";
    for (let i = 0; i < arr.length; i++)
        res += arr[i];
    return res;
}
/**
 * Noop changes.
 */
const noopChanges = {
    add: () => undefined,
    change: () => undefined,
    remove: () => undefined
};
/**
 * Implement a cache/event emitter.
 */
class Cache {
    constructor(changes = noopChanges) {
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = Object.create(null);
        this._counters = Object.create(null);
    }
    add(style) {
        const count = this._counters[style.id] || 0;
        const item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
            this._children[item.id] = item;
            this._keys.push(item.id);
            this.sheet.push(item.getStyles());
            this.changeId++;
            this.changes.add(item, this._keys.length - 1);
        }
        else if (item instanceof Cache && style instanceof Cache) {
            const curIndex = this._keys.indexOf(style.id);
            const prevItemChangeId = item.changeId;
            item.merge(style);
            if (item.changeId !== prevItemChangeId) {
                this.sheet.splice(curIndex, 1, item.getStyles());
                this.changeId++;
                this.changes.change(item, curIndex, curIndex);
            }
        }
    }
    remove(style) {
        const count = this._counters[style.id];
        if (count) {
            this._counters[style.id] = count - 1;
            const item = this._children[style.id];
            const index = this._keys.indexOf(item.id);
            if (count === 1) {
                delete this._counters[style.id];
                delete this._children[style.id];
                this._keys.splice(index, 1);
                this.sheet.splice(index, 1);
                this.changeId++;
                this.changes.remove(item, index);
            }
            else if (item instanceof Cache && style instanceof Cache) {
                const prevChangeId = item.changeId;
                item.unmerge(style);
                if (item.changeId !== prevChangeId) {
                    this.sheet.splice(index, 1, item.getStyles());
                    this.changeId++;
                    this.changes.change(item, index, index);
                }
            }
        }
    }
    values() {
        return this._keys.map(key => this._children[key]);
    }
    merge(cache) {
        for (const item of cache.values())
            this.add(item);
        return this;
    }
    unmerge(cache) {
        for (const item of cache.values())
            this.remove(item);
        return this;
    }
    clone() {
        return new Cache().merge(this);
    }
}
/**
 * Selector is a dumb class made to represent nested CSS selectors.
 */
class Selector {
    constructor(selector, id) {
        this.selector = selector;
        this.id = id;
    }
    getStyles() {
        return this.selector;
    }
    clone() {
        return this;
    }
}
/**
 * The style container registers a style string with selectors.
 */
class Style extends Cache {
    constructor(style, id) {
        super();
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.sheet.join(",")}{${this.style}}`;
    }
    clone() {
        return new Style(this.style, this.id).merge(this);
    }
}
/**
 * Implement rule logic for style output.
 */
class Rule extends Cache {
    constructor(rule, style, id) {
        super();
        this.rule = rule;
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.rule}{${this.style}${join(this.sheet)}}`;
    }
    clone() {
        return new Rule(this.rule, this.style, this.id).merge(this);
    }
}
function key(pid, styles) {
    const key = `f${stringHash(pid)}`;
    if ( false || !styles.$displayName)
        return key;
    return `${styles.$displayName}_${key}`;
}
/**
 * The FreeStyle class implements the API for everything else.
 */
class FreeStyle extends Cache {
    constructor(id, changes) {
        super(changes);
        this.id = id;
    }
    registerStyle(styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("&", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `.${ false ? 0 : escape(id)}`;
        composeStylize(this, pid, rulesList, stylesList, selector, true);
        return id;
    }
    registerKeyframes(keyframes) {
        return this.registerHashRule("@keyframes", keyframes);
    }
    registerHashRule(prefix, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `${prefix} ${ false ? 0 : escape(id)}`;
        const rule = new Rule(selector, "", `h\0${pid}\0${prefix}`);
        composeStylize(rule, pid, rulesList, stylesList, "", false);
        this.add(rule);
        return id;
    }
    registerRule(rule, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize(rule, styles, rulesList, stylesList);
        composeStylize(this, pid, rulesList, stylesList, "", false);
    }
    registerCss(styles) {
        return this.registerRule("", styles);
    }
    getStyles() {
        return join(this.sheet);
    }
    clone() {
        return new FreeStyle(this.id, this.changes).merge(this);
    }
}
/**
 * Exports a simple function to create a new instance.
 */
function create(changes) {
    return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
}
//# sourceMappingURL=index.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZnJlZS1zdHlsZV9kaXN0X2VzMjAxNV9pbmRleF9qcy5hZmRkMGI5MDA1YWI0MWQ2ODE4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLE1BQU07QUFDL0I7QUFDQSxjQUFjLElBQUksR0FBRyxNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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L2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZnJlZS1zdHlsZS9kaXN0LmVzMjAxNS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSB1bmlxdWUgaWQgaXMgdXNlZCBmb3IgdW5pcXVlIGhhc2hlcy5cbiAqL1xubGV0IHVuaXF1ZUlkID0gMDtcbi8qKlxuICogUXVpY2sgZGljdGlvbmFyeSBsb29rdXAgZm9yIHVuaXQtbGVzcyBudW1iZXJzLlxuICovXG5jb25zdCBDU1NfTlVNQkVSID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhcmUgdmFsaWQgdW5pdC1sZXNzIG51bWJlcnMuXG4gKlxuICogUmVmOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvQ1NTUHJvcGVydHkuanNcbiAqL1xuY29uc3QgQ1NTX05VTUJFUl9LRVlTID0gW1xuICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLFxuICAgIFwiYm9yZGVyLWltYWdlLW91dHNldFwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXNsaWNlXCIsXG4gICAgXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcbiAgICBcImJveC1mbGV4XCIsXG4gICAgXCJib3gtZmxleC1ncm91cFwiLFxuICAgIFwiYm94LW9yZGluYWwtZ3JvdXBcIixcbiAgICBcImNvbHVtbi1jb3VudFwiLFxuICAgIFwiY29sdW1uc1wiLFxuICAgIFwiY291bnRlci1pbmNyZW1lbnRcIixcbiAgICBcImNvdW50ZXItcmVzZXRcIixcbiAgICBcImZsZXhcIixcbiAgICBcImZsZXgtZ3Jvd1wiLFxuICAgIFwiZmxleC1wb3NpdGl2ZVwiLFxuICAgIFwiZmxleC1zaHJpbmtcIixcbiAgICBcImZsZXgtbmVnYXRpdmVcIixcbiAgICBcImZsZXgtb3JkZXJcIixcbiAgICBcImZvbnQtd2VpZ2h0XCIsXG4gICAgXCJncmlkLWFyZWFcIixcbiAgICBcImdyaWQtY29sdW1uXCIsXG4gICAgXCJncmlkLWNvbHVtbi1lbmRcIixcbiAgICBcImdyaWQtY29sdW1uLXNwYW5cIixcbiAgICBcImdyaWQtY29sdW1uLXN0YXJ0XCIsXG4gICAgXCJncmlkLXJvd1wiLFxuICAgIFwiZ3JpZC1yb3ctZW5kXCIsXG4gICAgXCJncmlkLXJvdy1zcGFuXCIsXG4gICAgXCJncmlkLXJvdy1zdGFydFwiLFxuICAgIFwibGluZS1jbGFtcFwiLFxuICAgIFwibGluZS1oZWlnaHRcIixcbiAgICBcIm9wYWNpdHlcIixcbiAgICBcIm9yZGVyXCIsXG4gICAgXCJvcnBoYW5zXCIsXG4gICAgXCJ0YWItc2l6ZVwiLFxuICAgIFwid2lkb3dzXCIsXG4gICAgXCJ6LWluZGV4XCIsXG4gICAgXCJ6b29tXCIsXG4gICAgLy8gU1ZHIHByb3BlcnRpZXMuXG4gICAgXCJmaWxsLW9wYWNpdHlcIixcbiAgICBcImZsb29kLW9wYWNpdHlcIixcbiAgICBcInN0b3Atb3BhY2l0eVwiLFxuICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLFxuICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgICBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gICAgXCJzdHJva2Utb3BhY2l0eVwiLFxuICAgIFwic3Ryb2tlLXdpZHRoXCJcbl07XG4vLyBBZGQgdmVuZG9yIHByZWZpeGVzIHRvIGFsbCB1bml0LWxlc3MgcHJvcGVydGllcy5cbmZvciAoY29uc3QgcHJvcGVydHkgb2YgQ1NTX05VTUJFUl9LRVlTKSB7XG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgW1wiLXdlYmtpdC1cIiwgXCItbXMtXCIsIFwiLW1vei1cIiwgXCItby1cIiwgXCJcIl0pIHtcbiAgICAgICAgQ1NTX05VTUJFUltwcmVmaXggKyBwcm9wZXJ0eV0gPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogRXNjYXBlIGEgQ1NTIGNsYXNzIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1sgISMkJSYoKSorLC4vOzw9Pj9AW1xcXV5ge3x9flwiJ1xcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBKYXZhU2NyaXB0IHByb3BlcnR5IGludG8gYSBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gcHJvcGVydHlOYW1lXG4gICAgICAgIC5yZXBsYWNlKC9bQS1aXS9nLCAobSkgPT4gYC0ke20udG9Mb3dlckNhc2UoKX1gKVxuICAgICAgICAucmVwbGFjZSgvXm1zLS8sIFwiLW1zLVwiKTsgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdmVuZG9yIHByZWZpeC5cbn1cbi8qKlxuICogR2VuZXJhdGUgYSBoYXNoIHZhbHVlIGZyb20gYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0hhc2goc3RyKSB7XG4gICAgbGV0IHZhbHVlID0gNTM4MTtcbiAgICBsZXQgbGVuID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuLS0pXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICogMzMpIF4gc3RyLmNoYXJDb2RlQXQobGVuKTtcbiAgICByZXR1cm4gKHZhbHVlID4+PiAwKS50b1N0cmluZygzNik7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhIHN0eWxlIHN0cmluZyB0byBhIENTUyBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0eWxlVG9TdHJpbmcoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIUNTU19OVU1CRVJba2V5XSkge1xuICAgICAgICByZXR1cm4gYCR7a2V5fToke3ZhbHVlfXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZX1gO1xufVxuLyoqXG4gKiBTb3J0IGFuIGFycmF5IG9mIHR1cGxlcyBieSBmaXJzdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc29ydFR1cGxlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zb3J0KChhLCBiKSA9PiAoYVswXSA+IGJbMF0gPyAxIDogLTEpKTtcbn1cbi8qKlxuICogQ2F0ZWdvcml6ZSB1c2VyIHN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTdHlsZXMoc3R5bGVzLCBoYXNOZXN0ZWRTdHlsZXMpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3QgbmVzdGVkU3R5bGVzID0gW107XG4gICAgLy8gU29ydCBrZXlzIGJlZm9yZSBhZGRpbmcgdG8gc3R5bGVzLlxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHN0eWxlcykpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGtleS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgIT09IDM2IC8qICQgKi8gJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRTdHlsZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbaHlwaGVuYXRlKG5hbWUpLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiBzdHJpbmdpZnlQcm9wZXJ0aWVzKHNvcnRUdXBsZXMocHJvcGVydGllcykpLFxuICAgICAgICBuZXN0ZWQ6IGhhc05lc3RlZFN0eWxlcyA/IG5lc3RlZFN0eWxlcyA6IHNvcnRUdXBsZXMobmVzdGVkU3R5bGVzKSxcbiAgICAgICAgaXNVbmlxdWU6ICEhc3R5bGVzLiR1bmlxdWVcbiAgICB9O1xufVxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gYXJyYXkgb2YgcHJvcGVydHkgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gcHJvcGVydGllc1xuICAgICAgICAubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGVUb1N0cmluZyhuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoeCA9PiBzdHlsZVRvU3RyaW5nKG5hbWUsIHgpKS5qb2luKFwiO1wiKTtcbiAgICB9KVxuICAgICAgICAuam9pbihcIjtcIik7XG59XG4vKipcbiAqIEludGVycG9sYXRlIENTUyBzZWxlY3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgICBpZiAoc2VsZWN0b3IuaW5kZXhPZihcIiZcIikgPT09IC0xKVxuICAgICAgICByZXR1cm4gYCR7cGFyZW50fSAke3NlbGVjdG9yfWA7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoLyYvZywgcGFyZW50KTtcbn1cbi8qKlxuICogUmVjdXJzaXZlIGxvb3AgYnVpbGRpbmcgc3R5bGVzIHdpdGggZGVmZXJyZWQgc2VsZWN0b3JzLlxuICovXG5mdW5jdGlvbiBzdHlsaXplKHNlbGVjdG9yLCBzdHlsZXMsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwgcGFyZW50KSB7XG4gICAgY29uc3QgeyBzdHlsZSwgbmVzdGVkLCBpc1VuaXF1ZSB9ID0gcGFyc2VTdHlsZXMoc3R5bGVzLCBzZWxlY3RvciAhPT0gXCJcIik7XG4gICAgbGV0IHBpZCA9IHN0eWxlO1xuICAgIGlmIChzZWxlY3Rvci5jaGFyQ29kZUF0KDApID09PSA2NCAvKiBAICovKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgc3R5bGU6IHBhcmVudCA/IFwiXCIgOiBzdHlsZVxuICAgICAgICB9O1xuICAgICAgICBydWxlc0xpc3QucHVzaChjaGlsZCk7XG4gICAgICAgIC8vIE5lc3RlZCBzdHlsZXMgc3VwcG9ydCAoZS5nLiBgLmZvbyA+IEBtZWRpYSA+IC5iYXJgKS5cbiAgICAgICAgaWYgKHN0eWxlICYmIHBhcmVudCkge1xuICAgICAgICAgICAgY2hpbGQuc3R5bGVzLnB1c2goeyBzZWxlY3RvcjogcGFyZW50LCBzdHlsZSwgaXNVbmlxdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG5lc3RlZCkge1xuICAgICAgICAgICAgcGlkICs9IG5hbWUgKyBzdHlsaXplKG5hbWUsIHZhbHVlLCBjaGlsZC5ydWxlcywgY2hpbGQuc3R5bGVzLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnQgPyBpbnRlcnBvbGF0ZShzZWxlY3RvciwgcGFyZW50KSA6IHNlbGVjdG9yO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBzdHlsZXNMaXN0LnB1c2goeyBzZWxlY3Rvcjoga2V5LCBzdHlsZSwgaXNVbmlxdWUgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBuZXN0ZWQpIHtcbiAgICAgICAgICAgIHBpZCArPSBuYW1lICsgc3R5bGl6ZShuYW1lLCB2YWx1ZSwgcnVsZXNMaXN0LCBzdHlsZXNMaXN0LCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaWQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBgc3R5bGl6ZWAgdHJlZSBpbnRvIHN0eWxlIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VTdHlsaXplKGNhY2hlLCBwaWQsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwgY2xhc3NOYW1lLCBpc1N0eWxlKSB7XG4gICAgZm9yIChjb25zdCB7IHNlbGVjdG9yLCBzdHlsZSwgaXNVbmlxdWUgfSBvZiBzdHlsZXNMaXN0KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGlzU3R5bGUgPyBpbnRlcnBvbGF0ZShzZWxlY3RvciwgY2xhc3NOYW1lKSA6IHNlbGVjdG9yO1xuICAgICAgICBjb25zdCBpZCA9IGlzVW5pcXVlXG4gICAgICAgICAgICA/IGB1XFwwJHsoKyt1bmlxdWVJZCkudG9TdHJpbmcoMzYpfWBcbiAgICAgICAgICAgIDogYHNcXDAke3BpZH1cXDAke3N0eWxlfWA7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgU3R5bGUoc3R5bGUsIGlkKTtcbiAgICAgICAgaXRlbS5hZGQobmV3IFNlbGVjdG9yKGtleSwgYGtcXDAke3BpZH1cXDAke2tleX1gKSk7XG4gICAgICAgIGNhY2hlLmFkZChpdGVtKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7IHNlbGVjdG9yLCBzdHlsZSwgcnVsZXMsIHN0eWxlcyB9IG9mIHJ1bGVzTGlzdCkge1xuICAgICAgICBjb25zdCBpdGVtID0gbmV3IFJ1bGUoc2VsZWN0b3IsIHN0eWxlLCBgclxcMCR7cGlkfVxcMCR7c2VsZWN0b3J9XFwwJHtzdHlsZX1gKTtcbiAgICAgICAgY29tcG9zZVN0eWxpemUoaXRlbSwgcGlkLCBydWxlcywgc3R5bGVzLCBjbGFzc05hbWUsIGlzU3R5bGUpO1xuICAgICAgICBjYWNoZS5hZGQoaXRlbSk7XG4gICAgfVxufVxuLyoqXG4gKiBDYWNoZSB0byBsaXN0IHRvIHN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gam9pbihhcnIpIHtcbiAgICBsZXQgcmVzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzICs9IGFycltpXTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBOb29wIGNoYW5nZXMuXG4gKi9cbmNvbnN0IG5vb3BDaGFuZ2VzID0ge1xuICAgIGFkZDogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNoYW5nZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIHJlbW92ZTogKCkgPT4gdW5kZWZpbmVkXG59O1xuLyoqXG4gKiBJbXBsZW1lbnQgYSBjYWNoZS9ldmVudCBlbWl0dGVyLlxuICovXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMgPSBub29wQ2hhbmdlcykge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNoZWV0ID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlSWQgPSAwO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBhZGQoc3R5bGUpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9jb3VudGVyc1tzdHlsZS5pZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW3N0eWxlLmlkXSB8fCBzdHlsZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9jb3VudGVyc1tzdHlsZS5pZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baXRlbS5pZF0gPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgICAgdGhpcy5zaGVldC5wdXNoKGl0ZW0uZ2V0U3R5bGVzKCkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmFkZChpdGVtLCB0aGlzLl9rZXlzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDYWNoZSAmJiBzdHlsZSBpbnN0YW5jZW9mIENhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJJbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZihzdHlsZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2SXRlbUNoYW5nZUlkID0gaXRlbS5jaGFuZ2VJZDtcbiAgICAgICAgICAgIGl0ZW0ubWVyZ2Uoc3R5bGUpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2hhbmdlSWQgIT09IHByZXZJdGVtQ2hhbmdlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWV0LnNwbGljZShjdXJJbmRleCwgMSwgaXRlbS5nZXRTdHlsZXMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5jaGFuZ2UoaXRlbSwgY3VySW5kZXgsIGN1ckluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoc3R5bGUpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9jb3VudGVyc1tzdHlsZS5pZF07XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdID0gY291bnQgLSAxO1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW3N0eWxlLmlkXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvdW50ZXJzW3N0eWxlLmlkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bc3R5bGUuaWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWV0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5yZW1vdmUoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIENhY2hlICYmIHN0eWxlIGluc3RhbmNlb2YgQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhbmdlSWQgPSBpdGVtLmNoYW5nZUlkO1xuICAgICAgICAgICAgICAgIGl0ZW0udW5tZXJnZShzdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hhbmdlSWQgIT09IHByZXZDaGFuZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWV0LnNwbGljZShpbmRleCwgMSwgaXRlbS5nZXRTdHlsZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmNoYW5nZShpdGVtLCBpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzLm1hcChrZXkgPT4gdGhpcy5fY2hpbGRyZW5ba2V5XSk7XG4gICAgfVxuICAgIG1lcmdlKGNhY2hlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjYWNoZS52YWx1ZXMoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW5tZXJnZShjYWNoZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2FjaGUudmFsdWVzKCkpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENhY2hlKCkubWVyZ2UodGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiBTZWxlY3RvciBpcyBhIGR1bWIgY2xhc3MgbWFkZSB0byByZXByZXNlbnQgbmVzdGVkIENTUyBzZWxlY3RvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIGlkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICBnZXRTdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc3R5bGUgY29udGFpbmVyIHJlZ2lzdGVycyBhIHN0eWxlIHN0cmluZyB3aXRoIHNlbGVjdG9ycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0eWxlIGV4dGVuZHMgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHN0eWxlLCBpZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zaGVldC5qb2luKFwiLFwiKX17JHt0aGlzLnN0eWxlfX1gO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZSh0aGlzLnN0eWxlLCB0aGlzLmlkKS5tZXJnZSh0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudCBydWxlIGxvZ2ljIGZvciBzdHlsZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdWxlIGV4dGVuZHMgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGUsIHN0eWxlLCBpZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5ydWxlfXske3RoaXMuc3R5bGV9JHtqb2luKHRoaXMuc2hlZXQpfX1gO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlKHRoaXMucnVsZSwgdGhpcy5zdHlsZSwgdGhpcy5pZCkubWVyZ2UodGhpcyk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5KHBpZCwgc3R5bGVzKSB7XG4gICAgY29uc3Qga2V5ID0gYGYke3N0cmluZ0hhc2gocGlkKX1gO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgIXN0eWxlcy4kZGlzcGxheU5hbWUpXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgcmV0dXJuIGAke3N0eWxlcy4kZGlzcGxheU5hbWV9XyR7a2V5fWA7XG59XG4vKipcbiAqIFRoZSBGcmVlU3R5bGUgY2xhc3MgaW1wbGVtZW50cyB0aGUgQVBJIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmVlU3R5bGUgZXh0ZW5kcyBDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIoY2hhbmdlcyk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgcmVnaXN0ZXJTdHlsZShzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZXNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHN0eWxlc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgcGlkID0gc3R5bGl6ZShcIiZcIiwgc3R5bGVzLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QpO1xuICAgICAgICBjb25zdCBpZCA9IGtleShwaWQsIHN0eWxlcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYC4ke3Byb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGlkIDogZXNjYXBlKGlkKX1gO1xuICAgICAgICBjb21wb3NlU3R5bGl6ZSh0aGlzLCBwaWQsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwgc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHJlZ2lzdGVyS2V5ZnJhbWVzKGtleWZyYW1lcykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3Rlckhhc2hSdWxlKFwiQGtleWZyYW1lc1wiLCBrZXlmcmFtZXMpO1xuICAgIH1cbiAgICByZWdpc3Rlckhhc2hSdWxlKHByZWZpeCwgc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBzdHlsZXNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHBpZCA9IHN0eWxpemUoXCJcIiwgc3R5bGVzLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QpO1xuICAgICAgICBjb25zdCBpZCA9IGtleShwaWQsIHN0eWxlcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYCR7cHJlZml4fSAke3Byb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGlkIDogZXNjYXBlKGlkKX1gO1xuICAgICAgICBjb25zdCBydWxlID0gbmV3IFJ1bGUoc2VsZWN0b3IsIFwiXCIsIGBoXFwwJHtwaWR9XFwwJHtwcmVmaXh9YCk7XG4gICAgICAgIGNvbXBvc2VTdHlsaXplKHJ1bGUsIHBpZCwgcnVsZXNMaXN0LCBzdHlsZXNMaXN0LCBcIlwiLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYWRkKHJ1bGUpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHJlZ2lzdGVyUnVsZShydWxlLCBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZXNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHN0eWxlc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgcGlkID0gc3R5bGl6ZShydWxlLCBzdHlsZXMsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCk7XG4gICAgICAgIGNvbXBvc2VTdHlsaXplKHRoaXMsIHBpZCwgcnVsZXNMaXN0LCBzdHlsZXNMaXN0LCBcIlwiLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ3NzKHN0eWxlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJ1bGUoXCJcIiwgc3R5bGVzKTtcbiAgICB9XG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gam9pbih0aGlzLnNoZWV0KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVN0eWxlKHRoaXMuaWQsIHRoaXMuY2hhbmdlcykubWVyZ2UodGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiBFeHBvcnRzIGEgc2ltcGxlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFuZ2VzKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlU3R5bGUoYGYkeygrK3VuaXF1ZUlkKS50b1N0cmluZygzNil9YCwgY2hhbmdlcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=