"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_swift_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/swift.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/swift.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "swift": () => (/* binding */ swift)
/* harmony export */ });
function wordSet(words) {
  var set = {}
  for (var i = 0; i < words.length; i++) set[words[i]] = true
  return set
}

var keywords = wordSet(["_","var","let","actor","class","enum","extension","import","protocol","struct","func","typealias","associatedtype",
                        "open","public","internal","fileprivate","private","deinit","init","new","override","self","subscript","super",
                        "convenience","dynamic","final","indirect","lazy","required","static","unowned","unowned(safe)","unowned(unsafe)","weak","as","is",
                        "break","case","continue","default","else","fallthrough","for","guard","if","in","repeat","switch","where","while",
                        "defer","return","inout","mutating","nonmutating","isolated","nonisolated","catch","do","rethrows","throw","throws","async","await","try","didSet","get","set","willSet",
                        "assignment","associativity","infix","left","none","operator","postfix","precedence","precedencegroup","prefix","right",
                        "Any","AnyObject","Type","dynamicType","Self","Protocol","__COLUMN__","__FILE__","__FUNCTION__","__LINE__"])
var definingKeywords = wordSet(["var","let","actor","class","enum","extension","import","protocol","struct","func","typealias","associatedtype","for"])
var atoms = wordSet(["true","false","nil","self","super","_"])
var types = wordSet(["Array","Bool","Character","Dictionary","Double","Float","Int","Int8","Int16","Int32","Int64","Never","Optional","Set","String",
                     "UInt8","UInt16","UInt32","UInt64","Void"])
var operators = "+-/*%=|&<>~^?!"
var punc = ":;,.(){}[]"
var binary = /^\-?0b[01][01_]*/
var octal = /^\-?0o[0-7][0-7_]*/
var hexadecimal = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/
var decimal = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/
var identifier = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/
var property = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/
var instruction = /^\#[A-Za-z]+/
var attribute = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/
//var regexp = /^\/(?!\s)(?:\/\/)?(?:\\.|[^\/])+\//

function tokenBase(stream, state, prev) {
  if (stream.sol()) state.indented = stream.indentation()
  if (stream.eatSpace()) return null

  var ch = stream.peek()
  if (ch == "/") {
    if (stream.match("//")) {
      stream.skipToEnd()
      return "comment"
    }
    if (stream.match("/*")) {
      state.tokenize.push(tokenComment)
      return tokenComment(stream, state)
    }
  }
  if (stream.match(instruction)) return "builtin"
  if (stream.match(attribute)) return "attribute"
  if (stream.match(binary)) return "number"
  if (stream.match(octal)) return "number"
  if (stream.match(hexadecimal)) return "number"
  if (stream.match(decimal)) return "number"
  if (stream.match(property)) return "property"
  if (operators.indexOf(ch) > -1) {
    stream.next()
    return "operator"
  }
  if (punc.indexOf(ch) > -1) {
    stream.next()
    stream.match("..")
    return "punctuation"
  }
  var stringMatch
  if (stringMatch = stream.match(/("""|"|')/)) {
    var tokenize = tokenString.bind(null, stringMatch[0])
    state.tokenize.push(tokenize)
    return tokenize(stream, state)
  }

  if (stream.match(identifier)) {
    var ident = stream.current()
    if (types.hasOwnProperty(ident)) return "type"
    if (atoms.hasOwnProperty(ident)) return "atom"
    if (keywords.hasOwnProperty(ident)) {
      if (definingKeywords.hasOwnProperty(ident))
        state.prev = "define"
      return "keyword"
    }
    if (prev == "define") return "def"
    return "variable"
  }

  stream.next()
  return null
}

function tokenUntilClosingParen() {
  var depth = 0
  return function(stream, state, prev) {
    var inner = tokenBase(stream, state, prev)
    if (inner == "punctuation") {
      if (stream.current() == "(") ++depth
      else if (stream.current() == ")") {
        if (depth == 0) {
          stream.backUp(1)
          state.tokenize.pop()
          return state.tokenize[state.tokenize.length - 1](stream, state)
        }
        else --depth
      }
    }
    return inner
  }
}

function tokenString(openQuote, stream, state) {
  var singleLine = openQuote.length == 1
  var ch, escaped = false
  while (ch = stream.peek()) {
    if (escaped) {
      stream.next()
      if (ch == "(") {
        state.tokenize.push(tokenUntilClosingParen())
        return "string"
      }
      escaped = false
    } else if (stream.match(openQuote)) {
      state.tokenize.pop()
      return "string"
    } else {
      stream.next()
      escaped = ch == "\\"
    }
  }
  if (singleLine) {
    state.tokenize.pop()
  }
  return "string"
}

function tokenComment(stream, state) {
  var ch
  while (true) {
    stream.match(/^[^/*]+/, true)
    ch = stream.next()
    if (!ch) break
    if (ch === "/" && stream.eat("*")) {
      state.tokenize.push(tokenComment)
    } else if (ch === "*" && stream.eat("/")) {
      state.tokenize.pop()
    }
  }
  return "comment"
}

function Context(prev, align, indented) {
  this.prev = prev
  this.align = align
  this.indented = indented
}

function pushContext(state, stream) {
  var align = stream.match(/^\s*($|\/[\/\*]|[)}\]])/, false) ? null : stream.column() + 1
  state.context = new Context(state.context, align, state.indented)
}

function popContext(state) {
  if (state.context) {
    state.indented = state.context.indented
    state.context = state.context.prev
  }
}

const swift = {
  startState: function() {
    return {
      prev: null,
      context: null,
      indented: 0,
      tokenize: []
    }
  },

  token: function(stream, state) {
    var prev = state.prev
    state.prev = null
    var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase
    var style = tokenize(stream, state, prev)
    if (!style || style == "comment") state.prev = prev
    else if (!state.prev) state.prev = style

    if (style == "punctuation") {
      var bracket = /[\(\[\{]|([\]\)\}])/.exec(stream.current())
      if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)
    }

    return style
  },

  indent: function(state, textAfter, iCx) {
    var cx = state.context
    if (!cx) return 0
    var closing = /^[\]\}\)]/.test(textAfter)
    if (cx.align != null) return cx.align - (closing ? 1 : 0)
    return cx.indented + (closing ? 0 : iCx.unit)
  },

  languageData: {
    indentOnInput: /^\s*[\)\}\]]$/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', "`"]}
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc3dpZnRfanMuYzY2ZDA4NmEzNWQwNjM2M2M1MzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw2QkFBNkI7QUFDN0Isb0JBQW9CLG9CQUFvQix5QkFBeUI7QUFDakUsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zd2lmdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkU2V0KHdvcmRzKSB7XG4gIHZhciBzZXQgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSBzZXRbd29yZHNbaV1dID0gdHJ1ZVxuICByZXR1cm4gc2V0XG59XG5cbnZhciBrZXl3b3JkcyA9IHdvcmRTZXQoW1wiX1wiLFwidmFyXCIsXCJsZXRcIixcImFjdG9yXCIsXCJjbGFzc1wiLFwiZW51bVwiLFwiZXh0ZW5zaW9uXCIsXCJpbXBvcnRcIixcInByb3RvY29sXCIsXCJzdHJ1Y3RcIixcImZ1bmNcIixcInR5cGVhbGlhc1wiLFwiYXNzb2NpYXRlZHR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3BlblwiLFwicHVibGljXCIsXCJpbnRlcm5hbFwiLFwiZmlsZXByaXZhdGVcIixcInByaXZhdGVcIixcImRlaW5pdFwiLFwiaW5pdFwiLFwibmV3XCIsXCJvdmVycmlkZVwiLFwic2VsZlwiLFwic3Vic2NyaXB0XCIsXCJzdXBlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb252ZW5pZW5jZVwiLFwiZHluYW1pY1wiLFwiZmluYWxcIixcImluZGlyZWN0XCIsXCJsYXp5XCIsXCJyZXF1aXJlZFwiLFwic3RhdGljXCIsXCJ1bm93bmVkXCIsXCJ1bm93bmVkKHNhZmUpXCIsXCJ1bm93bmVkKHVuc2FmZSlcIixcIndlYWtcIixcImFzXCIsXCJpc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJicmVha1wiLFwiY2FzZVwiLFwiY29udGludWVcIixcImRlZmF1bHRcIixcImVsc2VcIixcImZhbGx0aHJvdWdoXCIsXCJmb3JcIixcImd1YXJkXCIsXCJpZlwiLFwiaW5cIixcInJlcGVhdFwiLFwic3dpdGNoXCIsXCJ3aGVyZVwiLFwid2hpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmZXJcIixcInJldHVyblwiLFwiaW5vdXRcIixcIm11dGF0aW5nXCIsXCJub25tdXRhdGluZ1wiLFwiaXNvbGF0ZWRcIixcIm5vbmlzb2xhdGVkXCIsXCJjYXRjaFwiLFwiZG9cIixcInJldGhyb3dzXCIsXCJ0aHJvd1wiLFwidGhyb3dzXCIsXCJhc3luY1wiLFwiYXdhaXRcIixcInRyeVwiLFwiZGlkU2V0XCIsXCJnZXRcIixcInNldFwiLFwid2lsbFNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhc3NpZ25tZW50XCIsXCJhc3NvY2lhdGl2aXR5XCIsXCJpbmZpeFwiLFwibGVmdFwiLFwibm9uZVwiLFwib3BlcmF0b3JcIixcInBvc3RmaXhcIixcInByZWNlZGVuY2VcIixcInByZWNlZGVuY2Vncm91cFwiLFwicHJlZml4XCIsXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBbnlcIixcIkFueU9iamVjdFwiLFwiVHlwZVwiLFwiZHluYW1pY1R5cGVcIixcIlNlbGZcIixcIlByb3RvY29sXCIsXCJfX0NPTFVNTl9fXCIsXCJfX0ZJTEVfX1wiLFwiX19GVU5DVElPTl9fXCIsXCJfX0xJTkVfX1wiXSlcbnZhciBkZWZpbmluZ0tleXdvcmRzID0gd29yZFNldChbXCJ2YXJcIixcImxldFwiLFwiYWN0b3JcIixcImNsYXNzXCIsXCJlbnVtXCIsXCJleHRlbnNpb25cIixcImltcG9ydFwiLFwicHJvdG9jb2xcIixcInN0cnVjdFwiLFwiZnVuY1wiLFwidHlwZWFsaWFzXCIsXCJhc3NvY2lhdGVkdHlwZVwiLFwiZm9yXCJdKVxudmFyIGF0b21zID0gd29yZFNldChbXCJ0cnVlXCIsXCJmYWxzZVwiLFwibmlsXCIsXCJzZWxmXCIsXCJzdXBlclwiLFwiX1wiXSlcbnZhciB0eXBlcyA9IHdvcmRTZXQoW1wiQXJyYXlcIixcIkJvb2xcIixcIkNoYXJhY3RlclwiLFwiRGljdGlvbmFyeVwiLFwiRG91YmxlXCIsXCJGbG9hdFwiLFwiSW50XCIsXCJJbnQ4XCIsXCJJbnQxNlwiLFwiSW50MzJcIixcIkludDY0XCIsXCJOZXZlclwiLFwiT3B0aW9uYWxcIixcIlNldFwiLFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICBcIlVJbnQ4XCIsXCJVSW50MTZcIixcIlVJbnQzMlwiLFwiVUludDY0XCIsXCJWb2lkXCJdKVxudmFyIG9wZXJhdG9ycyA9IFwiKy0vKiU9fCY8Pn5ePyFcIlxudmFyIHB1bmMgPSBcIjo7LC4oKXt9W11cIlxudmFyIGJpbmFyeSA9IC9eXFwtPzBiWzAxXVswMV9dKi9cbnZhciBvY3RhbCA9IC9eXFwtPzBvWzAtN11bMC03X10qL1xudmFyIGhleGFkZWNpbWFsID0gL15cXC0/MHhbXFxkQS1GYS1mXVtcXGRBLUZhLWZfXSooPzooPzpcXC5bXFxkQS1GYS1mXVtcXGRBLUZhLWZfXSopP1tQcF1cXC0/XFxkW1xcZF9dKik/L1xudmFyIGRlY2ltYWwgPSAvXlxcLT9cXGRbXFxkX10qKD86XFwuXFxkW1xcZF9dKik/KD86W0VlXVxcLT9cXGRbXFxkX10qKT8vXG52YXIgaWRlbnRpZmllciA9IC9eXFwkXFxkK3woYD8pW19BLVphLXpdW19BLVphLXokMC05XSpcXDEvXG52YXIgcHJvcGVydHkgPSAvXlxcLig/OlxcJFxcZCt8KGA/KVtfQS1aYS16XVtfQS1aYS16JDAtOV0qXFwxKS9cbnZhciBpbnN0cnVjdGlvbiA9IC9eXFwjW0EtWmEtel0rL1xudmFyIGF0dHJpYnV0ZSA9IC9eQCg/OlxcJFxcZCt8KGA/KVtfQS1aYS16XVtfQS1aYS16JDAtOV0qXFwxKS9cbi8vdmFyIHJlZ2V4cCA9IC9eXFwvKD8hXFxzKSg/OlxcL1xcLyk/KD86XFxcXC58W15cXC9dKStcXC8vXG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlLCBwcmV2KSB7XG4gIGlmIChzdHJlYW0uc29sKCkpIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKClcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbFxuXG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKClcbiAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChcIi8vXCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKClcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiLypcIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5Db21tZW50KVxuICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKVxuICAgIH1cbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKGluc3RydWN0aW9uKSkgcmV0dXJuIFwiYnVpbHRpblwiXG4gIGlmIChzdHJlYW0ubWF0Y2goYXR0cmlidXRlKSkgcmV0dXJuIFwiYXR0cmlidXRlXCJcbiAgaWYgKHN0cmVhbS5tYXRjaChiaW5hcnkpKSByZXR1cm4gXCJudW1iZXJcIlxuICBpZiAoc3RyZWFtLm1hdGNoKG9jdGFsKSkgcmV0dXJuIFwibnVtYmVyXCJcbiAgaWYgKHN0cmVhbS5tYXRjaChoZXhhZGVjaW1hbCkpIHJldHVybiBcIm51bWJlclwiXG4gIGlmIChzdHJlYW0ubWF0Y2goZGVjaW1hbCkpIHJldHVybiBcIm51bWJlclwiXG4gIGlmIChzdHJlYW0ubWF0Y2gocHJvcGVydHkpKSByZXR1cm4gXCJwcm9wZXJ0eVwiXG4gIGlmIChvcGVyYXRvcnMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgIHN0cmVhbS5uZXh0KClcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gIH1cbiAgaWYgKHB1bmMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgIHN0cmVhbS5uZXh0KClcbiAgICBzdHJlYW0ubWF0Y2goXCIuLlwiKVxuICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCJcbiAgfVxuICB2YXIgc3RyaW5nTWF0Y2hcbiAgaWYgKHN0cmluZ01hdGNoID0gc3RyZWFtLm1hdGNoKC8oXCJcIlwifFwifCcpLykpIHtcbiAgICB2YXIgdG9rZW5pemUgPSB0b2tlblN0cmluZy5iaW5kKG51bGwsIHN0cmluZ01hdGNoWzBdKVxuICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5pemUpXG4gICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXIpKSB7XG4gICAgdmFyIGlkZW50ID0gc3RyZWFtLmN1cnJlbnQoKVxuICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShpZGVudCkpIHJldHVybiBcInR5cGVcIlxuICAgIGlmIChhdG9tcy5oYXNPd25Qcm9wZXJ0eShpZGVudCkpIHJldHVybiBcImF0b21cIlxuICAgIGlmIChrZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShpZGVudCkpIHtcbiAgICAgIGlmIChkZWZpbmluZ0tleXdvcmRzLmhhc093blByb3BlcnR5KGlkZW50KSlcbiAgICAgICAgc3RhdGUucHJldiA9IFwiZGVmaW5lXCJcbiAgICAgIHJldHVybiBcImtleXdvcmRcIlxuICAgIH1cbiAgICBpZiAocHJldiA9PSBcImRlZmluZVwiKSByZXR1cm4gXCJkZWZcIlxuICAgIHJldHVybiBcInZhcmlhYmxlXCJcbiAgfVxuXG4gIHN0cmVhbS5uZXh0KClcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gdG9rZW5VbnRpbENsb3NpbmdQYXJlbigpIHtcbiAgdmFyIGRlcHRoID0gMFxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSwgcHJldikge1xuICAgIHZhciBpbm5lciA9IHRva2VuQmFzZShzdHJlYW0sIHN0YXRlLCBwcmV2KVxuICAgIGlmIChpbm5lciA9PSBcInB1bmN0dWF0aW9uXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwiKFwiKSArK2RlcHRoXG4gICAgICBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwiKVwiKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKVxuICAgICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aCAtIDFdKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAtLWRlcHRoXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbm5lclxuICB9XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKG9wZW5RdW90ZSwgc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgc2luZ2xlTGluZSA9IG9wZW5RdW90ZS5sZW5ndGggPT0gMVxuICB2YXIgY2gsIGVzY2FwZWQgPSBmYWxzZVxuICB3aGlsZSAoY2ggPSBzdHJlYW0ucGVlaygpKSB7XG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIGlmIChjaCA9PSBcIihcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuVW50aWxDbG9zaW5nUGFyZW4oKSlcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKG9wZW5RdW90ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpXG4gICAgICByZXR1cm4gXCJzdHJpbmdcIlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBlc2NhcGVkID0gY2ggPT0gXCJcXFxcXCJcbiAgICB9XG4gIH1cbiAgaWYgKHNpbmdsZUxpbmUpIHtcbiAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKVxuICB9XG4gIHJldHVybiBcInN0cmluZ1wiXG59XG5cbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaFxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlteLypdKy8sIHRydWUpXG4gICAgY2ggPSBzdHJlYW0ubmV4dCgpXG4gICAgaWYgKCFjaCkgYnJlYWtcbiAgICBpZiAoY2ggPT09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuQ29tbWVudClcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIipcIiAmJiBzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUucG9wKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiXG59XG5cbmZ1bmN0aW9uIENvbnRleHQocHJldiwgYWxpZ24sIGluZGVudGVkKSB7XG4gIHRoaXMucHJldiA9IHByZXZcbiAgdGhpcy5hbGlnbiA9IGFsaWduXG4gIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBhbGlnbiA9IHN0cmVhbS5tYXRjaCgvXlxccyooJHxcXC9bXFwvXFwqXXxbKX1cXF1dKS8sIGZhbHNlKSA/IG51bGwgOiBzdHJlYW0uY29sdW1uKCkgKyAxXG4gIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZS5jb250ZXh0LCBhbGlnbiwgc3RhdGUuaW5kZW50ZWQpXG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmNvbnRleHQpIHtcbiAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWRcbiAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHN3aWZ0ID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJldjogbnVsbCxcbiAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICBpbmRlbnRlZDogMCxcbiAgICAgIHRva2VuaXplOiBbXVxuICAgIH1cbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBwcmV2ID0gc3RhdGUucHJldlxuICAgIHN0YXRlLnByZXYgPSBudWxsXG4gICAgdmFyIHRva2VuaXplID0gc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoIC0gMV0gfHwgdG9rZW5CYXNlXG4gICAgdmFyIHN0eWxlID0gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSwgcHJldilcbiAgICBpZiAoIXN0eWxlIHx8IHN0eWxlID09IFwiY29tbWVudFwiKSBzdGF0ZS5wcmV2ID0gcHJldlxuICAgIGVsc2UgaWYgKCFzdGF0ZS5wcmV2KSBzdGF0ZS5wcmV2ID0gc3R5bGVcblxuICAgIGlmIChzdHlsZSA9PSBcInB1bmN0dWF0aW9uXCIpIHtcbiAgICAgIHZhciBicmFja2V0ID0gL1tcXChcXFtcXHtdfChbXFxdXFwpXFx9XSkvLmV4ZWMoc3RyZWFtLmN1cnJlbnQoKSlcbiAgICAgIGlmIChicmFja2V0KSAoYnJhY2tldFsxXSA/IHBvcENvbnRleHQgOiBwdXNoQ29udGV4dCkoc3RhdGUsIHN0cmVhbSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGlDeCkge1xuICAgIHZhciBjeCA9IHN0YXRlLmNvbnRleHRcbiAgICBpZiAoIWN4KSByZXR1cm4gMFxuICAgIHZhciBjbG9zaW5nID0gL15bXFxdXFx9XFwpXS8udGVzdCh0ZXh0QWZ0ZXIpXG4gICAgaWYgKGN4LmFsaWduICE9IG51bGwpIHJldHVybiBjeC5hbGlnbiAtIChjbG9zaW5nID8gMSA6IDApXG4gICAgcmV0dXJuIGN4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaUN4LnVuaXQpXG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW1xcKVxcfVxcXV0kLyxcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIvL1wiLCBibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19LFxuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCBcImBcIl19XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==