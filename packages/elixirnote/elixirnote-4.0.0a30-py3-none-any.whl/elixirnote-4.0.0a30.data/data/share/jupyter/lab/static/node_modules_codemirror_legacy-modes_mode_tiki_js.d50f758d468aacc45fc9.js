"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_tiki_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/tiki.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/tiki.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tiki": () => (/* binding */ tiki)
/* harmony export */ });
function inBlock(style, terminator, returnTokenizer) {
  return function(stream, state) {
    while (!stream.eol()) {
      if (stream.match(terminator)) {
        state.tokenize = inText;
        break;
      }
      stream.next();
    }

    if (returnTokenizer) state.tokenize = returnTokenizer;

    return style;
  };
}

function inLine(style) {
  return function(stream, state) {
    while(!stream.eol()) {
      stream.next();
    }
    state.tokenize = inText;
    return style;
  };
}

function inText(stream, state) {
  function chain(parser) {
    state.tokenize = parser;
    return parser(stream, state);
  }

  var sol = stream.sol();
  var ch = stream.next();

  //non start of line
  switch (ch) { //switch is generally much faster than if, so it is used here
  case "{": //plugin
    stream.eat("/");
    stream.eatSpace();
    stream.eatWhile(/[^\s\u00a0=\"\'\/?(}]/);
    state.tokenize = inPlugin;
    return "tag";
  case "_": //bold
    if (stream.eat("_"))
      return chain(inBlock("strong", "__", inText));
    break;
  case "'": //italics
    if (stream.eat("'"))
      return chain(inBlock("em", "''", inText));
    break;
  case "(":// Wiki Link
    if (stream.eat("("))
      return chain(inBlock("link", "))", inText));
    break;
  case "[":// Weblink
    return chain(inBlock("url", "]", inText));
    break;
  case "|": //table
    if (stream.eat("|"))
      return chain(inBlock("comment", "||"));
    break;
  case "-":
    if (stream.eat("=")) {//titleBar
      return chain(inBlock("header string", "=-", inText));
    } else if (stream.eat("-")) {//deleted
      return chain(inBlock("error tw-deleted", "--", inText));
    }
    break;
  case "=": //underline
    if (stream.match("=="))
      return chain(inBlock("tw-underline", "===", inText));
    break;
  case ":":
    if (stream.eat(":"))
      return chain(inBlock("comment", "::"));
    break;
  case "^": //box
    return chain(inBlock("tw-box", "^"));
    break;
  case "~": //np
    if (stream.match("np~"))
      return chain(inBlock("meta", "~/np~"));
    break;
  }

  //start of line types
  if (sol) {
    switch (ch) {
    case "!": //header at start of line
      if (stream.match('!!!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!')) {
        return chain(inLine("header string"));
      } else {
        return chain(inLine("header string"));
      }
      break;
    case "*": //unordered list line item, or <li /> at start of line
    case "#": //ordered list line item, or <li /> at start of line
    case "+": //ordered list line item, or <li /> at start of line
      return chain(inLine("tw-listitem bracket"));
      break;
    }
  }

  //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki
  return null;
}

// Return variables for tokenizers
var pluginName, type;
function inPlugin(stream, state) {
  var ch = stream.next();
  var peek = stream.peek();

  if (ch == "}") {
    state.tokenize = inText;
    //type = ch == ")" ? "endPlugin" : "selfclosePlugin"; inPlugin
    return "tag";
  } else if (ch == "(" || ch == ")") {
    return "bracket";
  } else if (ch == "=") {
    type = "equals";

    if (peek == ">") {
      stream.next();
      peek = stream.peek();
    }

    //here we detect values directly after equal character with no quotes
    if (!/[\'\"]/.test(peek)) {
      state.tokenize = inAttributeNoQuote();
    }
    //end detect values

    return "operator";
  } else if (/[\'\"]/.test(ch)) {
    state.tokenize = inAttribute(ch);
    return state.tokenize(stream, state);
  } else {
    stream.eatWhile(/[^\s\u00a0=\"\'\/?]/);
    return "keyword";
  }
}

function inAttribute(quote) {
  return function(stream, state) {
    while (!stream.eol()) {
      if (stream.next() == quote) {
        state.tokenize = inPlugin;
        break;
      }
    }
    return "string";
  };
}

function inAttributeNoQuote() {
  return function(stream, state) {
    while (!stream.eol()) {
      var ch = stream.next();
      var peek = stream.peek();
      if (ch == " " || ch == "," || /[ )}]/.test(peek)) {
        state.tokenize = inPlugin;
        break;
      }
    }
    return "string";
  };
}

var curState, setStyle;
function pass() {
  for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
}

function cont() {
  pass.apply(null, arguments);
  return true;
}

function pushContext(pluginName, startOfLine) {
  var noIndent = curState.context && curState.context.noIndent;
  curState.context = {
    prev: curState.context,
    pluginName: pluginName,
    indent: curState.indented,
    startOfLine: startOfLine,
    noIndent: noIndent
  };
}

function popContext() {
  if (curState.context) curState.context = curState.context.prev;
}

function element(type) {
  if (type == "openPlugin") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}
  else if (type == "closePlugin") {
    var err = false;
    if (curState.context) {
      err = curState.context.pluginName != pluginName;
      popContext();
    } else {
      err = true;
    }
    if (err) setStyle = "error";
    return cont(endcloseplugin(err));
  }
  else if (type == "string") {
    if (!curState.context || curState.context.name != "!cdata") pushContext("!cdata");
    if (curState.tokenize == inText) popContext();
    return cont();
  }
  else return cont();
}

function endplugin(startOfLine) {
  return function(type) {
    if (
      type == "selfclosePlugin" ||
        type == "endPlugin"
    )
      return cont();
    if (type == "endPlugin") {pushContext(curState.pluginName, startOfLine); return cont();}
    return cont();
  };
}

function endcloseplugin(err) {
  return function(type) {
    if (err) setStyle = "error";
    if (type == "endPlugin") return cont();
    return pass();
  };
}

function attributes(type) {
  if (type == "keyword") {setStyle = "attribute"; return cont(attributes);}
  if (type == "equals") return cont(attvalue, attributes);
  return pass();
}
function attvalue(type) {
  if (type == "keyword") {setStyle = "string"; return cont();}
  if (type == "string") return cont(attvaluemaybe);
  return pass();
}
function attvaluemaybe(type) {
  if (type == "string") return cont(attvaluemaybe);
  else return pass();
}
const tiki = {
  startState: function() {
    return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};
  },
  token: function(stream, state) {
    if (stream.sol()) {
      state.startOfLine = true;
      state.indented = stream.indentation();
    }
    if (stream.eatSpace()) return null;

    setStyle = type = pluginName = null;
    var style = state.tokenize(stream, state);
    if ((style || type) && style != "comment") {
      curState = state;
      while (true) {
        var comb = state.cc.pop() || element;
        if (comb(type || style)) break;
      }
    }
    state.startOfLine = false;
    return setStyle || style;
  },
  indent: function(state, textAfter, cx) {
    var context = state.context;
    if (context && context.noIndent) return 0;
    if (context && /^{\//.test(textAfter))
      context = context.prev;
    while (context && !context.startOfLine)
      context = context.prev;
    if (context) return context.indent + cx.unit;
    else return 0;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfdGlraV9qcy5kNTBmNzU4ZDQ2OGFhY2M0NWZjOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3Rpa2kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW5CbG9jayhzdHlsZSwgdGVybWluYXRvciwgcmV0dXJuVG9rZW5pemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuVG9rZW5pemVyKSBzdGF0ZS50b2tlbml6ZSA9IHJldHVyblRva2VuaXplcjtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5MaW5lKHN0eWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgd2hpbGUoIXN0cmVhbS5lb2woKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xuICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcbiAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKTtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAvL25vbiBzdGFydCBvZiBsaW5lXG4gIHN3aXRjaCAoY2gpIHsgLy9zd2l0Y2ggaXMgZ2VuZXJhbGx5IG11Y2ggZmFzdGVyIHRoYW4gaWYsIHNvIGl0IGlzIHVzZWQgaGVyZVxuICBjYXNlIFwie1wiOiAvL3BsdWdpblxuICAgIHN0cmVhbS5lYXQoXCIvXCIpO1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXHUwMGEwPVxcXCJcXCdcXC8/KH1dLyk7XG4gICAgc3RhdGUudG9rZW5pemUgPSBpblBsdWdpbjtcbiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgY2FzZSBcIl9cIjogLy9ib2xkXG4gICAgaWYgKHN0cmVhbS5lYXQoXCJfXCIpKVxuICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJzdHJvbmdcIiwgXCJfX1wiLCBpblRleHQpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIidcIjogLy9pdGFsaWNzXG4gICAgaWYgKHN0cmVhbS5lYXQoXCInXCIpKVxuICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJlbVwiLCBcIicnXCIsIGluVGV4dCkpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiKFwiOi8vIFdpa2kgTGlua1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwibGlua1wiLCBcIikpXCIsIGluVGV4dCkpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiW1wiOi8vIFdlYmxpbmtcbiAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcInVybFwiLCBcIl1cIiwgaW5UZXh0KSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJ8XCI6IC8vdGFibGVcbiAgICBpZiAoc3RyZWFtLmVhdChcInxcIikpXG4gICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImNvbW1lbnRcIiwgXCJ8fFwiKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCItXCI6XG4gICAgaWYgKHN0cmVhbS5lYXQoXCI9XCIpKSB7Ly90aXRsZUJhclxuICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJoZWFkZXIgc3RyaW5nXCIsIFwiPS1cIiwgaW5UZXh0KSk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiLVwiKSkgey8vZGVsZXRlZFxuICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJlcnJvciB0dy1kZWxldGVkXCIsIFwiLS1cIiwgaW5UZXh0KSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIFwiPVwiOiAvL3VuZGVybGluZVxuICAgIGlmIChzdHJlYW0ubWF0Y2goXCI9PVwiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwidHctdW5kZXJsaW5lXCIsIFwiPT09XCIsIGluVGV4dCkpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiOlwiOlxuICAgIGlmIChzdHJlYW0uZWF0KFwiOlwiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiY29tbWVudFwiLCBcIjo6XCIpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIl5cIjogLy9ib3hcbiAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcInR3LWJveFwiLCBcIl5cIikpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiflwiOiAvL25wXG4gICAgaWYgKHN0cmVhbS5tYXRjaChcIm5wflwiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwibWV0YVwiLCBcIn4vbnB+XCIpKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vc3RhcnQgb2YgbGluZSB0eXBlc1xuICBpZiAoc29sKSB7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgXCIhXCI6IC8vaGVhZGVyIGF0IHN0YXJ0IG9mIGxpbmVcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJyEhISEhJykpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJyEhISEnKSkge1xuICAgICAgICByZXR1cm4gY2hhaW4oaW5MaW5lKFwiaGVhZGVyIHN0cmluZ1wiKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgnISEhJykpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJyEhJykpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIipcIjogLy91bm9yZGVyZWQgbGlzdCBsaW5lIGl0ZW0sIG9yIDxsaSAvPiBhdCBzdGFydCBvZiBsaW5lXG4gICAgY2FzZSBcIiNcIjogLy9vcmRlcmVkIGxpc3QgbGluZSBpdGVtLCBvciA8bGkgLz4gYXQgc3RhcnQgb2YgbGluZVxuICAgIGNhc2UgXCIrXCI6IC8vb3JkZXJlZCBsaXN0IGxpbmUgaXRlbSwgb3IgPGxpIC8+IGF0IHN0YXJ0IG9mIGxpbmVcbiAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJ0dy1saXN0aXRlbSBicmFja2V0XCIpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vc3RyZWFtLmVhdFdoaWxlKC9bJntdLyk7IHdhcyBlYXRpbmcgdXAgcGx1Z2lucywgdHVybmVkIG9mZiB0byBhY3QgbGVzcyBsaWtlIGh0bWwgYW5kIG1vcmUgbGlrZSB0aWtpXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXG52YXIgcGx1Z2luTmFtZSwgdHlwZTtcbmZ1bmN0aW9uIGluUGx1Z2luKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgdmFyIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuXG4gIGlmIChjaCA9PSBcIn1cIikge1xuICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgIC8vdHlwZSA9IGNoID09IFwiKVwiID8gXCJlbmRQbHVnaW5cIiA6IFwic2VsZmNsb3NlUGx1Z2luXCI7IGluUGx1Z2luXG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIoXCIgfHwgY2ggPT0gXCIpXCIpIHtcbiAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICB0eXBlID0gXCJlcXVhbHNcIjtcblxuICAgIGlmIChwZWVrID09IFwiPlwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcGVlayA9IHN0cmVhbS5wZWVrKCk7XG4gICAgfVxuXG4gICAgLy9oZXJlIHdlIGRldGVjdCB2YWx1ZXMgZGlyZWN0bHkgYWZ0ZXIgZXF1YWwgY2hhcmFjdGVyIHdpdGggbm8gcXVvdGVzXG4gICAgaWYgKCEvW1xcJ1xcXCJdLy50ZXN0KHBlZWspKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQXR0cmlidXRlTm9RdW90ZSgpO1xuICAgIH1cbiAgICAvL2VuZCBkZXRlY3QgdmFsdWVzXG5cbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9IGVsc2UgaWYgKC9bXFwnXFxcIl0vLnRlc3QoY2gpKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZShjaCk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXHUwMGEwPVxcXCJcXCdcXC8/XS8pO1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBxdW90ZSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluUGx1Z2luO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluQXR0cmlidXRlTm9RdW90ZSgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSBcIiBcIiB8fCBjaCA9PSBcIixcIiB8fCAvWyApfV0vLnRlc3QocGVlaykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblBsdWdpbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG52YXIgY3VyU3RhdGUsIHNldFN0eWxlO1xuZnVuY3Rpb24gcGFzcygpIHtcbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY3VyU3RhdGUuY2MucHVzaChhcmd1bWVudHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjb250KCkge1xuICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChwbHVnaW5OYW1lLCBzdGFydE9mTGluZSkge1xuICB2YXIgbm9JbmRlbnQgPSBjdXJTdGF0ZS5jb250ZXh0ICYmIGN1clN0YXRlLmNvbnRleHQubm9JbmRlbnQ7XG4gIGN1clN0YXRlLmNvbnRleHQgPSB7XG4gICAgcHJldjogY3VyU3RhdGUuY29udGV4dCxcbiAgICBwbHVnaW5OYW1lOiBwbHVnaW5OYW1lLFxuICAgIGluZGVudDogY3VyU3RhdGUuaW5kZW50ZWQsXG4gICAgc3RhcnRPZkxpbmU6IHN0YXJ0T2ZMaW5lLFxuICAgIG5vSW5kZW50OiBub0luZGVudFxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KCkge1xuICBpZiAoY3VyU3RhdGUuY29udGV4dCkgY3VyU3RhdGUuY29udGV4dCA9IGN1clN0YXRlLmNvbnRleHQucHJldjtcbn1cblxuZnVuY3Rpb24gZWxlbWVudCh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwib3BlblBsdWdpblwiKSB7Y3VyU3RhdGUucGx1Z2luTmFtZSA9IHBsdWdpbk5hbWU7IHJldHVybiBjb250KGF0dHJpYnV0ZXMsIGVuZHBsdWdpbihjdXJTdGF0ZS5zdGFydE9mTGluZSkpO31cbiAgZWxzZSBpZiAodHlwZSA9PSBcImNsb3NlUGx1Z2luXCIpIHtcbiAgICB2YXIgZXJyID0gZmFsc2U7XG4gICAgaWYgKGN1clN0YXRlLmNvbnRleHQpIHtcbiAgICAgIGVyciA9IGN1clN0YXRlLmNvbnRleHQucGx1Z2luTmFtZSAhPSBwbHVnaW5OYW1lO1xuICAgICAgcG9wQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXJyKSBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gY29udChlbmRjbG9zZXBsdWdpbihlcnIpKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIWN1clN0YXRlLmNvbnRleHQgfHwgY3VyU3RhdGUuY29udGV4dC5uYW1lICE9IFwiIWNkYXRhXCIpIHB1c2hDb250ZXh0KFwiIWNkYXRhXCIpO1xuICAgIGlmIChjdXJTdGF0ZS50b2tlbml6ZSA9PSBpblRleHQpIHBvcENvbnRleHQoKTtcbiAgICByZXR1cm4gY29udCgpO1xuICB9XG4gIGVsc2UgcmV0dXJuIGNvbnQoKTtcbn1cblxuZnVuY3Rpb24gZW5kcGx1Z2luKHN0YXJ0T2ZMaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZSA9PSBcInNlbGZjbG9zZVBsdWdpblwiIHx8XG4gICAgICAgIHR5cGUgPT0gXCJlbmRQbHVnaW5cIlxuICAgIClcbiAgICAgIHJldHVybiBjb250KCk7XG4gICAgaWYgKHR5cGUgPT0gXCJlbmRQbHVnaW5cIikge3B1c2hDb250ZXh0KGN1clN0YXRlLnBsdWdpbk5hbWUsIHN0YXJ0T2ZMaW5lKTsgcmV0dXJuIGNvbnQoKTt9XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5kY2xvc2VwbHVnaW4oZXJyKSB7XG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKGVycikgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgaWYgKHR5cGUgPT0gXCJlbmRQbHVnaW5cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcygpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyaWJ1dGVzKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkXCIpIHtzZXRTdHlsZSA9IFwiYXR0cmlidXRlXCI7IHJldHVybiBjb250KGF0dHJpYnV0ZXMpO31cbiAgaWYgKHR5cGUgPT0gXCJlcXVhbHNcIikgcmV0dXJuIGNvbnQoYXR0dmFsdWUsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4gcGFzcygpO1xufVxuZnVuY3Rpb24gYXR0dmFsdWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBcImtleXdvcmRcIikge3NldFN0eWxlID0gXCJzdHJpbmdcIjsgcmV0dXJuIGNvbnQoKTt9XG4gIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBjb250KGF0dHZhbHVlbWF5YmUpO1xuICByZXR1cm4gcGFzcygpO1xufVxuZnVuY3Rpb24gYXR0dmFsdWVtYXliZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBjb250KGF0dHZhbHVlbWF5YmUpO1xuICBlbHNlIHJldHVybiBwYXNzKCk7XG59XG5leHBvcnQgY29uc3QgdGlraSA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogaW5UZXh0LCBjYzogW10sIGluZGVudGVkOiAwLCBzdGFydE9mTGluZTogdHJ1ZSwgcGx1Z2luTmFtZTogbnVsbCwgY29udGV4dDogbnVsbH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgIHNldFN0eWxlID0gdHlwZSA9IHBsdWdpbk5hbWUgPSBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXCJjb21tZW50XCIpIHtcbiAgICAgIGN1clN0YXRlID0gc3RhdGU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY29tYiA9IHN0YXRlLmNjLnBvcCgpIHx8IGVsZW1lbnQ7XG4gICAgICAgIGlmIChjb21iKHR5cGUgfHwgc3R5bGUpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gc2V0U3R5bGUgfHwgc3R5bGU7XG4gIH0sXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgICB2YXIgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIDA7XG4gICAgaWYgKGNvbnRleHQgJiYgL157XFwvLy50ZXN0KHRleHRBZnRlcikpXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgIHdoaWxlIChjb250ZXh0ICYmICFjb250ZXh0LnN0YXJ0T2ZMaW5lKVxuICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQuaW5kZW50ICsgY3gudW5pdDtcbiAgICBlbHNlIHJldHVybiAwO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9