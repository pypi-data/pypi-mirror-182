"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_erlang_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/erlang.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/erlang.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "erlang": () => (/* binding */ erlang)
/* harmony export */ });
/////////////////////////////////////////////////////////////////////////////
// constants

var typeWords = [
  "-type", "-spec", "-export_type", "-opaque"];

var keywordWords = [
  "after","begin","catch","case","cond","end","fun","if",
  "let","of","query","receive","try","when"];

var separatorRE    = /[\->,;]/;
var separatorWords = [
  "->",";",","];

var operatorAtomWords = [
  "and","andalso","band","bnot","bor","bsl","bsr","bxor",
  "div","not","or","orelse","rem","xor"];

var operatorSymbolRE    = /[\+\-\*\/<>=\|:!]/;
var operatorSymbolWords = [
  "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];

var openParenRE    = /[<\(\[\{]/;
var openParenWords = [
  "<<","(","[","{"];

var closeParenRE    = /[>\)\]\}]/;
var closeParenWords = [
  "}","]",")",">>"];

var guardWords = [
  "is_atom","is_binary","is_bitstring","is_boolean","is_float",
  "is_function","is_integer","is_list","is_number","is_pid",
  "is_port","is_record","is_reference","is_tuple",
  "atom","binary","bitstring","boolean","function","integer","list",
  "number","pid","port","record","reference","tuple"];

var bifWords = [
  "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
  "atom_to_list","binary_to_atom","binary_to_existing_atom",
  "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
  "byte_size","check_process_code","contact_binary","crc32",
  "crc32_combine","date","decode_packet","delete_module",
  "disconnect_node","element","erase","exit","float","float_to_list",
  "garbage_collect","get","get_keys","group_leader","halt","hd",
  "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
  "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
  "is_float","is_function","is_integer","is_list","is_number","is_pid",
  "is_port","is_process_alive","is_record","is_reference","is_tuple",
  "length","link","list_to_atom","list_to_binary","list_to_bitstring",
  "list_to_existing_atom","list_to_float","list_to_integer",
  "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
  "monitor_node","node","node_link","node_unlink","nodes","notalive",
  "now","open_port","pid_to_list","port_close","port_command",
  "port_connect","port_control","pre_loaded","process_flag",
  "process_info","processes","purge_module","put","register",
  "registered","round","self","setelement","size","spawn","spawn_link",
  "spawn_monitor","spawn_opt","split_binary","statistics",
  "term_to_binary","time","throw","tl","trunc","tuple_size",
  "tuple_to_list","unlink","unregister","whereis"];

// upper case: [A-Z] [Ø-Þ] [À-Ö]
// lower case: [a-z] [ß-ö] [ø-ÿ]
var anumRE       = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/;
var escapesRE    =
    /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

/////////////////////////////////////////////////////////////////////////////
// tokenizer

function tokenizer(stream,state) {
  // in multi-line string
  if (state.in_string) {
    state.in_string = (!doubleQuote(stream));
    return rval(state,stream,"string");
  }

  // in multi-line atom
  if (state.in_atom) {
    state.in_atom = (!singleQuote(stream));
    return rval(state,stream,"atom");
  }

  // whitespace
  if (stream.eatSpace()) {
    return rval(state,stream,"whitespace");
  }

  // attributes and type specs
  if (!peekToken(state) &&
      stream.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) {
    if (is_member(stream.current(),typeWords)) {
      return rval(state,stream,"type");
    }else{
      return rval(state,stream,"attribute");
    }
  }

  var ch = stream.next();

  // comment
  if (ch == '%') {
    stream.skipToEnd();
    return rval(state,stream,"comment");
  }

  // colon
  if (ch == ":") {
    return rval(state,stream,"colon");
  }

  // macro
  if (ch == '?') {
    stream.eatSpace();
    stream.eatWhile(anumRE);
    return rval(state,stream,"macro");
  }

  // record
  if (ch == "#") {
    stream.eatSpace();
    stream.eatWhile(anumRE);
    return rval(state,stream,"record");
  }

  // dollar escape
  if (ch == "$") {
    if (stream.next() == "\\" && !stream.match(escapesRE)) {
      return rval(state,stream,"error");
    }
    return rval(state,stream,"number");
  }

  // dot
  if (ch == ".") {
    return rval(state,stream,"dot");
  }

  // quoted atom
  if (ch == '\'') {
    if (!(state.in_atom = (!singleQuote(stream)))) {
      if (stream.match(/\s*\/\s*[0-9]/,false)) {
        stream.match(/\s*\/\s*[0-9]/,true);
        return rval(state,stream,"fun");      // 'f'/0 style fun
      }
      if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
        return rval(state,stream,"function");
      }
    }
    return rval(state,stream,"atom");
  }

  // string
  if (ch == '"') {
    state.in_string = (!doubleQuote(stream));
    return rval(state,stream,"string");
  }

  // variable
  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {
    stream.eatWhile(anumRE);
    return rval(state,stream,"variable");
  }

  // atom/keyword/BIF/function
  if (/[a-z_ß-öø-ÿ]/.test(ch)) {
    stream.eatWhile(anumRE);

    if (stream.match(/\s*\/\s*[0-9]/,false)) {
      stream.match(/\s*\/\s*[0-9]/,true);
      return rval(state,stream,"fun");      // f/0 style fun
    }

    var w = stream.current();

    if (is_member(w,keywordWords)) {
      return rval(state,stream,"keyword");
    }else if (is_member(w,operatorAtomWords)) {
      return rval(state,stream,"operator");
    }else if (stream.match(/\s*\(/,false)) {
      // 'put' and 'erlang:put' are bifs, 'foo:put' is not
      if (is_member(w,bifWords) &&
          ((peekToken(state).token != ":") ||
           (peekToken(state,2).token == "erlang"))) {
        return rval(state,stream,"builtin");
      }else if (is_member(w,guardWords)) {
        return rval(state,stream,"guard");
      }else{
        return rval(state,stream,"function");
      }
    }else if (lookahead(stream) == ":") {
      if (w == "erlang") {
        return rval(state,stream,"builtin");
      } else {
        return rval(state,stream,"function");
      }
    }else if (is_member(w,["true","false"])) {
      return rval(state,stream,"boolean");
    }else{
      return rval(state,stream,"atom");
    }
  }

  // number
  var digitRE      = /[0-9]/;
  var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
  if (digitRE.test(ch)) {
    stream.eatWhile(digitRE);
    if (stream.eat('#')) {                // 36#aZ  style integer
      if (!stream.eatWhile(radixRE)) {
        stream.backUp(1);                 //"36#" - syntax error
      }
    } else if (stream.eat('.')) {       // float
      if (!stream.eatWhile(digitRE)) {
        stream.backUp(1);        // "3." - probably end of function
      } else {
        if (stream.eat(/[eE]/)) {        // float with exponent
          if (stream.eat(/[-+]/)) {
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(2);            // "2e-" - syntax error
            }
          } else {
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(1);            // "2e" - syntax error
            }
          }
        }
      }
    }
    return rval(state,stream,"number");   // normal integer
  }

  // open parens
  if (nongreedy(stream,openParenRE,openParenWords)) {
    return rval(state,stream,"open_paren");
  }

  // close parens
  if (nongreedy(stream,closeParenRE,closeParenWords)) {
    return rval(state,stream,"close_paren");
  }

  // separators
  if (greedy(stream,separatorRE,separatorWords)) {
    return rval(state,stream,"separator");
  }

  // operators
  if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
    return rval(state,stream,"operator");
  }

  return rval(state,stream,null);
}

/////////////////////////////////////////////////////////////////////////////
// utilities
function nongreedy(stream,re,words) {
  if (stream.current().length == 1 && re.test(stream.current())) {
    stream.backUp(1);
    while (re.test(stream.peek())) {
      stream.next();
      if (is_member(stream.current(),words)) {
        return true;
      }
    }
    stream.backUp(stream.current().length-1);
  }
  return false;
}

function greedy(stream,re,words) {
  if (stream.current().length == 1 && re.test(stream.current())) {
    while (re.test(stream.peek())) {
      stream.next();
    }
    while (0 < stream.current().length) {
      if (is_member(stream.current(),words)) {
        return true;
      }else{
        stream.backUp(1);
      }
    }
    stream.next();
  }
  return false;
}

function doubleQuote(stream) {
  return quote(stream, '"', '\\');
}

function singleQuote(stream) {
  return quote(stream,'\'','\\');
}

function quote(stream,quoteChar,escapeChar) {
  while (!stream.eol()) {
    var ch = stream.next();
    if (ch == quoteChar) {
      return true;
    }else if (ch == escapeChar) {
      stream.next();
    }
  }
  return false;
}

function lookahead(stream) {
  var m = stream.match(/^\s*([^\s%])/, false)
  return m ? m[1] : "";
}

function is_member(element,list) {
  return (-1 < list.indexOf(element));
}

function rval(state,stream,type) {

  // parse stack
  pushToken(state,realToken(type,stream));

  // map erlang token type to CodeMirror style class
  //     erlang             -> CodeMirror tag
  switch (type) {
  case "atom":        return "atom";
  case "attribute":   return "attribute";
  case "boolean":     return "atom";
  case "builtin":     return "builtin";
  case "close_paren": return null;
  case "colon":       return null;
  case "comment":     return "comment";
  case "dot":         return null;
  case "error":       return "error";
  case "fun":         return "meta";
  case "function":    return "tag";
  case "guard":       return "property";
  case "keyword":     return "keyword";
  case "macro":       return "macroName";
  case "number":      return "number";
  case "open_paren":  return null;
  case "operator":    return "operator";
  case "record":      return "bracket";
  case "separator":   return null;
  case "string":      return "string";
  case "type":        return "def";
  case "variable":    return "variable";
  default:            return null;
  }
}

function aToken(tok,col,ind,typ) {
  return {token:  tok,
          column: col,
          indent: ind,
          type:   typ};
}

function realToken(type,stream) {
  return aToken(stream.current(),
                stream.column(),
                stream.indentation(),
                type);
}

function fakeToken(type) {
  return aToken(type,0,0,type);
}

function peekToken(state,depth) {
  var len = state.tokenStack.length;
  var dep = (depth ? depth : 1);

  if (len < dep) {
    return false;
  }else{
    return state.tokenStack[len-dep];
  }
}

function pushToken(state,token) {

  if (!(token.type == "comment" || token.type == "whitespace")) {
    state.tokenStack = maybe_drop_pre(state.tokenStack,token);
    state.tokenStack = maybe_drop_post(state.tokenStack);
  }
}

function maybe_drop_pre(s,token) {
  var last = s.length-1;

  if (0 < last && s[last].type === "record" && token.type === "dot") {
    s.pop();
  }else if (0 < last && s[last].type === "group") {
    s.pop();
    s.push(token);
  }else{
    s.push(token);
  }
  return s;
}

function maybe_drop_post(s) {
  if (!s.length) return s
  var last = s.length-1;

  if (s[last].type === "dot") {
    return [];
  }
  if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {
    return s.slice(0,last-1);
  }
  switch (s[last].token) {
  case "}":    return d(s,{g:["{"]});
  case "]":    return d(s,{i:["["]});
  case ")":    return d(s,{i:["("]});
  case ">>":   return d(s,{i:["<<"]});
  case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});
  case ",":    return d(s,{e:["begin","try","when","->",
                              ",","(","[","{","<<"]});
  case "->":   return d(s,{r:["when"],
                           m:["try","if","case","receive"]});
  case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});
  case "catch":return d(s,{e:["try"]});
  case "of":   return d(s,{e:["case"]});
  case "after":return d(s,{e:["receive","try"]});
  default:     return s;
  }
}

function d(stack,tt) {
  // stack is a stack of Token objects.
  // tt is an object; {type:tokens}
  // type is a char, tokens is a list of token strings.
  // The function returns (possibly truncated) stack.
  // It will descend the stack, looking for a Token such that Token.token
  //  is a member of tokens. If it does not find that, it will normally (but
  //  see "E" below) return stack. If it does find a match, it will remove
  //  all the Tokens between the top and the matched Token.
  // If type is "m", that is all it does.
  // If type is "i", it will also remove the matched Token and the top Token.
  // If type is "g", like "i", but add a fake "group" token at the top.
  // If type is "r", it will remove the matched Token, but not the top Token.
  // If type is "e", it will keep the matched Token but not the top Token.
  // If type is "E", it behaves as for type "e", except if there is no match,
  //  in which case it will return an empty stack.

  for (var type in tt) {
    var len = stack.length-1;
    var tokens = tt[type];
    for (var i = len-1; -1 < i ; i--) {
      if (is_member(stack[i].token,tokens)) {
        var ss = stack.slice(0,i);
        switch (type) {
        case "m": return ss.concat(stack[i]).concat(stack[len]);
        case "r": return ss.concat(stack[len]);
        case "i": return ss;
        case "g": return ss.concat(fakeToken("group"));
        case "E": return ss.concat(stack[i]);
        case "e": return ss.concat(stack[i]);
        }
      }
    }
  }
  return (type == "E" ? [] : stack);
}

/////////////////////////////////////////////////////////////////////////////
// indenter

function indenter(state, textAfter, cx) {
  var t;
  var wordAfter = wordafter(textAfter);
  var currT = peekToken(state,1);
  var prevT = peekToken(state,2);

  if (state.in_string || state.in_atom) {
    return null;
  }else if (!prevT) {
    return 0;
  }else if (currT.token == "when") {
    return currT.column + cx.unit;
  }else if (wordAfter === "when" && prevT.type === "function") {
    return prevT.indent+cx.unit;
  }else if (wordAfter === "(" && currT.token === "fun") {
    return  currT.column+3;
  }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {
    return t.column;
  }else if (is_member(wordAfter,["end","after","of"])) {
    t = getToken(state,["begin","case","fun","if","receive","try"]);
    return t ? t.column : null;
  }else if (is_member(wordAfter,closeParenWords)) {
    t = getToken(state,openParenWords);
    return t ? t.column : null;
  }else if (is_member(currT.token,[",","|","||"]) ||
            is_member(wordAfter,[",","|","||"])) {
    t = postcommaToken(state);
    return t ? t.column+t.token.length : cx.unit;
  }else if (currT.token == "->") {
    if (is_member(prevT.token, ["receive","case","if","try"])) {
      return prevT.column+cx.unit+cx.unit;
    }else{
      return prevT.column+cx.unit;
    }
  }else if (is_member(currT.token,openParenWords)) {
    return currT.column+currT.token.length;
  }else{
    t = defaultToken(state);
    return truthy(t) ? t.column+cx.unit : 0;
  }
}

function wordafter(str) {
  var m = str.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/);

  return truthy(m) && (m.index === 0) ? m[0] : "";
}

function postcommaToken(state) {
  var objs = state.tokenStack.slice(0,-1);
  var i = getTokenIndex(objs,"type",["open_paren"]);

  return truthy(objs[i]) ? objs[i] : false;
}

function defaultToken(state) {
  var objs = state.tokenStack;
  var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);
  var oper = getTokenIndex(objs,"type",["operator"]);

  if (truthy(stop) && truthy(oper) && stop < oper) {
    return objs[stop+1];
  } else if (truthy(stop)) {
    return objs[stop];
  } else {
    return false;
  }
}

function getToken(state,tokens) {
  var objs = state.tokenStack;
  var i = getTokenIndex(objs,"token",tokens);

  return truthy(objs[i]) ? objs[i] : false;
}

function getTokenIndex(objs,propname,propvals) {

  for (var i = objs.length-1; -1 < i ; i--) {
    if (is_member(objs[i][propname],propvals)) {
      return i;
    }
  }
  return false;
}

function truthy(x) {
  return (x !== false) && (x != null);
}

/////////////////////////////////////////////////////////////////////////////
// this object defines the mode

const erlang = {
  startState() {
    return {tokenStack: [],
            in_string:  false,
            in_atom:    false};
  },

  token: tokenizer,

  indent: indenter,

  languageData: {
    commentTokens: {line: "%"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9lcmxhbmdfanMuZmM5NmJhYWIxNTBjZTBmZWY2YjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLGlCQUFpQjs7QUFFakIsK0JBQStCO0FBQy9CO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSSx5Q0FBeUMsRUFBRSxHQUFHLGFBQWE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsTUFBTSxrQ0FBa0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0JBQWtCLEtBQUssR0FBRztBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsOENBQThDO0FBQ3pFLDJCQUEyQjtBQUMzQiw0Q0FBNEMsUUFBUTtBQUNwRCwyQkFBMkI7QUFDM0IsMkRBQTJEO0FBQzNELFNBQVMsa0JBQWtCLDZDQUE2QztBQUN4RSwyQkFBMkIsVUFBVTtBQUNyQywyQkFBMkIsV0FBVztBQUN0QywyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9lcmxhbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnN0YW50c1xuXG52YXIgdHlwZVdvcmRzID0gW1xuICBcIi10eXBlXCIsIFwiLXNwZWNcIiwgXCItZXhwb3J0X3R5cGVcIiwgXCItb3BhcXVlXCJdO1xuXG52YXIga2V5d29yZFdvcmRzID0gW1xuICBcImFmdGVyXCIsXCJiZWdpblwiLFwiY2F0Y2hcIixcImNhc2VcIixcImNvbmRcIixcImVuZFwiLFwiZnVuXCIsXCJpZlwiLFxuICBcImxldFwiLFwib2ZcIixcInF1ZXJ5XCIsXCJyZWNlaXZlXCIsXCJ0cnlcIixcIndoZW5cIl07XG5cbnZhciBzZXBhcmF0b3JSRSAgICA9IC9bXFwtPiw7XS87XG52YXIgc2VwYXJhdG9yV29yZHMgPSBbXG4gIFwiLT5cIixcIjtcIixcIixcIl07XG5cbnZhciBvcGVyYXRvckF0b21Xb3JkcyA9IFtcbiAgXCJhbmRcIixcImFuZGFsc29cIixcImJhbmRcIixcImJub3RcIixcImJvclwiLFwiYnNsXCIsXCJic3JcIixcImJ4b3JcIixcbiAgXCJkaXZcIixcIm5vdFwiLFwib3JcIixcIm9yZWxzZVwiLFwicmVtXCIsXCJ4b3JcIl07XG5cbnZhciBvcGVyYXRvclN5bWJvbFJFICAgID0gL1tcXCtcXC1cXCpcXC88Pj1cXHw6IV0vO1xudmFyIG9wZXJhdG9yU3ltYm9sV29yZHMgPSBbXG4gIFwiPVwiLFwiK1wiLFwiLVwiLFwiKlwiLFwiL1wiLFwiPlwiLFwiPj1cIixcIjxcIixcIj08XCIsXCI9Oj1cIixcIj09XCIsXCI9Lz1cIixcIi89XCIsXCJ8fFwiLFwiPC1cIixcIiFcIl07XG5cbnZhciBvcGVuUGFyZW5SRSAgICA9IC9bPFxcKFxcW1xce10vO1xudmFyIG9wZW5QYXJlbldvcmRzID0gW1xuICBcIjw8XCIsXCIoXCIsXCJbXCIsXCJ7XCJdO1xuXG52YXIgY2xvc2VQYXJlblJFICAgID0gL1s+XFwpXFxdXFx9XS87XG52YXIgY2xvc2VQYXJlbldvcmRzID0gW1xuICBcIn1cIixcIl1cIixcIilcIixcIj4+XCJdO1xuXG52YXIgZ3VhcmRXb3JkcyA9IFtcbiAgXCJpc19hdG9tXCIsXCJpc19iaW5hcnlcIixcImlzX2JpdHN0cmluZ1wiLFwiaXNfYm9vbGVhblwiLFwiaXNfZmxvYXRcIixcbiAgXCJpc19mdW5jdGlvblwiLFwiaXNfaW50ZWdlclwiLFwiaXNfbGlzdFwiLFwiaXNfbnVtYmVyXCIsXCJpc19waWRcIixcbiAgXCJpc19wb3J0XCIsXCJpc19yZWNvcmRcIixcImlzX3JlZmVyZW5jZVwiLFwiaXNfdHVwbGVcIixcbiAgXCJhdG9tXCIsXCJiaW5hcnlcIixcImJpdHN0cmluZ1wiLFwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIixcImludGVnZXJcIixcImxpc3RcIixcbiAgXCJudW1iZXJcIixcInBpZFwiLFwicG9ydFwiLFwicmVjb3JkXCIsXCJyZWZlcmVuY2VcIixcInR1cGxlXCJdO1xuXG52YXIgYmlmV29yZHMgPSBbXG4gIFwiYWJzXCIsXCJhZGxlcjMyXCIsXCJhZGxlcjMyX2NvbWJpbmVcIixcImFsaXZlXCIsXCJhcHBseVwiLFwiYXRvbV90b19iaW5hcnlcIixcbiAgXCJhdG9tX3RvX2xpc3RcIixcImJpbmFyeV90b19hdG9tXCIsXCJiaW5hcnlfdG9fZXhpc3RpbmdfYXRvbVwiLFxuICBcImJpbmFyeV90b19saXN0XCIsXCJiaW5hcnlfdG9fdGVybVwiLFwiYml0X3NpemVcIixcImJpdHN0cmluZ190b19saXN0XCIsXG4gIFwiYnl0ZV9zaXplXCIsXCJjaGVja19wcm9jZXNzX2NvZGVcIixcImNvbnRhY3RfYmluYXJ5XCIsXCJjcmMzMlwiLFxuICBcImNyYzMyX2NvbWJpbmVcIixcImRhdGVcIixcImRlY29kZV9wYWNrZXRcIixcImRlbGV0ZV9tb2R1bGVcIixcbiAgXCJkaXNjb25uZWN0X25vZGVcIixcImVsZW1lbnRcIixcImVyYXNlXCIsXCJleGl0XCIsXCJmbG9hdFwiLFwiZmxvYXRfdG9fbGlzdFwiLFxuICBcImdhcmJhZ2VfY29sbGVjdFwiLFwiZ2V0XCIsXCJnZXRfa2V5c1wiLFwiZ3JvdXBfbGVhZGVyXCIsXCJoYWx0XCIsXCJoZFwiLFxuICBcImludGVnZXJfdG9fbGlzdFwiLFwiaW50ZXJuYWxfYmlmXCIsXCJpb2xpc3Rfc2l6ZVwiLFwiaW9saXN0X3RvX2JpbmFyeVwiLFxuICBcImlzX2FsaXZlXCIsXCJpc19hdG9tXCIsXCJpc19iaW5hcnlcIixcImlzX2JpdHN0cmluZ1wiLFwiaXNfYm9vbGVhblwiLFxuICBcImlzX2Zsb2F0XCIsXCJpc19mdW5jdGlvblwiLFwiaXNfaW50ZWdlclwiLFwiaXNfbGlzdFwiLFwiaXNfbnVtYmVyXCIsXCJpc19waWRcIixcbiAgXCJpc19wb3J0XCIsXCJpc19wcm9jZXNzX2FsaXZlXCIsXCJpc19yZWNvcmRcIixcImlzX3JlZmVyZW5jZVwiLFwiaXNfdHVwbGVcIixcbiAgXCJsZW5ndGhcIixcImxpbmtcIixcImxpc3RfdG9fYXRvbVwiLFwibGlzdF90b19iaW5hcnlcIixcImxpc3RfdG9fYml0c3RyaW5nXCIsXG4gIFwibGlzdF90b19leGlzdGluZ19hdG9tXCIsXCJsaXN0X3RvX2Zsb2F0XCIsXCJsaXN0X3RvX2ludGVnZXJcIixcbiAgXCJsaXN0X3RvX3BpZFwiLFwibGlzdF90b190dXBsZVwiLFwibG9hZF9tb2R1bGVcIixcIm1ha2VfcmVmXCIsXCJtb2R1bGVfbG9hZGVkXCIsXG4gIFwibW9uaXRvcl9ub2RlXCIsXCJub2RlXCIsXCJub2RlX2xpbmtcIixcIm5vZGVfdW5saW5rXCIsXCJub2Rlc1wiLFwibm90YWxpdmVcIixcbiAgXCJub3dcIixcIm9wZW5fcG9ydFwiLFwicGlkX3RvX2xpc3RcIixcInBvcnRfY2xvc2VcIixcInBvcnRfY29tbWFuZFwiLFxuICBcInBvcnRfY29ubmVjdFwiLFwicG9ydF9jb250cm9sXCIsXCJwcmVfbG9hZGVkXCIsXCJwcm9jZXNzX2ZsYWdcIixcbiAgXCJwcm9jZXNzX2luZm9cIixcInByb2Nlc3Nlc1wiLFwicHVyZ2VfbW9kdWxlXCIsXCJwdXRcIixcInJlZ2lzdGVyXCIsXG4gIFwicmVnaXN0ZXJlZFwiLFwicm91bmRcIixcInNlbGZcIixcInNldGVsZW1lbnRcIixcInNpemVcIixcInNwYXduXCIsXCJzcGF3bl9saW5rXCIsXG4gIFwic3Bhd25fbW9uaXRvclwiLFwic3Bhd25fb3B0XCIsXCJzcGxpdF9iaW5hcnlcIixcInN0YXRpc3RpY3NcIixcbiAgXCJ0ZXJtX3RvX2JpbmFyeVwiLFwidGltZVwiLFwidGhyb3dcIixcInRsXCIsXCJ0cnVuY1wiLFwidHVwbGVfc2l6ZVwiLFxuICBcInR1cGxlX3RvX2xpc3RcIixcInVubGlua1wiLFwidW5yZWdpc3RlclwiLFwid2hlcmVpc1wiXTtcblxuLy8gdXBwZXIgY2FzZTogW0EtWl0gW8OYLcOeXSBbw4Atw5ZdXG4vLyBsb3dlciBjYXNlOiBbYS16XSBbw58tw7ZdIFvDuC3Dv11cbnZhciBhbnVtUkUgICAgICAgPSAvW1xcd0DDmC3DnsOALcOWw58tw7bDuC3Dv10vO1xudmFyIGVzY2FwZXNSRSAgICA9XG4gICAgL1swLTddezEsM318W2JkZWZucnN0dlxcXFxcIiddfFxcXlthLXpBLVpdfHhbMC05YS16QS1aXXsyfXx4e1swLTlhLXpBLVpdK30vO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdG9rZW5pemVyXG5cbmZ1bmN0aW9uIHRva2VuaXplcihzdHJlYW0sc3RhdGUpIHtcbiAgLy8gaW4gbXVsdGktbGluZSBzdHJpbmdcbiAgaWYgKHN0YXRlLmluX3N0cmluZykge1xuICAgIHN0YXRlLmluX3N0cmluZyA9ICghZG91YmxlUXVvdGUoc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic3RyaW5nXCIpO1xuICB9XG5cbiAgLy8gaW4gbXVsdGktbGluZSBhdG9tXG4gIGlmIChzdGF0ZS5pbl9hdG9tKSB7XG4gICAgc3RhdGUuaW5fYXRvbSA9ICghc2luZ2xlUXVvdGUoc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXRvbVwiKTtcbiAgfVxuXG4gIC8vIHdoaXRlc3BhY2VcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwid2hpdGVzcGFjZVwiKTtcbiAgfVxuXG4gIC8vIGF0dHJpYnV0ZXMgYW5kIHR5cGUgc3BlY3NcbiAgaWYgKCFwZWVrVG9rZW4oc3RhdGUpICYmXG4gICAgICBzdHJlYW0ubWF0Y2goLy1cXHMqW2EtesOfLcO2w7gtw79dW1xcd8OYLcOew4Atw5bDny3DtsO4LcO/XSovKSkge1xuICAgIGlmIChpc19tZW1iZXIoc3RyZWFtLmN1cnJlbnQoKSx0eXBlV29yZHMpKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJ0eXBlXCIpO1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXR0cmlidXRlXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgLy8gY29tbWVudFxuICBpZiAoY2ggPT0gJyUnKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNvbW1lbnRcIik7XG4gIH1cblxuICAvLyBjb2xvblxuICBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJjb2xvblwiKTtcbiAgfVxuXG4gIC8vIG1hY3JvXG4gIGlmIChjaCA9PSAnPycpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJtYWNyb1wiKTtcbiAgfVxuXG4gIC8vIHJlY29yZFxuICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJyZWNvcmRcIik7XG4gIH1cblxuICAvLyBkb2xsYXIgZXNjYXBlXG4gIGlmIChjaCA9PSBcIiRcIikge1xuICAgIGlmIChzdHJlYW0ubmV4dCgpID09IFwiXFxcXFwiICYmICFzdHJlYW0ubWF0Y2goZXNjYXBlc1JFKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZXJyb3JcIik7XG4gICAgfVxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm51bWJlclwiKTtcbiAgfVxuXG4gIC8vIGRvdFxuICBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJkb3RcIik7XG4gIH1cblxuICAvLyBxdW90ZWQgYXRvbVxuICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICBpZiAoIShzdGF0ZS5pbl9hdG9tID0gKCFzaW5nbGVRdW90ZShzdHJlYW0pKSkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLGZhbHNlKSkge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLHRydWUpO1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5cIik7ICAgICAgLy8gJ2YnLzAgc3R5bGUgZnVuXG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwoLyxmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKC9cXHMqOi8sZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJhdG9tXCIpO1xuICB9XG5cbiAgLy8gc3RyaW5nXG4gIGlmIChjaCA9PSAnXCInKSB7XG4gICAgc3RhdGUuaW5fc3RyaW5nID0gKCFkb3VibGVRdW90ZShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzdHJpbmdcIik7XG4gIH1cblxuICAvLyB2YXJpYWJsZVxuICBpZiAoL1tBLVpfw5gtw57DgC3Dll0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGFudW1SRSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwidmFyaWFibGVcIik7XG4gIH1cblxuICAvLyBhdG9tL2tleXdvcmQvQklGL2Z1bmN0aW9uXG4gIGlmICgvW2Etel/Dny3DtsO4LcO/XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcblxuICAgIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLGZhbHNlKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyx0cnVlKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1blwiKTsgICAgICAvLyBmLzAgc3R5bGUgZnVuXG4gICAgfVxuXG4gICAgdmFyIHcgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gICAgaWYgKGlzX21lbWJlcih3LGtleXdvcmRXb3JkcykpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImtleXdvcmRcIik7XG4gICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LG9wZXJhdG9yQXRvbVdvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3BlcmF0b3JcIik7XG4gICAgfWVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcKC8sZmFsc2UpKSB7XG4gICAgICAvLyAncHV0JyBhbmQgJ2VybGFuZzpwdXQnIGFyZSBiaWZzLCAnZm9vOnB1dCcgaXMgbm90XG4gICAgICBpZiAoaXNfbWVtYmVyKHcsYmlmV29yZHMpICYmXG4gICAgICAgICAgKChwZWVrVG9rZW4oc3RhdGUpLnRva2VuICE9IFwiOlwiKSB8fFxuICAgICAgICAgICAocGVla1Rva2VuKHN0YXRlLDIpLnRva2VuID09IFwiZXJsYW5nXCIpKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJidWlsdGluXCIpO1xuICAgICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LGd1YXJkV29yZHMpKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImd1YXJkXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmIChsb29rYWhlYWQoc3RyZWFtKSA9PSBcIjpcIikge1xuICAgICAgaWYgKHcgPT0gXCJlcmxhbmdcIikge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJidWlsdGluXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LFtcInRydWVcIixcImZhbHNlXCJdKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYm9vbGVhblwiKTtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gbnVtYmVyXG4gIHZhciBkaWdpdFJFICAgICAgPSAvWzAtOV0vO1xuICB2YXIgcmFkaXhSRSAgICAgID0gL1swLTlhLXpBLVpdLzsgICAgICAgICAvLyAzNiN6WiBzdHlsZSBpbnRcbiAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSk7XG4gICAgaWYgKHN0cmVhbS5lYXQoJyMnKSkgeyAgICAgICAgICAgICAgICAvLyAzNiNhWiAgc3R5bGUgaW50ZWdlclxuICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUocmFkaXhSRSkpIHtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgICAgICAgICAgIC8vXCIzNiNcIiAtIHN5bnRheCBlcnJvclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnLicpKSB7ICAgICAgIC8vIGZsb2F0XG4gICAgICBpZiAoIXN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgLy8gXCIzLlwiIC0gcHJvYmFibHkgZW5kIG9mIGZ1bmN0aW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdCgvW2VFXS8pKSB7ICAgICAgICAvLyBmbG9hdCB3aXRoIGV4cG9uZW50XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoL1stK10vKSkge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgyKTsgICAgICAgICAgICAvLyBcIjJlLVwiIC0gc3ludGF4IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7ICAgICAgICAgICAgLy8gXCIyZVwiIC0gc3ludGF4IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm51bWJlclwiKTsgICAvLyBub3JtYWwgaW50ZWdlclxuICB9XG5cbiAgLy8gb3BlbiBwYXJlbnNcbiAgaWYgKG5vbmdyZWVkeShzdHJlYW0sb3BlblBhcmVuUkUsb3BlblBhcmVuV29yZHMpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3Blbl9wYXJlblwiKTtcbiAgfVxuXG4gIC8vIGNsb3NlIHBhcmVuc1xuICBpZiAobm9uZ3JlZWR5KHN0cmVhbSxjbG9zZVBhcmVuUkUsY2xvc2VQYXJlbldvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNsb3NlX3BhcmVuXCIpO1xuICB9XG5cbiAgLy8gc2VwYXJhdG9yc1xuICBpZiAoZ3JlZWR5KHN0cmVhbSxzZXBhcmF0b3JSRSxzZXBhcmF0b3JXb3JkcykpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzZXBhcmF0b3JcIik7XG4gIH1cblxuICAvLyBvcGVyYXRvcnNcbiAgaWYgKGdyZWVkeShzdHJlYW0sb3BlcmF0b3JTeW1ib2xSRSxvcGVyYXRvclN5bWJvbFdvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm9wZXJhdG9yXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLG51bGwpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdXRpbGl0aWVzXG5mdW5jdGlvbiBub25ncmVlZHkoc3RyZWFtLHJlLHdvcmRzKSB7XG4gIGlmIChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCA9PSAxICYmIHJlLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgIHdoaWxlIChyZS50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHdvcmRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtLmJhY2tVcChzdHJlYW0uY3VycmVudCgpLmxlbmd0aC0xKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdyZWVkeShzdHJlYW0scmUsd29yZHMpIHtcbiAgaWYgKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoID09IDEgJiYgcmUudGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgIHdoaWxlIChyZS50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgICB3aGlsZSAoMCA8IHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0cmVhbS5jdXJyZW50KCksd29yZHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0cmVhbS5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkb3VibGVRdW90ZShzdHJlYW0pIHtcbiAgcmV0dXJuIHF1b3RlKHN0cmVhbSwgJ1wiJywgJ1xcXFwnKTtcbn1cblxuZnVuY3Rpb24gc2luZ2xlUXVvdGUoc3RyZWFtKSB7XG4gIHJldHVybiBxdW90ZShzdHJlYW0sJ1xcJycsJ1xcXFwnKTtcbn1cblxuZnVuY3Rpb24gcXVvdGUoc3RyZWFtLHF1b3RlQ2hhcixlc2NhcGVDaGFyKSB7XG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gcXVvdGVDaGFyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9ZWxzZSBpZiAoY2ggPT0gZXNjYXBlQ2hhcikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsb29rYWhlYWQoc3RyZWFtKSB7XG4gIHZhciBtID0gc3RyZWFtLm1hdGNoKC9eXFxzKihbXlxccyVdKS8sIGZhbHNlKVxuICByZXR1cm4gbSA/IG1bMV0gOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBpc19tZW1iZXIoZWxlbWVudCxsaXN0KSB7XG4gIHJldHVybiAoLTEgPCBsaXN0LmluZGV4T2YoZWxlbWVudCkpO1xufVxuXG5mdW5jdGlvbiBydmFsKHN0YXRlLHN0cmVhbSx0eXBlKSB7XG5cbiAgLy8gcGFyc2Ugc3RhY2tcbiAgcHVzaFRva2VuKHN0YXRlLHJlYWxUb2tlbih0eXBlLHN0cmVhbSkpO1xuXG4gIC8vIG1hcCBlcmxhbmcgdG9rZW4gdHlwZSB0byBDb2RlTWlycm9yIHN0eWxlIGNsYXNzXG4gIC8vICAgICBlcmxhbmcgICAgICAgICAgICAgLT4gQ29kZU1pcnJvciB0YWdcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgXCJhdG9tXCI6ICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gIGNhc2UgXCJhdHRyaWJ1dGVcIjogICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgY2FzZSBcImJvb2xlYW5cIjogICAgIHJldHVybiBcImF0b21cIjtcbiAgY2FzZSBcImJ1aWx0aW5cIjogICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgY2FzZSBcImNsb3NlX3BhcmVuXCI6IHJldHVybiBudWxsO1xuICBjYXNlIFwiY29sb25cIjogICAgICAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJjb21tZW50XCI6ICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIGNhc2UgXCJkb3RcIjogICAgICAgICByZXR1cm4gbnVsbDtcbiAgY2FzZSBcImVycm9yXCI6ICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gIGNhc2UgXCJmdW5cIjogICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gIGNhc2UgXCJmdW5jdGlvblwiOiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgY2FzZSBcImd1YXJkXCI6ICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gIGNhc2UgXCJrZXl3b3JkXCI6ICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIGNhc2UgXCJtYWNyb1wiOiAgICAgICByZXR1cm4gXCJtYWNyb05hbWVcIjtcbiAgY2FzZSBcIm51bWJlclwiOiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICBjYXNlIFwib3Blbl9wYXJlblwiOiAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJvcGVyYXRvclwiOiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICBjYXNlIFwicmVjb3JkXCI6ICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICBjYXNlIFwic2VwYXJhdG9yXCI6ICAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJzdHJpbmdcIjogICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgY2FzZSBcInR5cGVcIjogICAgICAgIHJldHVybiBcImRlZlwiO1xuICBjYXNlIFwidmFyaWFibGVcIjogICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgZGVmYXVsdDogICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhVG9rZW4odG9rLGNvbCxpbmQsdHlwKSB7XG4gIHJldHVybiB7dG9rZW46ICB0b2ssXG4gICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgaW5kZW50OiBpbmQsXG4gICAgICAgICAgdHlwZTogICB0eXB9O1xufVxuXG5mdW5jdGlvbiByZWFsVG9rZW4odHlwZSxzdHJlYW0pIHtcbiAgcmV0dXJuIGFUb2tlbihzdHJlYW0uY3VycmVudCgpLFxuICAgICAgICAgICAgICAgIHN0cmVhbS5jb2x1bW4oKSxcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5kZW50YXRpb24oKSxcbiAgICAgICAgICAgICAgICB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZmFrZVRva2VuKHR5cGUpIHtcbiAgcmV0dXJuIGFUb2tlbih0eXBlLDAsMCx0eXBlKTtcbn1cblxuZnVuY3Rpb24gcGVla1Rva2VuKHN0YXRlLGRlcHRoKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS50b2tlblN0YWNrLmxlbmd0aDtcbiAgdmFyIGRlcCA9IChkZXB0aCA/IGRlcHRoIDogMSk7XG5cbiAgaWYgKGxlbiA8IGRlcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfWVsc2V7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuU3RhY2tbbGVuLWRlcF07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFRva2VuKHN0YXRlLHRva2VuKSB7XG5cbiAgaWYgKCEodG9rZW4udHlwZSA9PSBcImNvbW1lbnRcIiB8fCB0b2tlbi50eXBlID09IFwid2hpdGVzcGFjZVwiKSkge1xuICAgIHN0YXRlLnRva2VuU3RhY2sgPSBtYXliZV9kcm9wX3ByZShzdGF0ZS50b2tlblN0YWNrLHRva2VuKTtcbiAgICBzdGF0ZS50b2tlblN0YWNrID0gbWF5YmVfZHJvcF9wb3N0KHN0YXRlLnRva2VuU3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlX2Ryb3BfcHJlKHMsdG9rZW4pIHtcbiAgdmFyIGxhc3QgPSBzLmxlbmd0aC0xO1xuXG4gIGlmICgwIDwgbGFzdCAmJiBzW2xhc3RdLnR5cGUgPT09IFwicmVjb3JkXCIgJiYgdG9rZW4udHlwZSA9PT0gXCJkb3RcIikge1xuICAgIHMucG9wKCk7XG4gIH1lbHNlIGlmICgwIDwgbGFzdCAmJiBzW2xhc3RdLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgIHMucG9wKCk7XG4gICAgcy5wdXNoKHRva2VuKTtcbiAgfWVsc2V7XG4gICAgcy5wdXNoKHRva2VuKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gbWF5YmVfZHJvcF9wb3N0KHMpIHtcbiAgaWYgKCFzLmxlbmd0aCkgcmV0dXJuIHNcbiAgdmFyIGxhc3QgPSBzLmxlbmd0aC0xO1xuXG4gIGlmIChzW2xhc3RdLnR5cGUgPT09IFwiZG90XCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGxhc3QgPiAxICYmIHNbbGFzdF0udHlwZSA9PT0gXCJmdW5cIiAmJiBzW2xhc3QtMV0udG9rZW4gPT09IFwiZnVuXCIpIHtcbiAgICByZXR1cm4gcy5zbGljZSgwLGxhc3QtMSk7XG4gIH1cbiAgc3dpdGNoIChzW2xhc3RdLnRva2VuKSB7XG4gIGNhc2UgXCJ9XCI6ICAgIHJldHVybiBkKHMse2c6W1wie1wiXX0pO1xuICBjYXNlIFwiXVwiOiAgICByZXR1cm4gZChzLHtpOltcIltcIl19KTtcbiAgY2FzZSBcIilcIjogICAgcmV0dXJuIGQocyx7aTpbXCIoXCJdfSk7XG4gIGNhc2UgXCI+PlwiOiAgIHJldHVybiBkKHMse2k6W1wiPDxcIl19KTtcbiAgY2FzZSBcImVuZFwiOiAgcmV0dXJuIGQocyx7aTpbXCJiZWdpblwiLFwiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCJdfSk7XG4gIGNhc2UgXCIsXCI6ICAgIHJldHVybiBkKHMse2U6W1wiYmVnaW5cIixcInRyeVwiLFwid2hlblwiLFwiLT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiLFwiKFwiLFwiW1wiLFwie1wiLFwiPDxcIl19KTtcbiAgY2FzZSBcIi0+XCI6ICAgcmV0dXJuIGQocyx7cjpbXCJ3aGVuXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbTpbXCJ0cnlcIixcImlmXCIsXCJjYXNlXCIsXCJyZWNlaXZlXCJdfSk7XG4gIGNhc2UgXCI7XCI6ICAgIHJldHVybiBkKHMse0U6W1wiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCIsXCJ3aGVuXCJdfSk7XG4gIGNhc2UgXCJjYXRjaFwiOnJldHVybiBkKHMse2U6W1widHJ5XCJdfSk7XG4gIGNhc2UgXCJvZlwiOiAgIHJldHVybiBkKHMse2U6W1wiY2FzZVwiXX0pO1xuICBjYXNlIFwiYWZ0ZXJcIjpyZXR1cm4gZChzLHtlOltcInJlY2VpdmVcIixcInRyeVwiXX0pO1xuICBkZWZhdWx0OiAgICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZChzdGFjayx0dCkge1xuICAvLyBzdGFjayBpcyBhIHN0YWNrIG9mIFRva2VuIG9iamVjdHMuXG4gIC8vIHR0IGlzIGFuIG9iamVjdDsge3R5cGU6dG9rZW5zfVxuICAvLyB0eXBlIGlzIGEgY2hhciwgdG9rZW5zIGlzIGEgbGlzdCBvZiB0b2tlbiBzdHJpbmdzLlxuICAvLyBUaGUgZnVuY3Rpb24gcmV0dXJucyAocG9zc2libHkgdHJ1bmNhdGVkKSBzdGFjay5cbiAgLy8gSXQgd2lsbCBkZXNjZW5kIHRoZSBzdGFjaywgbG9va2luZyBmb3IgYSBUb2tlbiBzdWNoIHRoYXQgVG9rZW4udG9rZW5cbiAgLy8gIGlzIGEgbWVtYmVyIG9mIHRva2Vucy4gSWYgaXQgZG9lcyBub3QgZmluZCB0aGF0LCBpdCB3aWxsIG5vcm1hbGx5IChidXRcbiAgLy8gIHNlZSBcIkVcIiBiZWxvdykgcmV0dXJuIHN0YWNrLiBJZiBpdCBkb2VzIGZpbmQgYSBtYXRjaCwgaXQgd2lsbCByZW1vdmVcbiAgLy8gIGFsbCB0aGUgVG9rZW5zIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlIG1hdGNoZWQgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJtXCIsIHRoYXQgaXMgYWxsIGl0IGRvZXMuXG4gIC8vIElmIHR5cGUgaXMgXCJpXCIsIGl0IHdpbGwgYWxzbyByZW1vdmUgdGhlIG1hdGNoZWQgVG9rZW4gYW5kIHRoZSB0b3AgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJnXCIsIGxpa2UgXCJpXCIsIGJ1dCBhZGQgYSBmYWtlIFwiZ3JvdXBcIiB0b2tlbiBhdCB0aGUgdG9wLlxuICAvLyBJZiB0eXBlIGlzIFwiclwiLCBpdCB3aWxsIHJlbW92ZSB0aGUgbWF0Y2hlZCBUb2tlbiwgYnV0IG5vdCB0aGUgdG9wIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwiZVwiLCBpdCB3aWxsIGtlZXAgdGhlIG1hdGNoZWQgVG9rZW4gYnV0IG5vdCB0aGUgdG9wIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwiRVwiLCBpdCBiZWhhdmVzIGFzIGZvciB0eXBlIFwiZVwiLCBleGNlcHQgaWYgdGhlcmUgaXMgbm8gbWF0Y2gsXG4gIC8vICBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0YWNrLlxuXG4gIGZvciAodmFyIHR5cGUgaW4gdHQpIHtcbiAgICB2YXIgbGVuID0gc3RhY2subGVuZ3RoLTE7XG4gICAgdmFyIHRva2VucyA9IHR0W3R5cGVdO1xuICAgIGZvciAodmFyIGkgPSBsZW4tMTsgLTEgPCBpIDsgaS0tKSB7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0YWNrW2ldLnRva2VuLHRva2VucykpIHtcbiAgICAgICAgdmFyIHNzID0gc3RhY2suc2xpY2UoMCxpKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbaV0pLmNvbmNhdChzdGFja1tsZW5dKTtcbiAgICAgICAgY2FzZSBcInJcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tsZW5dKTtcbiAgICAgICAgY2FzZSBcImlcIjogcmV0dXJuIHNzO1xuICAgICAgICBjYXNlIFwiZ1wiOiByZXR1cm4gc3MuY29uY2F0KGZha2VUb2tlbihcImdyb3VwXCIpKTtcbiAgICAgICAgY2FzZSBcIkVcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSk7XG4gICAgICAgIGNhc2UgXCJlXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAodHlwZSA9PSBcIkVcIiA/IFtdIDogc3RhY2spO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaW5kZW50ZXJcblxuZnVuY3Rpb24gaW5kZW50ZXIoc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgdmFyIHQ7XG4gIHZhciB3b3JkQWZ0ZXIgPSB3b3JkYWZ0ZXIodGV4dEFmdGVyKTtcbiAgdmFyIGN1cnJUID0gcGVla1Rva2VuKHN0YXRlLDEpO1xuICB2YXIgcHJldlQgPSBwZWVrVG9rZW4oc3RhdGUsMik7XG5cbiAgaWYgKHN0YXRlLmluX3N0cmluZyB8fCBzdGF0ZS5pbl9hdG9tKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1lbHNlIGlmICghcHJldlQpIHtcbiAgICByZXR1cm4gMDtcbiAgfWVsc2UgaWYgKGN1cnJULnRva2VuID09IFwid2hlblwiKSB7XG4gICAgcmV0dXJuIGN1cnJULmNvbHVtbiArIGN4LnVuaXQ7XG4gIH1lbHNlIGlmICh3b3JkQWZ0ZXIgPT09IFwid2hlblwiICYmIHByZXZULnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBwcmV2VC5pbmRlbnQrY3gudW5pdDtcbiAgfWVsc2UgaWYgKHdvcmRBZnRlciA9PT0gXCIoXCIgJiYgY3VyclQudG9rZW4gPT09IFwiZnVuXCIpIHtcbiAgICByZXR1cm4gIGN1cnJULmNvbHVtbiszO1xuICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcImNhdGNoXCIgJiYgKHQgPSBnZXRUb2tlbihzdGF0ZSxbXCJ0cnlcIl0pKSkge1xuICAgIHJldHVybiB0LmNvbHVtbjtcbiAgfWVsc2UgaWYgKGlzX21lbWJlcih3b3JkQWZ0ZXIsW1wiZW5kXCIsXCJhZnRlclwiLFwib2ZcIl0pKSB7XG4gICAgdCA9IGdldFRva2VuKHN0YXRlLFtcImJlZ2luXCIsXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIl0pO1xuICAgIHJldHVybiB0ID8gdC5jb2x1bW4gOiBudWxsO1xuICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHdvcmRBZnRlcixjbG9zZVBhcmVuV29yZHMpKSB7XG4gICAgdCA9IGdldFRva2VuKHN0YXRlLG9wZW5QYXJlbldvcmRzKTtcbiAgICByZXR1cm4gdCA/IHQuY29sdW1uIDogbnVsbDtcbiAgfWVsc2UgaWYgKGlzX21lbWJlcihjdXJyVC50b2tlbixbXCIsXCIsXCJ8XCIsXCJ8fFwiXSkgfHxcbiAgICAgICAgICAgIGlzX21lbWJlcih3b3JkQWZ0ZXIsW1wiLFwiLFwifFwiLFwifHxcIl0pKSB7XG4gICAgdCA9IHBvc3Rjb21tYVRva2VuKHN0YXRlKTtcbiAgICByZXR1cm4gdCA/IHQuY29sdW1uK3QudG9rZW4ubGVuZ3RoIDogY3gudW5pdDtcbiAgfWVsc2UgaWYgKGN1cnJULnRva2VuID09IFwiLT5cIikge1xuICAgIGlmIChpc19tZW1iZXIocHJldlQudG9rZW4sIFtcInJlY2VpdmVcIixcImNhc2VcIixcImlmXCIsXCJ0cnlcIl0pKSB7XG4gICAgICByZXR1cm4gcHJldlQuY29sdW1uK2N4LnVuaXQrY3gudW5pdDtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBwcmV2VC5jb2x1bW4rY3gudW5pdDtcbiAgICB9XG4gIH1lbHNlIGlmIChpc19tZW1iZXIoY3VyclQudG9rZW4sb3BlblBhcmVuV29yZHMpKSB7XG4gICAgcmV0dXJuIGN1cnJULmNvbHVtbitjdXJyVC50b2tlbi5sZW5ndGg7XG4gIH1lbHNle1xuICAgIHQgPSBkZWZhdWx0VG9rZW4oc3RhdGUpO1xuICAgIHJldHVybiB0cnV0aHkodCkgPyB0LmNvbHVtbitjeC51bml0IDogMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JkYWZ0ZXIoc3RyKSB7XG4gIHZhciBtID0gc3RyLm1hdGNoKC8sfFthLXpdK3xcXH18XFxdfFxcKXw+PnxcXHwrfFxcKC8pO1xuXG4gIHJldHVybiB0cnV0aHkobSkgJiYgKG0uaW5kZXggPT09IDApID8gbVswXSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHBvc3Rjb21tYVRva2VuKHN0YXRlKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjay5zbGljZSgwLC0xKTtcbiAgdmFyIGkgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3Blbl9wYXJlblwiXSk7XG5cbiAgcmV0dXJuIHRydXRoeShvYmpzW2ldKSA/IG9ianNbaV0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRva2VuKHN0YXRlKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjaztcbiAgdmFyIHN0b3AgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3Blbl9wYXJlblwiLFwic2VwYXJhdG9yXCIsXCJrZXl3b3JkXCJdKTtcbiAgdmFyIG9wZXIgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3BlcmF0b3JcIl0pO1xuXG4gIGlmICh0cnV0aHkoc3RvcCkgJiYgdHJ1dGh5KG9wZXIpICYmIHN0b3AgPCBvcGVyKSB7XG4gICAgcmV0dXJuIG9ianNbc3RvcCsxXTtcbiAgfSBlbHNlIGlmICh0cnV0aHkoc3RvcCkpIHtcbiAgICByZXR1cm4gb2Jqc1tzdG9wXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW4oc3RhdGUsdG9rZW5zKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjaztcbiAgdmFyIGkgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0b2tlblwiLHRva2Vucyk7XG5cbiAgcmV0dXJuIHRydXRoeShvYmpzW2ldKSA/IG9ianNbaV0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5JbmRleChvYmpzLHByb3BuYW1lLHByb3B2YWxzKSB7XG5cbiAgZm9yICh2YXIgaSA9IG9ianMubGVuZ3RoLTE7IC0xIDwgaSA7IGktLSkge1xuICAgIGlmIChpc19tZW1iZXIob2Jqc1tpXVtwcm9wbmFtZV0scHJvcHZhbHMpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cnV0aHkoeCkge1xuICByZXR1cm4gKHggIT09IGZhbHNlKSAmJiAoeCAhPSBudWxsKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHRoaXMgb2JqZWN0IGRlZmluZXMgdGhlIG1vZGVcblxuZXhwb3J0IGNvbnN0IGVybGFuZyA9IHtcbiAgc3RhcnRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge3Rva2VuU3RhY2s6IFtdLFxuICAgICAgICAgICAgaW5fc3RyaW5nOiAgZmFsc2UsXG4gICAgICAgICAgICBpbl9hdG9tOiAgICBmYWxzZX07XG4gIH0sXG5cbiAgdG9rZW46IHRva2VuaXplcixcblxuICBpbmRlbnQ6IGluZGVudGVyLFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiVcIn1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9