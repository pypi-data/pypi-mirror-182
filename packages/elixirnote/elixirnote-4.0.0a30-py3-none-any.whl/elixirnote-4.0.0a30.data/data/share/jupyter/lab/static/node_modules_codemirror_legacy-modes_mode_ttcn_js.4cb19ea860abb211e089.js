"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_ttcn_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/ttcn.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/ttcn.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ttcn": () => (/* binding */ ttcn)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

const parserConfig = {
  name: "ttcn",
  keywords: words("activate address alive all alt altstep and and4b any" +
                  " break case component const continue control deactivate" +
                  " display do else encode enumerated except exception" +
                  " execute extends extension external for from function" +
                  " goto group if import in infinity inout interleave" +
                  " label language length log match message mixed mod" +
                  " modifies module modulepar mtc noblock not not4b nowait" +
                  " of on optional or or4b out override param pattern port" +
                  " procedure record recursive rem repeat return runs select" +
                  " self sender set signature system template testcase to" +
                  " type union value valueof var variant while with xor xor4b"),
  builtin: words("bit2hex bit2int bit2oct bit2str char2int char2oct encvalue" +
                 " decomp decvalue float2int float2str hex2bit hex2int" +
                 " hex2oct hex2str int2bit int2char int2float int2hex" +
                 " int2oct int2str int2unichar isbound ischosen ispresent" +
                 " isvalue lengthof log2str oct2bit oct2char oct2hex oct2int" +
                 " oct2str regexp replace rnd sizeof str2bit str2float" +
                 " str2hex str2int str2oct substr unichar2int unichar2char" +
                 " enum2int"),
  types: words("anytype bitstring boolean char charstring default float" +
               " hexstring integer objid octetstring universal verdicttype timer"),
  timerOps: words("read running start stop timeout"),
  portOps: words("call catch check clear getcall getreply halt raise receive" +
                 " reply send trigger"),
  configOps: words("create connect disconnect done kill killed map unmap"),
  verdictOps: words("getverdict setverdict"),
  sutOps: words("action"),
  functionOps: words("apply derefers refers"),

  verdictConsts: words("error fail inconc none pass"),
  booleanConsts: words("true false"),
  otherConsts: words("null NULL omit"),

  visibilityModifiers: words("private public friend"),
  templateMatch: words("complement ifpresent subset superset permutation"),
  multiLineStrings: true
}

var wordList = []
function add(obj) {
  if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
    wordList.push(prop);
}
add(parserConfig.keywords);
add(parserConfig.builtin);
add(parserConfig.timerOps);
add(parserConfig.portOps);

var keywords = parserConfig.keywords || {},
    builtin = parserConfig.builtin || {},
    timerOps = parserConfig.timerOps || {},
    portOps  = parserConfig.portOps || {},
    configOps = parserConfig.configOps || {},
    verdictOps = parserConfig.verdictOps || {},
    sutOps = parserConfig.sutOps || {},
    functionOps = parserConfig.functionOps || {},

    verdictConsts = parserConfig.verdictConsts || {},
    booleanConsts = parserConfig.booleanConsts || {},
    otherConsts   = parserConfig.otherConsts || {},

    types = parserConfig.types || {},
    visibilityModifiers = parserConfig.visibilityModifiers || {},
    templateMatch = parserConfig.templateMatch || {},
    multiLineStrings = parserConfig.multiLineStrings,
    indentStatements = parserConfig.indentStatements !== false;
var isOperatorChar = /[+\-*&@=<>!\/]/;
var curPunc;

function tokenBase(stream, state) {
  var ch = stream.next();

  if (ch == '"' || ch == "'") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }
  if (/[\[\]{}\(\),;\\:\?\.]/.test(ch)) {
    curPunc = ch;
    return "punctuation";
  }
  if (ch == "#"){
    stream.skipToEnd();
    return "atom";
  }
  if (ch == "%"){
    stream.eatWhile(/\b/);
    return "atom";
  }
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\w\.]/);
    return "number";
  }
  if (ch == "/") {
    if (stream.eat("*")) {
      state.tokenize = tokenComment;
      return tokenComment(stream, state);
    }
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
  }
  if (isOperatorChar.test(ch)) {
    if(ch == "@"){
      if(stream.match("try") || stream.match("catch")
         || stream.match("lazy")){
        return "keyword";
      }
    }
    stream.eatWhile(isOperatorChar);
    return "operator";
  }
  stream.eatWhile(/[\w\$_\xa1-\uffff]/);
  var cur = stream.current();

  if (keywords.propertyIsEnumerable(cur)) return "keyword";
  if (builtin.propertyIsEnumerable(cur)) return "builtin";

  if (timerOps.propertyIsEnumerable(cur)) return "def";
  if (configOps.propertyIsEnumerable(cur)) return "def";
  if (verdictOps.propertyIsEnumerable(cur)) return "def";
  if (portOps.propertyIsEnumerable(cur)) return "def";
  if (sutOps.propertyIsEnumerable(cur)) return "def";
  if (functionOps.propertyIsEnumerable(cur)) return "def";

  if (verdictConsts.propertyIsEnumerable(cur)) return "string";
  if (booleanConsts.propertyIsEnumerable(cur)) return "string";
  if (otherConsts.propertyIsEnumerable(cur)) return "string";

  if (types.propertyIsEnumerable(cur)) return "typeName.standard";
  if (visibilityModifiers.propertyIsEnumerable(cur))
    return "modifier";
  if (templateMatch.propertyIsEnumerable(cur)) return "atom";

  return "variable";
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped){
        var afterQuote = stream.peek();
        //look if the character after the quote is like the B in '10100010'B
        if (afterQuote){
          afterQuote = afterQuote.toLowerCase();
          if(afterQuote == "b" || afterQuote == "h" || afterQuote == "o")
            stream.next();
        }
        end = true; break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end || !(escaped || multiLineStrings))
      state.tokenize = null;
    return "string";
  };
}

function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == "/" && maybeEnd) {
      state.tokenize = null;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function Context(indented, column, type, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.align = align;
  this.prev = prev;
}

function pushContext(state, col, type) {
  var indent = state.indented;
  if (state.context && state.context.type == "statement")
    indent = state.context.indented;
  return state.context = new Context(indent, col, type, null, state.context);
}

function popContext(state) {
  var t = state.context.type;
  if (t == ")" || t == "]" || t == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

//Interface
const ttcn = {
  startState: function() {
    return {
      tokenize: null,
      context: new Context(0, 0, "top", false),
      indented: 0,
      startOfLine: true
    };
  },

  token: function(stream, state) {
    var ctx = state.context;
    if (stream.sol()) {
      if (ctx.align == null) ctx.align = false;
      state.indented = stream.indentation();
      state.startOfLine = true;
    }
    if (stream.eatSpace()) return null;
    curPunc = null;
    var style = (state.tokenize || tokenBase)(stream, state);
    if (style == "comment") return style;
    if (ctx.align == null) ctx.align = true;

    if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
        && ctx.type == "statement"){
      popContext(state);
    }
    else if (curPunc == "{") pushContext(state, stream.column(), "}");
    else if (curPunc == "[") pushContext(state, stream.column(), "]");
    else if (curPunc == "(") pushContext(state, stream.column(), ")");
    else if (curPunc == "}") {
      while (ctx.type == "statement") ctx = popContext(state);
      if (ctx.type == "}") ctx = popContext(state);
      while (ctx.type == "statement") ctx = popContext(state);
    }
    else if (curPunc == ctx.type) popContext(state);
    else if (indentStatements &&
             (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
              (ctx.type == "statement" && curPunc == "newstatement")))
      pushContext(state, stream.column(), "statement");

    state.startOfLine = false;

    return style;
  },

  languageData: {
    indentOnInput: /^\s*[{}]$/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
    autocomplete: wordList
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfdHRjbl9qcy40Y2IxOWVhODYwYWJiMjExZTA4OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLHlDQUF5QztBQUN6Qyw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLHNDQUFzQztBQUN0QyxnREFBZ0Q7O0FBRWhELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsa0RBQWtEOztBQUVsRCxvQ0FBb0M7QUFDcEMsZ0VBQWdFO0FBQ2hFLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDO0FBQ25FO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0NBQXdDO0FBQ3RFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQixvQkFBb0IseUJBQXlCO0FBQ2pFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdHRjbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBwYXJzZXJDb25maWcgPSB7XG4gIG5hbWU6IFwidHRjblwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJhY3RpdmF0ZSBhZGRyZXNzIGFsaXZlIGFsbCBhbHQgYWx0c3RlcCBhbmQgYW5kNGIgYW55XCIgK1xuICAgICAgICAgICAgICAgICAgXCIgYnJlYWsgY2FzZSBjb21wb25lbnQgY29uc3QgY29udGludWUgY29udHJvbCBkZWFjdGl2YXRlXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgZGlzcGxheSBkbyBlbHNlIGVuY29kZSBlbnVtZXJhdGVkIGV4Y2VwdCBleGNlcHRpb25cIiArXG4gICAgICAgICAgICAgICAgICBcIiBleGVjdXRlIGV4dGVuZHMgZXh0ZW5zaW9uIGV4dGVybmFsIGZvciBmcm9tIGZ1bmN0aW9uXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgZ290byBncm91cCBpZiBpbXBvcnQgaW4gaW5maW5pdHkgaW5vdXQgaW50ZXJsZWF2ZVwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGxhYmVsIGxhbmd1YWdlIGxlbmd0aCBsb2cgbWF0Y2ggbWVzc2FnZSBtaXhlZCBtb2RcIiArXG4gICAgICAgICAgICAgICAgICBcIiBtb2RpZmllcyBtb2R1bGUgbW9kdWxlcGFyIG10YyBub2Jsb2NrIG5vdCBub3Q0YiBub3dhaXRcIiArXG4gICAgICAgICAgICAgICAgICBcIiBvZiBvbiBvcHRpb25hbCBvciBvcjRiIG91dCBvdmVycmlkZSBwYXJhbSBwYXR0ZXJuIHBvcnRcIiArXG4gICAgICAgICAgICAgICAgICBcIiBwcm9jZWR1cmUgcmVjb3JkIHJlY3Vyc2l2ZSByZW0gcmVwZWF0IHJldHVybiBydW5zIHNlbGVjdFwiICtcbiAgICAgICAgICAgICAgICAgIFwiIHNlbGYgc2VuZGVyIHNldCBzaWduYXR1cmUgc3lzdGVtIHRlbXBsYXRlIHRlc3RjYXNlIHRvXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgdHlwZSB1bmlvbiB2YWx1ZSB2YWx1ZW9mIHZhciB2YXJpYW50IHdoaWxlIHdpdGggeG9yIHhvcjRiXCIpLFxuICBidWlsdGluOiB3b3JkcyhcImJpdDJoZXggYml0MmludCBiaXQyb2N0IGJpdDJzdHIgY2hhcjJpbnQgY2hhcjJvY3QgZW5jdmFsdWVcIiArXG4gICAgICAgICAgICAgICAgIFwiIGRlY29tcCBkZWN2YWx1ZSBmbG9hdDJpbnQgZmxvYXQyc3RyIGhleDJiaXQgaGV4MmludFwiICtcbiAgICAgICAgICAgICAgICAgXCIgaGV4Mm9jdCBoZXgyc3RyIGludDJiaXQgaW50MmNoYXIgaW50MmZsb2F0IGludDJoZXhcIiArXG4gICAgICAgICAgICAgICAgIFwiIGludDJvY3QgaW50MnN0ciBpbnQydW5pY2hhciBpc2JvdW5kIGlzY2hvc2VuIGlzcHJlc2VudFwiICtcbiAgICAgICAgICAgICAgICAgXCIgaXN2YWx1ZSBsZW5ndGhvZiBsb2cyc3RyIG9jdDJiaXQgb2N0MmNoYXIgb2N0MmhleCBvY3QyaW50XCIgK1xuICAgICAgICAgICAgICAgICBcIiBvY3Qyc3RyIHJlZ2V4cCByZXBsYWNlIHJuZCBzaXplb2Ygc3RyMmJpdCBzdHIyZmxvYXRcIiArXG4gICAgICAgICAgICAgICAgIFwiIHN0cjJoZXggc3RyMmludCBzdHIyb2N0IHN1YnN0ciB1bmljaGFyMmludCB1bmljaGFyMmNoYXJcIiArXG4gICAgICAgICAgICAgICAgIFwiIGVudW0yaW50XCIpLFxuICB0eXBlczogd29yZHMoXCJhbnl0eXBlIGJpdHN0cmluZyBib29sZWFuIGNoYXIgY2hhcnN0cmluZyBkZWZhdWx0IGZsb2F0XCIgK1xuICAgICAgICAgICAgICAgXCIgaGV4c3RyaW5nIGludGVnZXIgb2JqaWQgb2N0ZXRzdHJpbmcgdW5pdmVyc2FsIHZlcmRpY3R0eXBlIHRpbWVyXCIpLFxuICB0aW1lck9wczogd29yZHMoXCJyZWFkIHJ1bm5pbmcgc3RhcnQgc3RvcCB0aW1lb3V0XCIpLFxuICBwb3J0T3BzOiB3b3JkcyhcImNhbGwgY2F0Y2ggY2hlY2sgY2xlYXIgZ2V0Y2FsbCBnZXRyZXBseSBoYWx0IHJhaXNlIHJlY2VpdmVcIiArXG4gICAgICAgICAgICAgICAgIFwiIHJlcGx5IHNlbmQgdHJpZ2dlclwiKSxcbiAgY29uZmlnT3BzOiB3b3JkcyhcImNyZWF0ZSBjb25uZWN0IGRpc2Nvbm5lY3QgZG9uZSBraWxsIGtpbGxlZCBtYXAgdW5tYXBcIiksXG4gIHZlcmRpY3RPcHM6IHdvcmRzKFwiZ2V0dmVyZGljdCBzZXR2ZXJkaWN0XCIpLFxuICBzdXRPcHM6IHdvcmRzKFwiYWN0aW9uXCIpLFxuICBmdW5jdGlvbk9wczogd29yZHMoXCJhcHBseSBkZXJlZmVycyByZWZlcnNcIiksXG5cbiAgdmVyZGljdENvbnN0czogd29yZHMoXCJlcnJvciBmYWlsIGluY29uYyBub25lIHBhc3NcIiksXG4gIGJvb2xlYW5Db25zdHM6IHdvcmRzKFwidHJ1ZSBmYWxzZVwiKSxcbiAgb3RoZXJDb25zdHM6IHdvcmRzKFwibnVsbCBOVUxMIG9taXRcIiksXG5cbiAgdmlzaWJpbGl0eU1vZGlmaWVyczogd29yZHMoXCJwcml2YXRlIHB1YmxpYyBmcmllbmRcIiksXG4gIHRlbXBsYXRlTWF0Y2g6IHdvcmRzKFwiY29tcGxlbWVudCBpZnByZXNlbnQgc3Vic2V0IHN1cGVyc2V0IHBlcm11dGF0aW9uXCIpLFxuICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlXG59XG5cbnZhciB3b3JkTGlzdCA9IFtdXG5mdW5jdGlvbiBhZGQob2JqKSB7XG4gIGlmIChvYmopIGZvciAodmFyIHByb3AgaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgIHdvcmRMaXN0LnB1c2gocHJvcCk7XG59XG5hZGQocGFyc2VyQ29uZmlnLmtleXdvcmRzKTtcbmFkZChwYXJzZXJDb25maWcuYnVpbHRpbik7XG5hZGQocGFyc2VyQ29uZmlnLnRpbWVyT3BzKTtcbmFkZChwYXJzZXJDb25maWcucG9ydE9wcyk7XG5cbnZhciBrZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5rZXl3b3JkcyB8fCB7fSxcbiAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgdGltZXJPcHMgPSBwYXJzZXJDb25maWcudGltZXJPcHMgfHwge30sXG4gICAgcG9ydE9wcyAgPSBwYXJzZXJDb25maWcucG9ydE9wcyB8fCB7fSxcbiAgICBjb25maWdPcHMgPSBwYXJzZXJDb25maWcuY29uZmlnT3BzIHx8IHt9LFxuICAgIHZlcmRpY3RPcHMgPSBwYXJzZXJDb25maWcudmVyZGljdE9wcyB8fCB7fSxcbiAgICBzdXRPcHMgPSBwYXJzZXJDb25maWcuc3V0T3BzIHx8IHt9LFxuICAgIGZ1bmN0aW9uT3BzID0gcGFyc2VyQ29uZmlnLmZ1bmN0aW9uT3BzIHx8IHt9LFxuXG4gICAgdmVyZGljdENvbnN0cyA9IHBhcnNlckNvbmZpZy52ZXJkaWN0Q29uc3RzIHx8IHt9LFxuICAgIGJvb2xlYW5Db25zdHMgPSBwYXJzZXJDb25maWcuYm9vbGVhbkNvbnN0cyB8fCB7fSxcbiAgICBvdGhlckNvbnN0cyAgID0gcGFyc2VyQ29uZmlnLm90aGVyQ29uc3RzIHx8IHt9LFxuXG4gICAgdHlwZXMgPSBwYXJzZXJDb25maWcudHlwZXMgfHwge30sXG4gICAgdmlzaWJpbGl0eU1vZGlmaWVycyA9IHBhcnNlckNvbmZpZy52aXNpYmlsaXR5TW9kaWZpZXJzIHx8IHt9LFxuICAgIHRlbXBsYXRlTWF0Y2ggPSBwYXJzZXJDb25maWcudGVtcGxhdGVNYXRjaCB8fCB7fSxcbiAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgaW5kZW50U3RhdGVtZW50cyA9IHBhcnNlckNvbmZpZy5pbmRlbnRTdGF0ZW1lbnRzICE9PSBmYWxzZTtcbnZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomQD08PiFcXC9dLztcbnZhciBjdXJQdW5jO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXFxcOlxcP1xcLl0vLnRlc3QoY2gpKSB7XG4gICAgY3VyUHVuYyA9IGNoO1xuICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gIH1cbiAgaWYgKGNoID09IFwiI1wiKXtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiYXRvbVwiO1xuICB9XG4gIGlmIChjaCA9PSBcIiVcIil7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9cXGIvKTtcbiAgICByZXR1cm4gXCJhdG9tXCI7XG4gIH1cbiAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9XG4gIGlmIChjaCA9PSBcIi9cIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgaWYoY2ggPT0gXCJAXCIpe1xuICAgICAgaWYoc3RyZWFtLm1hdGNoKFwidHJ5XCIpIHx8IHN0cmVhbS5tYXRjaChcImNhdGNoXCIpXG4gICAgICAgICB8fCBzdHJlYW0ubWF0Y2goXCJsYXp5XCIpKXtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX1xceGExLVxcdWZmZmZdLyk7XG4gIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIGlmIChidWlsdGluLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImJ1aWx0aW5cIjtcblxuICBpZiAodGltZXJPcHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiZGVmXCI7XG4gIGlmIChjb25maWdPcHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiZGVmXCI7XG4gIGlmICh2ZXJkaWN0T3BzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImRlZlwiO1xuICBpZiAocG9ydE9wcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJkZWZcIjtcbiAgaWYgKHN1dE9wcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJkZWZcIjtcbiAgaWYgKGZ1bmN0aW9uT3BzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImRlZlwiO1xuXG4gIGlmICh2ZXJkaWN0Q29uc3RzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcInN0cmluZ1wiO1xuICBpZiAoYm9vbGVhbkNvbnN0cy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJzdHJpbmdcIjtcbiAgaWYgKG90aGVyQ29uc3RzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcInN0cmluZ1wiO1xuXG4gIGlmICh0eXBlcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJ0eXBlTmFtZS5zdGFuZGFyZFwiO1xuICBpZiAodmlzaWJpbGl0eU1vZGlmaWVycy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKVxuICAgIHJldHVybiBcIm1vZGlmaWVyXCI7XG4gIGlmICh0ZW1wbGF0ZU1hdGNoLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b21cIjtcblxuICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKXtcbiAgICAgICAgdmFyIGFmdGVyUXVvdGUgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICAvL2xvb2sgaWYgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgcXVvdGUgaXMgbGlrZSB0aGUgQiBpbiAnMTAxMDAwMTAnQlxuICAgICAgICBpZiAoYWZ0ZXJRdW90ZSl7XG4gICAgICAgICAgYWZ0ZXJRdW90ZSA9IGFmdGVyUXVvdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZihhZnRlclF1b3RlID09IFwiYlwiIHx8IGFmdGVyUXVvdGUgPT0gXCJoXCIgfHwgYWZ0ZXJRdW90ZSA9PSBcIm9cIilcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kID0gdHJ1ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlKSB7XG4gIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwic3RhdGVtZW50XCIpXG4gICAgaW5kZW50ID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xufVxuXG4vL0ludGVyZmFjZVxuZXhwb3J0IGNvbnN0IHR0Y24gPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KDAsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgIGluZGVudGVkOiAwLFxuICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgY3VyUHVuYyA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiKSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIgfHwgY3VyUHVuYyA9PSBcIixcIilcbiAgICAgICAgJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIil7XG4gICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgZWxzZSBpZiAoaW5kZW50U3RhdGVtZW50cyAmJlxuICAgICAgICAgICAgICgoKGN0eC50eXBlID09IFwifVwiIHx8IGN0eC50eXBlID09IFwidG9wXCIpICYmIGN1clB1bmMgIT0gJzsnKSB8fFxuICAgICAgICAgICAgICAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKSlcbiAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIpO1xuXG4gICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypbe31dJC8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLy9cIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fSxcbiAgICBhdXRvY29tcGxldGU6IHdvcmRMaXN0XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=