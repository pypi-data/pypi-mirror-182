"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_dylan_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/dylan.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/dylan.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dylan": () => (/* binding */ dylan)
/* harmony export */ });
function forEach(arr, f) {
  for (var i = 0; i < arr.length; i++) f(arr[i], i)
}
function some(arr, f) {
  for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
  return false
}

// Words
var words = {
  // Words that introduce unnamed definitions like "define interface"
  unnamedDefinition: ["interface"],

  // Words that introduce simple named definitions like "define library"
  namedDefinition: ["module", "library", "macro",
                    "C-struct", "C-union",
                    "C-function", "C-callable-wrapper"
                   ],

  // Words that introduce type definitions like "define class".
  // These are also parameterized like "define method" and are
  // appended to otherParameterizedDefinitionWords
  typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

  // Words that introduce trickier definitions like "define method".
  // These require special definitions to be added to startExpressions
  otherParameterizedDefinition: ["method", "function",
                                 "C-variable", "C-address"
                                ],

  // Words that introduce module constant definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  constantSimpleDefinition: ["constant"],

  // Words that introduce module variable definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  variableSimpleDefinition: ["variable"],

  // Other words that introduce simple definitions
  // (without implicit bodies).
  otherSimpleDefinition: ["generic", "domain",
                          "C-pointer-type",
                          "table"
                         ],

  // Words that begin statements with implicit bodies.
  statement: ["if", "block", "begin", "method", "case",
              "for", "select", "when", "unless", "until",
              "while", "iterate", "profiling", "dynamic-bind"
             ],

  // Patterns that act as separators in compound statements.
  // This may include any general pattern that must be indented
  // specially.
  separator: ["finally", "exception", "cleanup", "else",
              "elseif", "afterwards"
             ],

  // Keywords that do not require special indentation handling,
  // but which should be highlighted
  other: ["above", "below", "by", "from", "handler", "in",
          "instance", "let", "local", "otherwise", "slot",
          "subclass", "then", "to", "keyed-by", "virtual"
         ],

  // Condition signaling function calls
  signalingCalls: ["signal", "error", "cerror",
                   "break", "check-type", "abort"
                  ]
};

words["otherDefinition"] =
  words["unnamedDefinition"]
  .concat(words["namedDefinition"])
  .concat(words["otherParameterizedDefinition"]);

words["definition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherDefinition"]);

words["parameterizedDefinition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherParameterizedDefinition"]);

words["simpleDefinition"] =
  words["constantSimpleDefinition"]
  .concat(words["variableSimpleDefinition"])
  .concat(words["otherSimpleDefinition"]);

words["keyword"] =
  words["statement"]
  .concat(words["separator"])
  .concat(words["other"]);

// Patterns
var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
var symbol = new RegExp("^" + symbolPattern);
var patterns = {
  // Symbols with special syntax
  symbolKeyword: symbolPattern + ":",
  symbolClass: "<" + symbolPattern + ">",
  symbolGlobal: "\\*" + symbolPattern + "\\*",
  symbolConstant: "\\$" + symbolPattern
};
var patternStyles = {
  symbolKeyword: "atom",
  symbolClass: "tag",
  symbolGlobal: "variableName.standard",
  symbolConstant: "variableName.constant"
};

// Compile all patterns to regular expressions
for (var patternName in patterns)
  if (patterns.hasOwnProperty(patternName))
    patterns[patternName] = new RegExp("^" + patterns[patternName]);

// Names beginning "with-" and "without-" are commonly
// used as statement macro
patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

var styles = {};
styles["keyword"] = "keyword";
styles["definition"] = "def";
styles["simpleDefinition"] = "def";
styles["signalingCalls"] = "builtin";

// protected words lookup table
var wordLookup = {};
var styleLookup = {};

forEach([
  "keyword",
  "definition",
  "simpleDefinition",
  "signalingCalls"
], function(type) {
  forEach(words[type], function(word) {
    wordLookup[word] = type;
    styleLookup[word] = styles[type];
  });
});


function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

function tokenBase(stream, state) {
  // String
  var ch = stream.peek();
  if (ch == "'" || ch == '"') {
    stream.next();
    return chain(stream, state, tokenString(ch, "string"));
  }
  // Comment
  else if (ch == "/") {
    stream.next();
    if (stream.eat("*")) {
      return chain(stream, state, tokenComment);
    } else if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
    stream.backUp(1);
  }
  // Decimal
  else if (/[+\-\d\.]/.test(ch)) {
    if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
        stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
        stream.match(/^[+-]?\d+/)) {
      return "number";
    }
  }
  // Hash
  else if (ch == "#") {
    stream.next();
    // Symbol with string syntax
    ch = stream.peek();
    if (ch == '"') {
      stream.next();
      return chain(stream, state, tokenString('"', "string"));
    }
    // Binary number
    else if (ch == "b") {
      stream.next();
      stream.eatWhile(/[01]/);
      return "number";
    }
    // Hex number
    else if (ch == "x") {
      stream.next();
      stream.eatWhile(/[\da-f]/i);
      return "number";
    }
    // Octal number
    else if (ch == "o") {
      stream.next();
      stream.eatWhile(/[0-7]/);
      return "number";
    }
    // Token concatenation in macros
    else if (ch == '#') {
      stream.next();
      return "punctuation";
    }
    // Sequence literals
    else if ((ch == '[') || (ch == '(')) {
      stream.next();
      return "bracket";
      // Hash symbol
    } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
      return "atom";
    } else {
      stream.eatWhile(/[-a-zA-Z]/);
      return "error";
    }
  } else if (ch == "~") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      ch = stream.peek();
      if (ch == "=") {
        stream.next();
        return "operator";
      }
      return "operator";
    }
    return "operator";
  } else if (ch == ":") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      return "operator";
    } else if (ch == ":") {
      stream.next();
      return "punctuation";
    }
  } else if ("[](){}".indexOf(ch) != -1) {
    stream.next();
    return "bracket";
  } else if (".,".indexOf(ch) != -1) {
    stream.next();
    return "punctuation";
  } else if (stream.match("end")) {
    return "keyword";
  }
  for (var name in patterns) {
    if (patterns.hasOwnProperty(name)) {
      var pattern = patterns[name];
      if ((pattern instanceof Array && some(pattern, function(p) {
        return stream.match(p);
      })) || stream.match(pattern))
        return patternStyles[name];
    }
  }
  if (/[+\-*\/^=<>&|]/.test(ch)) {
    stream.next();
    return "operator";
  }
  if (stream.match("define")) {
    return "def";
  } else {
    stream.eatWhile(/[\w\-]/);
    // Keyword
    if (wordLookup.hasOwnProperty(stream.current())) {
      return styleLookup[stream.current()];
    } else if (stream.current().match(symbol)) {
      return "variable";
    } else {
      stream.next();
      return "variableName.standard";
    }
  }
}

function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while ((ch = stream.next())) {
    if (ch == "/" && maybeEnd) {
      if (nestedCount > 0) {
        nestedCount--;
      } else {
        state.tokenize = tokenBase;
        break;
      }
    } else if (ch == "*" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == "*");
    maybeNested = (ch == "/");
  }
  return "comment";
}

function tokenString(quote, style) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end || !escaped) {
      state.tokenize = tokenBase;
    }
    return style;
  };
}

// Interface
const dylan = {
  startState: function() {
    return {
      tokenize: tokenBase,
      currentIndent: 0
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace())
      return null;
    var style = state.tokenize(stream, state);
    return style;
  },
  languageData: {
    commentTokens: {block: {open: "/*", close: "*/"}}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZHlsYW5fanMuNmQ4OWQ5Y2JkZTMyZTcwYmZkNWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZHlsYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZm9yRWFjaChhcnIsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGYoYXJyW2ldLCBpKVxufVxuZnVuY3Rpb24gc29tZShhcnIsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGlmIChmKGFycltpXSwgaSkpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBXb3Jkc1xudmFyIHdvcmRzID0ge1xuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSB1bm5hbWVkIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgaW50ZXJmYWNlXCJcbiAgdW5uYW1lZERlZmluaXRpb246IFtcImludGVyZmFjZVwiXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSBzaW1wbGUgbmFtZWQgZGVmaW5pdGlvbnMgbGlrZSBcImRlZmluZSBsaWJyYXJ5XCJcbiAgbmFtZWREZWZpbml0aW9uOiBbXCJtb2R1bGVcIiwgXCJsaWJyYXJ5XCIsIFwibWFjcm9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDLXN0cnVjdFwiLCBcIkMtdW5pb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDLWZ1bmN0aW9uXCIsIFwiQy1jYWxsYWJsZS13cmFwcGVyXCJcbiAgICAgICAgICAgICAgICAgICBdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHR5cGUgZGVmaW5pdGlvbnMgbGlrZSBcImRlZmluZSBjbGFzc1wiLlxuICAvLyBUaGVzZSBhcmUgYWxzbyBwYXJhbWV0ZXJpemVkIGxpa2UgXCJkZWZpbmUgbWV0aG9kXCIgYW5kIGFyZVxuICAvLyBhcHBlbmRlZCB0byBvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uV29yZHNcbiAgdHlwZVBhcmFtZXRlcml6ZWREZWZpbml0aW9uOiBbXCJjbGFzc1wiLCBcIkMtc3VidHlwZVwiLCBcIkMtbWFwcGVkLXN1YnR5cGVcIl0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgdHJpY2tpZXIgZGVmaW5pdGlvbnMgbGlrZSBcImRlZmluZSBtZXRob2RcIi5cbiAgLy8gVGhlc2UgcmVxdWlyZSBzcGVjaWFsIGRlZmluaXRpb25zIHRvIGJlIGFkZGVkIHRvIHN0YXJ0RXhwcmVzc2lvbnNcbiAgb3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbjogW1wibWV0aG9kXCIsIFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQy12YXJpYWJsZVwiLCBcIkMtYWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgbW9kdWxlIGNvbnN0YW50IGRlZmluaXRpb25zLlxuICAvLyBUaGVzZSBtdXN0IGFsc28gYmUgc2ltcGxlIGRlZmluaXRpb25zIGFuZCBhcmVcbiAgLy8gYXBwZW5kZWQgdG8gb3RoZXJTaW1wbGVEZWZpbml0aW9uV29yZHNcbiAgY29uc3RhbnRTaW1wbGVEZWZpbml0aW9uOiBbXCJjb25zdGFudFwiXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSBtb2R1bGUgdmFyaWFibGUgZGVmaW5pdGlvbnMuXG4gIC8vIFRoZXNlIG11c3QgYWxzbyBiZSBzaW1wbGUgZGVmaW5pdGlvbnMgYW5kIGFyZVxuICAvLyBhcHBlbmRlZCB0byBvdGhlclNpbXBsZURlZmluaXRpb25Xb3Jkc1xuICB2YXJpYWJsZVNpbXBsZURlZmluaXRpb246IFtcInZhcmlhYmxlXCJdLFxuXG4gIC8vIE90aGVyIHdvcmRzIHRoYXQgaW50cm9kdWNlIHNpbXBsZSBkZWZpbml0aW9uc1xuICAvLyAod2l0aG91dCBpbXBsaWNpdCBib2RpZXMpLlxuICBvdGhlclNpbXBsZURlZmluaXRpb246IFtcImdlbmVyaWNcIiwgXCJkb21haW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDLXBvaW50ZXItdHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuXG4gIC8vIFdvcmRzIHRoYXQgYmVnaW4gc3RhdGVtZW50cyB3aXRoIGltcGxpY2l0IGJvZGllcy5cbiAgc3RhdGVtZW50OiBbXCJpZlwiLCBcImJsb2NrXCIsIFwiYmVnaW5cIiwgXCJtZXRob2RcIiwgXCJjYXNlXCIsXG4gICAgICAgICAgICAgIFwiZm9yXCIsIFwic2VsZWN0XCIsIFwid2hlblwiLCBcInVubGVzc1wiLCBcInVudGlsXCIsXG4gICAgICAgICAgICAgIFwid2hpbGVcIiwgXCJpdGVyYXRlXCIsIFwicHJvZmlsaW5nXCIsIFwiZHluYW1pYy1iaW5kXCJcbiAgICAgICAgICAgICBdLFxuXG4gIC8vIFBhdHRlcm5zIHRoYXQgYWN0IGFzIHNlcGFyYXRvcnMgaW4gY29tcG91bmQgc3RhdGVtZW50cy5cbiAgLy8gVGhpcyBtYXkgaW5jbHVkZSBhbnkgZ2VuZXJhbCBwYXR0ZXJuIHRoYXQgbXVzdCBiZSBpbmRlbnRlZFxuICAvLyBzcGVjaWFsbHkuXG4gIHNlcGFyYXRvcjogW1wiZmluYWxseVwiLCBcImV4Y2VwdGlvblwiLCBcImNsZWFudXBcIiwgXCJlbHNlXCIsXG4gICAgICAgICAgICAgIFwiZWxzZWlmXCIsIFwiYWZ0ZXJ3YXJkc1wiXG4gICAgICAgICAgICAgXSxcblxuICAvLyBLZXl3b3JkcyB0aGF0IGRvIG5vdCByZXF1aXJlIHNwZWNpYWwgaW5kZW50YXRpb24gaGFuZGxpbmcsXG4gIC8vIGJ1dCB3aGljaCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWRcbiAgb3RoZXI6IFtcImFib3ZlXCIsIFwiYmVsb3dcIiwgXCJieVwiLCBcImZyb21cIiwgXCJoYW5kbGVyXCIsIFwiaW5cIixcbiAgICAgICAgICBcImluc3RhbmNlXCIsIFwibGV0XCIsIFwibG9jYWxcIiwgXCJvdGhlcndpc2VcIiwgXCJzbG90XCIsXG4gICAgICAgICAgXCJzdWJjbGFzc1wiLCBcInRoZW5cIiwgXCJ0b1wiLCBcImtleWVkLWJ5XCIsIFwidmlydHVhbFwiXG4gICAgICAgICBdLFxuXG4gIC8vIENvbmRpdGlvbiBzaWduYWxpbmcgZnVuY3Rpb24gY2FsbHNcbiAgc2lnbmFsaW5nQ2FsbHM6IFtcInNpZ25hbFwiLCBcImVycm9yXCIsIFwiY2Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgXCJicmVha1wiLCBcImNoZWNrLXR5cGVcIiwgXCJhYm9ydFwiXG4gICAgICAgICAgICAgICAgICBdXG59O1xuXG53b3Jkc1tcIm90aGVyRGVmaW5pdGlvblwiXSA9XG4gIHdvcmRzW1widW5uYW1lZERlZmluaXRpb25cIl1cbiAgLmNvbmNhdCh3b3Jkc1tcIm5hbWVkRGVmaW5pdGlvblwiXSlcbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl0pO1xuXG53b3Jkc1tcImRlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcInR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJEZWZpbml0aW9uXCJdKTtcblxud29yZHNbXCJwYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXSA9XG4gIHdvcmRzW1widHlwZVBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdKTtcblxud29yZHNbXCJzaW1wbGVEZWZpbml0aW9uXCJdID1cbiAgd29yZHNbXCJjb25zdGFudFNpbXBsZURlZmluaXRpb25cIl1cbiAgLmNvbmNhdCh3b3Jkc1tcInZhcmlhYmxlU2ltcGxlRGVmaW5pdGlvblwiXSlcbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyU2ltcGxlRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wia2V5d29yZFwiXSA9XG4gIHdvcmRzW1wic3RhdGVtZW50XCJdXG4gIC5jb25jYXQod29yZHNbXCJzZXBhcmF0b3JcIl0pXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclwiXSk7XG5cbi8vIFBhdHRlcm5zXG52YXIgc3ltYm9sUGF0dGVybiA9IFwiWy1fYS16QS1aPyEqQDw+JCVdK1wiO1xudmFyIHN5bWJvbCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzeW1ib2xQYXR0ZXJuKTtcbnZhciBwYXR0ZXJucyA9IHtcbiAgLy8gU3ltYm9scyB3aXRoIHNwZWNpYWwgc3ludGF4XG4gIHN5bWJvbEtleXdvcmQ6IHN5bWJvbFBhdHRlcm4gKyBcIjpcIixcbiAgc3ltYm9sQ2xhc3M6IFwiPFwiICsgc3ltYm9sUGF0dGVybiArIFwiPlwiLFxuICBzeW1ib2xHbG9iYWw6IFwiXFxcXCpcIiArIHN5bWJvbFBhdHRlcm4gKyBcIlxcXFwqXCIsXG4gIHN5bWJvbENvbnN0YW50OiBcIlxcXFwkXCIgKyBzeW1ib2xQYXR0ZXJuXG59O1xudmFyIHBhdHRlcm5TdHlsZXMgPSB7XG4gIHN5bWJvbEtleXdvcmQ6IFwiYXRvbVwiLFxuICBzeW1ib2xDbGFzczogXCJ0YWdcIixcbiAgc3ltYm9sR2xvYmFsOiBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiLFxuICBzeW1ib2xDb25zdGFudDogXCJ2YXJpYWJsZU5hbWUuY29uc3RhbnRcIlxufTtcblxuLy8gQ29tcGlsZSBhbGwgcGF0dGVybnMgdG8gcmVndWxhciBleHByZXNzaW9uc1xuZm9yICh2YXIgcGF0dGVybk5hbWUgaW4gcGF0dGVybnMpXG4gIGlmIChwYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShwYXR0ZXJuTmFtZSkpXG4gICAgcGF0dGVybnNbcGF0dGVybk5hbWVdID0gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm5zW3BhdHRlcm5OYW1lXSk7XG5cbi8vIE5hbWVzIGJlZ2lubmluZyBcIndpdGgtXCIgYW5kIFwid2l0aG91dC1cIiBhcmUgY29tbW9ubHlcbi8vIHVzZWQgYXMgc3RhdGVtZW50IG1hY3JvXG5wYXR0ZXJuc1tcImtleXdvcmRcIl0gPSBbL153aXRoKD86b3V0KT8tWy1fYS16QS1aPyEqQDw+JCVdKy9dO1xuXG52YXIgc3R5bGVzID0ge307XG5zdHlsZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG5zdHlsZXNbXCJkZWZpbml0aW9uXCJdID0gXCJkZWZcIjtcbnN0eWxlc1tcInNpbXBsZURlZmluaXRpb25cIl0gPSBcImRlZlwiO1xuc3R5bGVzW1wic2lnbmFsaW5nQ2FsbHNcIl0gPSBcImJ1aWx0aW5cIjtcblxuLy8gcHJvdGVjdGVkIHdvcmRzIGxvb2t1cCB0YWJsZVxudmFyIHdvcmRMb29rdXAgPSB7fTtcbnZhciBzdHlsZUxvb2t1cCA9IHt9O1xuXG5mb3JFYWNoKFtcbiAgXCJrZXl3b3JkXCIsXG4gIFwiZGVmaW5pdGlvblwiLFxuICBcInNpbXBsZURlZmluaXRpb25cIixcbiAgXCJzaWduYWxpbmdDYWxsc1wiXG5dLCBmdW5jdGlvbih0eXBlKSB7XG4gIGZvckVhY2god29yZHNbdHlwZV0sIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICB3b3JkTG9va3VwW3dvcmRdID0gdHlwZTtcbiAgICBzdHlsZUxvb2t1cFt3b3JkXSA9IHN0eWxlc1t0eXBlXTtcbiAgfSk7XG59KTtcblxuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIFN0cmluZ1xuICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICBpZiAoY2ggPT0gXCInXCIgfHwgY2ggPT0gJ1wiJykge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoLCBcInN0cmluZ1wiKSk7XG4gIH1cbiAgLy8gQ29tbWVudFxuICBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5Db21tZW50KTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gIH1cbiAgLy8gRGVjaW1hbFxuICBlbHNlIGlmICgvWytcXC1cXGRcXC5dLy50ZXN0KGNoKSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dP1swLTldKlxcLlswLTldKihbZXNkeF1bKy1dP1swLTldKyk/L2kpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlsrLV0/WzAtOV0rKFtlc2R4XVsrLV0/WzAtOV0rKS9pKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goL15bKy1dP1xcZCsvKSkge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICB9XG4gIC8vIEhhc2hcbiAgZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIC8vIFN5bWJvbCB3aXRoIHN0cmluZyBzeW50YXhcbiAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoJ1wiJywgXCJzdHJpbmdcIikpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkgbnVtYmVyXG4gICAgZWxzZSBpZiAoY2ggPT0gXCJiXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1swMV0vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICAvLyBIZXggbnVtYmVyXG4gICAgZWxzZSBpZiAoY2ggPT0gXCJ4XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIC8vIE9jdGFsIG51bWJlclxuICAgIGVsc2UgaWYgKGNoID09IFwib1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bMC03XS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIC8vIFRva2VuIGNvbmNhdGVuYXRpb24gaW4gbWFjcm9zXG4gICAgZWxzZSBpZiAoY2ggPT0gJyMnKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgICB9XG4gICAgLy8gU2VxdWVuY2UgbGl0ZXJhbHNcbiAgICBlbHNlIGlmICgoY2ggPT0gJ1snKSB8fCAoY2ggPT0gJygnKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgIC8vIEhhc2ggc3ltYm9sXG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL2Z8dHxhbGwta2V5c3xpbmNsdWRlfGtleXxuZXh0fHJlc3QvaSkpIHtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bLWEtekEtWl0vKTtcbiAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoID09IFwiflwiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJbXSgpe31cIi5pbmRleE9mKGNoKSAhPSAtMSkge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICB9IGVsc2UgaWYgKFwiLixcIi5pbmRleE9mKGNoKSAhPSAtMSkge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJlbmRcIikpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBwYXR0ZXJucykge1xuICAgIGlmIChwYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tuYW1lXTtcbiAgICAgIGlmICgocGF0dGVybiBpbnN0YW5jZW9mIEFycmF5ICYmIHNvbWUocGF0dGVybiwgZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKHApO1xuICAgICAgfSkpIHx8IHN0cmVhbS5tYXRjaChwYXR0ZXJuKSlcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5TdHlsZXNbbmFtZV07XG4gICAgfVxuICB9XG4gIGlmICgvWytcXC0qXFwvXj08PiZ8XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaChcImRlZmluZVwiKSkge1xuICAgIHJldHVybiBcImRlZlwiO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLV0vKTtcbiAgICAvLyBLZXl3b3JkXG4gICAgaWYgKHdvcmRMb29rdXAuaGFzT3duUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgIHJldHVybiBzdHlsZUxvb2t1cFtzdHJlYW0uY3VycmVudCgpXTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5jdXJyZW50KCkubWF0Y2goc3ltYm9sKSkge1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgbWF5YmVOZXN0ZWQgPSBmYWxzZSwgbmVzdGVkQ291bnQgPSAwLCBjaDtcbiAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpKSB7XG4gICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICBpZiAobmVzdGVkQ291bnQgPiAwKSB7XG4gICAgICAgIG5lc3RlZENvdW50LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIipcIiAmJiBtYXliZU5lc3RlZCkge1xuICAgICAgbmVzdGVkQ291bnQrKztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIG1heWJlTmVzdGVkID0gKGNoID09IFwiL1wiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlLCBzdHlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIGlmIChlbmQgfHwgIWVzY2FwZWQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0IGNvbnN0IGR5bGFuID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGN1cnJlbnRJbmRlbnQ6IDBcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2Jsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9