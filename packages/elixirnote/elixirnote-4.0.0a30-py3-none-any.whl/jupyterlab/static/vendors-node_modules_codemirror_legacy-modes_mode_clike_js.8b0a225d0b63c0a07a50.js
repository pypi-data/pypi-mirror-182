"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_clike_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/clike.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/clike.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ c),
/* harmony export */   "ceylon": () => (/* binding */ ceylon),
/* harmony export */   "clike": () => (/* binding */ clike),
/* harmony export */   "cpp": () => (/* binding */ cpp),
/* harmony export */   "csharp": () => (/* binding */ csharp),
/* harmony export */   "dart": () => (/* binding */ dart),
/* harmony export */   "java": () => (/* binding */ java),
/* harmony export */   "kotlin": () => (/* binding */ kotlin),
/* harmony export */   "nesC": () => (/* binding */ nesC),
/* harmony export */   "objectiveC": () => (/* binding */ objectiveC),
/* harmony export */   "objectiveCpp": () => (/* binding */ objectiveCpp),
/* harmony export */   "scala": () => (/* binding */ scala),
/* harmony export */   "shader": () => (/* binding */ shader),
/* harmony export */   "squirrel": () => (/* binding */ squirrel)
/* harmony export */ });
function Context(indented, column, type, info, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.info = info;
  this.align = align;
  this.prev = prev;
}
function pushContext(state, col, type, info) {
  var indent = state.indented;
  if (state.context && state.context.type == "statement" && type != "statement")
    indent = state.context.indented;
  return state.context = new Context(indent, col, type, info, null, state.context);
}
function popContext(state) {
  var t = state.context.type;
  if (t == ")" || t == "]" || t == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

function typeBefore(stream, state, pos) {
  if (state.prevToken == "variable" || state.prevToken == "type") return true;
  if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos))) return true;
  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;
}

function isTopScope(context) {
  for (;;) {
    if (!context || context.type == "top") return true;
    if (context.type == "}" && context.prev.info != "namespace") return false;
    context = context.prev;
  }
}

function clike(parserConfig) {
  var statementIndentUnit = parserConfig.statementIndentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      types = parserConfig.types || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      defKeywords = parserConfig.defKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false,
      indentSwitch = parserConfig.indentSwitch !== false,
      namespaceSeparator = parserConfig.namespaceSeparator,
      isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
      numberStart = parserConfig.numberStart || /[\d\.]/,
      number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
      isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
      isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/,
      // An optional function that takes a {string} token and returns true if it
      // should be treated as a builtin.
      isReservedIdentifier = parserConfig.isReservedIdentifier || false;

  var curPunc, isDefKeyword;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (numberStart.test(ch)) {
      stream.backUp(1)
      if (stream.match(number)) return "number"
      stream.next()
    }
    if (isPunctuationChar.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {}
      return "operator";
    }
    stream.eatWhile(isIdentifierChar);
    if (namespaceSeparator) while (stream.match(namespaceSeparator))
      stream.eatWhile(isIdentifierChar);

    var cur = stream.current();
    if (contains(keywords, cur)) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      if (contains(defKeywords, cur)) isDefKeyword = true;
      return "keyword";
    }
    if (contains(types, cur)) return "type";
    if (contains(builtin, cur)
        || (isReservedIdentifier && isReservedIdentifier(cur))) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (contains(atoms, cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function maybeEOL(stream, state) {
    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)
  }

  // Interface

  return {
    startState: function(indentUnit) {
      return {
        tokenize: null,
        context: new Context(-indentUnit, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }
      curPunc = isDefKeyword = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false)))
        while (state.context.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (indentStatements &&
               (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||
                (ctx.type == "statement" && curPunc == "newstatement"))) {
        pushContext(state, stream.column(), "statement", stream.current());
      }

      if (style == "variable" &&
          ((state.prevToken == "def" ||
            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&
             isTopScope(state.context) && stream.match(/^\s*\(/, false)))))
        style = "def";

      if (hooks.token) {
        var result = hooks.token(stream, state, style);
        if (result !== undefined) style = result;
      }

      if (style == "def" && parserConfig.styleDefs === false) style = "variable";

      state.startOfLine = false;
      state.prevToken = isDefKeyword ? "def" : style || curPunc;
      maybeEOL(stream, state);
      return style;
    },

    indent: function(state, textAfter, context) {
      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return null;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      if (parserConfig.dontIndentStatements)
        while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
          ctx = ctx.prev
      if (hooks.indent) {
        var hook = hooks.indent(state, ctx, textAfter, context.unit);
        if (typeof hook == "number") return hook
      }
      var switchBlock = ctx.prev && ctx.prev.info == "switch";
      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
        while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev
        return ctx.indented
      }
      if (ctx.type == "statement")
        return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit || context.unit);
      if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
        return ctx.column + (closing ? 0 : 1);
      if (ctx.type == ")" && !closing)
        return ctx.indented + (statementIndentUnit || context.unit);

      return ctx.indented + (closing ? 0 : context.unit) +
        (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? context.unit : 0);
    },

    languageData: {
      indentOnInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
      autocomplete: Object.keys(keywords).concat(Object.keys(types)).concat(Object.keys(builtin)).concat(Object.keys(atoms)),
      ...parserConfig.languageData
    }
  };
};

function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
function contains(words, word) {
  if (typeof words === "function") {
    return words(word);
  } else {
    return words.propertyIsEnumerable(word);
  }
}
var cKeywords = "auto if break case register continue return default do sizeof " +
    "static else struct switch extern typedef union for goto while enum const " +
    "volatile inline restrict asm fortran";

// Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.
var cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch " +
    "class compl concept constexpr const_cast decltype delete dynamic_cast " +
    "explicit export final friend import module mutable namespace new noexcept " +
    "not not_eq operator or or_eq override private protected public " +
    "reinterpret_cast requires static_assert static_cast template this " +
    "thread_local throw try typeid typename using virtual xor xor_eq";

var objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy " +
    "readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd " +
    "@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class " +
    "@public @package @private @protected @required @optional @try @catch @finally @import " +
    "@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";

var objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION " +
    " NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER " +
    "NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION " +
    "NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT"

// Do not use this. Use the cTypes function below. This is global just to avoid
// excessive calls when cTypes is being called multiple times during a parse.
var basicCTypes = words("int long char short double float unsigned signed " +
                        "void bool");

// Do not use this. Use the objCTypes function below. This is global just to avoid
// excessive calls when objCTypes is being called multiple times during a parse.
var basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");

// Returns true if identifier is a "C" type.
// C type is defined as those that are reserved by the compiler (basicTypes),
// and those that end in _t (Reserved by POSIX for types)
// http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html
function cTypes(identifier) {
  return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);
}

// Returns true if identifier is a "Objective C" type.
function objCTypes(identifier) {
  return cTypes(identifier) || contains(basicObjCTypes, identifier);
}

var cBlockKeywords = "case do else for if switch while struct enum union";
var cDefKeywords = "struct enum union";

function cppHook(stream, state) {
  if (!state.startOfLine) return false
  for (var ch, next = null; ch = stream.peek();) {
    if (ch == "\\" && stream.match(/^.$/)) {
      next = cppHook
      break
    } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
      break
    }
    stream.next()
  }
  state.tokenize = next
  return "meta"
}

function pointerHook(_stream, state) {
  if (state.prevToken == "type") return "type";
  return false;
}

// For C and C++ (and ObjC): identifiers starting with __
// or _ followed by a capital letter are reserved for the compiler.
function cIsReservedIdentifier(token) {
  if (!token || token.length < 2) return false;
  if (token[0] != '_') return false;
  return (token[1] == '_') || (token[1] !== token[1].toLowerCase());
}

function cpp14Literal(stream) {
  stream.eatWhile(/[\w\.']/);
  return "number";
}

function cpp11StringHook(stream, state) {
  stream.backUp(1);
  // Raw strings.
  if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var match = stream.match(/^"([^\s\\()]{0,16})\(/);
    if (!match) {
      return false;
    }
    state.cpp11RawStringDelim = match[1];
    state.tokenize = tokenRawString;
    return tokenRawString(stream, state);
  }
  // Unicode strings/chars.
  if (stream.match(/^(?:u8|u|U|L)/)) {
    if (stream.match(/^["']/, /* eat */ false)) {
      return "string";
    }
    return false;
  }
  // Ignore this hook.
  stream.next();
  return false;
}

function cppLooksLikeConstructor(word) {
  var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
  return lastTwo && lastTwo[1] == lastTwo[2];
}

// C#-style strings where "" escapes a quote.
function tokenAtString(stream, state) {
  var next;
  while ((next = stream.next()) != null) {
    if (next == '"' && !stream.eat('"')) {
      state.tokenize = null;
      break;
    }
  }
  return "string";
}

// C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
// <delim> can be a string up to 16 characters long.
function tokenRawString(stream, state) {
  // Escape characters that have special regex meanings.
  var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
  var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
  if (match)
    state.tokenize = null;
  else
    stream.skipToEnd();
  return "string";
}

const c = clike({
  keywords: words(cKeywords),
  types: cTypes,
  blockKeywords: words(cBlockKeywords),
  defKeywords: words(cDefKeywords),
  typeFirstDefinitions: true,
  atoms: words("NULL true false"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
  }
})

const cpp = clike({
  keywords: words(cKeywords + " " + cppKeywords),
  types: cTypes,
  blockKeywords: words(cBlockKeywords + " class try catch"),
  defKeywords: words(cDefKeywords + " class namespace"),
  typeFirstDefinitions: true,
  atoms: words("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style) {
      if (style == "variable" && stream.peek() == "(" &&
          (state.prevToken == ";" || state.prevToken == null ||
           state.prevToken == "}") &&
          cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});

const java = clike({
  keywords: words("abstract assert break case catch class const continue default " +
                  "do else enum extends final finally for goto if implements import " +
                  "instanceof interface native new package private protected public " +
                  "return static strictfp super switch synchronized this throw throws transient " +
                  "try volatile while @interface"),
  types: words("var byte short int long float double boolean char void Boolean Byte Character Double Float " +
               "Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: words("catch class do else finally for if switch try while"),
  defKeywords: words("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(stream) {
      // Don't match the @interface keyword.
      if (stream.match('interface', false)) return false;

      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match(/""$/)) return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    }
  }
})

const csharp = clike({
  keywords: words("abstract as async await base break case catch checked class const continue" +
                  " default delegate do else enum event explicit extern finally fixed for" +
                  " foreach goto if implicit in interface internal is lock namespace new" +
                  " operator out override params private protected public readonly ref return sealed" +
                  " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                  " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                  " global group into join let orderby partial remove select set value var yield"),
  types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func" +
               " Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32" +
               " UInt64 bool byte char decimal double short int long object"  +
               " sbyte float string ushort uint ulong"),
  blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
  defKeywords: words("class interface namespace struct var"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  hooks: {
    "@": function(stream, state) {
      if (stream.eat('"')) {
        state.tokenize = tokenAtString;
        return tokenAtString(stream, state);
      }
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    }
  }
});

function tokenTripleString(stream, state) {
  var escaped = false;
  while (!stream.eol()) {
    if (!escaped && stream.match('"""')) {
      state.tokenize = null;
      break;
    }
    escaped = stream.next() == "\\" && !escaped;
  }
  return "string";
}

function tokenNestedComment(depth) {
  return function (stream, state) {
    var ch
    while (ch = stream.next()) {
      if (ch == "*" && stream.eat("/")) {
        if (depth == 1) {
          state.tokenize = null
          break
        } else {
          state.tokenize = tokenNestedComment(depth - 1)
          return state.tokenize(stream, state)
        }
      } else if (ch == "/" && stream.eat("*")) {
        state.tokenize = tokenNestedComment(depth + 1)
        return state.tokenize(stream, state)
      }
    }
    return "comment"
  }
}

const scala = clike({
  keywords: words(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try type val var while with yield _ " +

    /* package scala */
    "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble"
  ),
  types: words(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector " +

    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: words("class enum def object package trait type val var"),
  atoms: words("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match('""')) return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    "=": function(stream, state) {
      var cx = state.context
      if (cx.type == "}" && cx.align && stream.eat(">")) {
        state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)
        return "operator"
      } else {
        return false
      }
    },

    "/": function(stream, state) {
      if (!stream.eat("*")) return false
      state.tokenize = tokenNestedComment(1)
      return state.tokenize(stream, state)
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
});

function tokenKotlinString(tripleString){
  return function (stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!tripleString && !escaped && stream.match('"') ) {end = true; break;}
      if (tripleString && stream.match('"""')) {end = true; break;}
      next = stream.next();
      if(!escaped && next == "$" && stream.match('{'))
        stream.skipTo("}");
      escaped = !escaped && next == "\\" && !tripleString;
    }
    if (end || !tripleString)
      state.tokenize = null;
    return "string";
  }
}

const kotlin = clike({
  keywords: words(
    /*keywords*/
    "package as typealias class interface this super val operator " +
      "var fun for is in This throw return annotation " +
      "break continue object if else while do try when !in !is as? " +

    /*soft keywords*/
    "file import where by get set abstract enum open inner override private public internal " +
      "protected catch finally out final vararg reified dynamic companion constructor init " +
      "sealed field property receiver param sparam lateinit data inline noinline tailrec " +
      "external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: words(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray " +
      "ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy " +
      "LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: words("catch class do else finally for if where try while enum"),
  defKeywords: words("class val var object interface fun"),
  atoms: words("true false null this"),
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '*': function(_stream, state) {
      return state.prevToken == '.' ? 'variable' : 'operator';
    },
    '"': function(stream, state) {
      state.tokenize = tokenKotlinString(stream.match('""'));
      return state.tokenize(stream, state);
    },
    "/": function(stream, state) {
      if (!stream.eat("*")) return false;
      state.tokenize = tokenNestedComment(1);
      return state.tokenize(stream, state)
    },
    indent: function(state, ctx, textAfter, indentUnit) {
      var firstChar = textAfter && textAfter.charAt(0);
      if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
        return state.indented;
      if ((state.prevToken == "operator" && textAfter != "}" && state.context.type != "}") ||
          state.prevToken == "variable" && firstChar == "." ||
          (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
        return indentUnit * 2 + ctx.indented;
      if (ctx.align && ctx.type == "}")
        return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
});

const shader = clike({
  keywords: words("sampler1D sampler2D sampler3D samplerCube " +
                  "sampler1DShadow sampler2DShadow " +
                  "const attribute uniform varying " +
                  "break continue discard return " +
                  "for while do if else struct " +
                  "in out inout"),
  types: words("float int bool void " +
               "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
               "mat2 mat3 mat4"),
  blockKeywords: words("for while do if else struct"),
  builtin: words("radians degrees sin cos tan asin acos atan " +
                 "pow exp log exp2 sqrt inversesqrt " +
                 "abs sign floor ceil fract mod min max clamp mix step smoothstep " +
                 "length distance dot cross normalize ftransform faceforward " +
                 "reflect refract matrixCompMult " +
                 "lessThan lessThanEqual greaterThan greaterThanEqual " +
                 "equal notEqual any all not " +
                 "texture1D texture1DProj texture1DLod texture1DProjLod " +
                 "texture2D texture2DProj texture2DLod texture2DProjLod " +
                 "texture3D texture3DProj texture3DLod texture3DProjLod " +
                 "textureCube textureCubeLod " +
                 "shadow1D shadow2D shadow1DProj shadow2DProj " +
                 "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                 "dFdx dFdy fwidth " +
                 "noise1 noise2 noise3 noise4"),
  atoms: words("true false " +
               "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
               "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
               "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
               "gl_FogCoord gl_PointCoord " +
               "gl_Position gl_PointSize gl_ClipVertex " +
               "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
               "gl_TexCoord gl_FogFragCoord " +
               "gl_FragCoord gl_FrontFacing " +
               "gl_FragData gl_FragDepth " +
               "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
               "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
               "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
               "gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
               "gl_ProjectionMatrixInverseTranspose " +
               "gl_ModelViewProjectionMatrixInverseTranspose " +
               "gl_TextureMatrixInverseTranspose " +
               "gl_NormalScale gl_DepthRange gl_ClipPlane " +
               "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
               "gl_FrontLightModelProduct gl_BackLightModelProduct " +
               "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
               "gl_FogParameters " +
               "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
               "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
               "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
               "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
               "gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: {"#": cppHook}
})

const nesC = clike({
  keywords: words(cKeywords + " as atomic async call command component components configuration event generic " +
                  "implementation includes interface module new norace nx_struct nx_union post provides " +
                  "signal task uses abstract extends"),
  types: cTypes,
  blockKeywords: words(cBlockKeywords),
  atoms: words("null true false"),
  hooks: {"#": cppHook}
})

const objectiveC = clike({
  keywords: words(cKeywords + " " + objCKeywords),
  types: objCTypes,
  builtin: words(objCBuiltins),
  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: words("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
  }
})

const objectiveCpp = clike({
  keywords: words(cKeywords + " " + objCKeywords + " " + cppKeywords),
  types: objCTypes,
  builtin: words(objCBuiltins),
  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: words("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style) {
      if (style == "variable" && stream.peek() == "(" &&
          (state.prevToken == ";" || state.prevToken == null ||
           state.prevToken == "}") &&
          cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
})

const squirrel = clike({
  keywords: words("base break clone continue const default delete enum extends function in class" +
                  " foreach local resume return this throw typeof yield constructor instanceof static"),
  types: cTypes,
  blockKeywords: words("case catch class else for foreach if switch try while"),
  defKeywords: words("function local class"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  hooks: {"#": cppHook}
})

// Ceylon Strings need to deal with interpolation
var stringTokenizer = null;
function tokenCeylonString(type) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"') &&
          (type == "single" || stream.match('""'))) {
        end = true;
        break;
      }
      if (!escaped && stream.match('``')) {
        stringTokenizer = tokenCeylonString(type);
        end = true;
        break;
      }
      next = stream.next();
      escaped = type == "single" && !escaped && next == "\\";
    }
    if (end)
      state.tokenize = null;
    return "string";
  }
}

const ceylon = clike({
  keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else" +
                  " exists extends finally for function given if import in interface is let module new" +
                  " nonempty object of out outer package return satisfies super switch then this throw" +
                  " try value void while"),
  types: function(word) {
    // In Ceylon all identifiers that start with an uppercase are types
    var first = word.charAt(0);
    return (first === first.toUpperCase() && first !== first.toLowerCase());
  },
  blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: words("class dynamic function interface module object package value"),
  builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license" +
                 " native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: words("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
      return state.tokenize(stream, state);
    },
    '`': function(stream, state) {
      if (!stringTokenizer || !stream.match('`')) return false;
      state.tokenize = stringTokenizer;
      stringTokenizer = null;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    token: function(_stream, state, style) {
      if ((style == "variable" || style == "type") &&
          state.prevToken == ".") {
        return "variableName.special";
      }
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
})

function pushInterpolationStack(state) {
  (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);
}

function popInterpolationStack(state) {
  return (state.interpolationStack || (state.interpolationStack = [])).pop();
}

function sizeInterpolationStack(state) {
  return state.interpolationStack ? state.interpolationStack.length : 0;
}

function tokenDartString(quote, stream, state, raw) {
  var tripleQuoted = false;
  if (stream.eat(quote)) {
    if (stream.eat(quote)) tripleQuoted = true;
    else return "string"; //empty string
  }
  function tokenStringHelper(stream, state) {
    var escaped = false;
    while (!stream.eol()) {
      if (!raw && !escaped && stream.peek() == "$") {
        pushInterpolationStack(state);
        state.tokenize = tokenInterpolation;
        return "string";
      }
      var next = stream.next();
      if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {
        state.tokenize = null;
        break;
      }
      escaped = !raw && !escaped && next == "\\";
    }
    return "string";
  }
  state.tokenize = tokenStringHelper;
  return tokenStringHelper(stream, state);
}

function tokenInterpolation(stream, state) {
  stream.eat("$");
  if (stream.eat("{")) {
    // let clike handle the content of ${...},
    // we take over again when "}" appears (see hooks).
    state.tokenize = null;
  } else {
    state.tokenize = tokenInterpolationIdentifier;
  }
  return null;
}

function tokenInterpolationIdentifier(stream, state) {
  stream.eatWhile(/[\w_]/);
  state.tokenize = popInterpolationStack(state);
  return "variable";
}

const dart = clike({
  keywords: words("this super static final const abstract class extends external factory " +
                  "implements mixin get native set typedef with enum throw rethrow " +
                  "assert break case continue default in return new deferred async await covariant " +
                  "try catch finally do else for if switch while import library export " +
                  "part of show hide is as extension on yield late required"),
  blockKeywords: words("try catch finally do else for if switch while"),
  builtin: words("void bool num int double dynamic var String Null Never"),
  atoms: words("true false null"),
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_\.]/);
      return "meta";
    },

    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(stream, state) {
      return tokenDartString("'", stream, state, false);
    },
    "\"": function(stream, state) {
      return tokenDartString("\"", stream, state, false);
    },
    "r": function(stream, state) {
      var peek = stream.peek();
      if (peek == "'" || peek == "\"") {
        return tokenDartString(stream.next(), stream, state, true);
      }
      return false;
    },

    "}": function(_stream, state) {
      // "}" is end of interpolation, if interpolation stack is non-empty
      if (sizeInterpolationStack(state) > 0) {
        state.tokenize = popInterpolationStack(state);
        return null;
      }
      return false;
    },

    "/": function(stream, state) {
      if (!stream.eat("*")) return false
      state.tokenize = tokenNestedComment(1)
      return state.tokenize(stream, state)
    },
    token: function(stream, _, style) {
      if (style == "variable") {
        // Assume uppercase symbols are classes
        var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');
        if (isUpper.test(stream.current())) {
          return 'type';
        }
      }
    }
  }
})


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9jbGlrZV9qcy44YjBhMjI1ZDBiNjNjMGEwN2E1MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBQ3RDLDBDQUEwQztBQUMxQyxzREFBc0Q7QUFDdEQsa0RBQWtEO0FBQ2xELHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUVBQWlFLEVBQUUsSUFBSSxjQUFjO0FBQ3JGLHNCQUFzQixvQkFBb0IseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0EsbURBQW1EO0FBQ25ELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkRBQTJELDZCQUE2QjtBQUN4RjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix5Q0FBeUMsSUFBSTtBQUM3QyxpQ0FBaUM7QUFDakM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxNQUFNO0FBQ04sV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvY2xpa2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBpbmZvLCBhbGlnbiwgcHJldikge1xuICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmluZm8gPSBpbmZvO1xuICB0aGlzLmFsaWduID0gYWxpZ247XG4gIHRoaXMucHJldiA9IHByZXY7XG59XG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlLCBpbmZvKSB7XG4gIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgdHlwZSAhPSBcInN0YXRlbWVudFwiKVxuICAgIGluZGVudCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoaW5kZW50LCBjb2wsIHR5cGUsIGluZm8sIG51bGwsIHN0YXRlLmNvbnRleHQpO1xufVxuZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgaWYgKHQgPT0gXCIpXCIgfHwgdCA9PSBcIl1cIiB8fCB0ID09IFwifVwiKVxuICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG59XG5cbmZ1bmN0aW9uIHR5cGVCZWZvcmUoc3RyZWFtLCBzdGF0ZSwgcG9zKSB7XG4gIGlmIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ2YXJpYWJsZVwiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBcInR5cGVcIikgcmV0dXJuIHRydWU7XG4gIGlmICgvXFxTKD86W14tIF0+fFsqXFxdXSlcXHMqJHxcXCokLy50ZXN0KHN0cmVhbS5zdHJpbmcuc2xpY2UoMCwgcG9zKSkpIHJldHVybiB0cnVlO1xuICBpZiAoc3RhdGUudHlwZUF0RW5kT2ZMaW5lICYmIHN0cmVhbS5jb2x1bW4oKSA9PSBzdHJlYW0uaW5kZW50YXRpb24oKSkgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVG9wU2NvcGUoY29udGV4dCkge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQudHlwZSA9PSBcInRvcFwiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29udGV4dC50eXBlID09IFwifVwiICYmIGNvbnRleHQucHJldi5pbmZvICE9IFwibmFtZXNwYWNlXCIpIHJldHVybiBmYWxzZTtcbiAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlrZShwYXJzZXJDb25maWcpIHtcbiAgdmFyIHN0YXRlbWVudEluZGVudFVuaXQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50VW5pdCxcbiAgICAgIGRvbnRBbGlnbkNhbGxzID0gcGFyc2VyQ29uZmlnLmRvbnRBbGlnbkNhbGxzLFxuICAgICAga2V5d29yZHMgPSBwYXJzZXJDb25maWcua2V5d29yZHMgfHwge30sXG4gICAgICB0eXBlcyA9IHBhcnNlckNvbmZpZy50eXBlcyB8fCB7fSxcbiAgICAgIGJ1aWx0aW4gPSBwYXJzZXJDb25maWcuYnVpbHRpbiB8fCB7fSxcbiAgICAgIGJsb2NrS2V5d29yZHMgPSBwYXJzZXJDb25maWcuYmxvY2tLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGRlZktleXdvcmRzID0gcGFyc2VyQ29uZmlnLmRlZktleXdvcmRzIHx8IHt9LFxuICAgICAgYXRvbXMgPSBwYXJzZXJDb25maWcuYXRvbXMgfHwge30sXG4gICAgICBob29rcyA9IHBhcnNlckNvbmZpZy5ob29rcyB8fCB7fSxcbiAgICAgIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncyxcbiAgICAgIGluZGVudFN0YXRlbWVudHMgPSBwYXJzZXJDb25maWcuaW5kZW50U3RhdGVtZW50cyAhPT0gZmFsc2UsXG4gICAgICBpbmRlbnRTd2l0Y2ggPSBwYXJzZXJDb25maWcuaW5kZW50U3dpdGNoICE9PSBmYWxzZSxcbiAgICAgIG5hbWVzcGFjZVNlcGFyYXRvciA9IHBhcnNlckNvbmZpZy5uYW1lc3BhY2VTZXBhcmF0b3IsXG4gICAgICBpc1B1bmN0dWF0aW9uQ2hhciA9IHBhcnNlckNvbmZpZy5pc1B1bmN0dWF0aW9uQ2hhciB8fCAvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLyxcbiAgICAgIG51bWJlclN0YXJ0ID0gcGFyc2VyQ29uZmlnLm51bWJlclN0YXJ0IHx8IC9bXFxkXFwuXS8sXG4gICAgICBudW1iZXIgPSBwYXJzZXJDb25maWcubnVtYmVyIHx8IC9eKD86MHhbYS1mXFxkXSt8MGJbMDFdK3woPzpcXGQrXFwuP1xcZCp8XFwuXFxkKykoPzplWy0rXT9cXGQrKT8pKHV8bGw/fGx8Zik/L2ksXG4gICAgICBpc09wZXJhdG9yQ2hhciA9IHBhcnNlckNvbmZpZy5pc09wZXJhdG9yQ2hhciB8fCAvWytcXC0qJiU9PD4hP3xcXC9dLyxcbiAgICAgIGlzSWRlbnRpZmllckNoYXIgPSBwYXJzZXJDb25maWcuaXNJZGVudGlmaWVyQ2hhciB8fCAvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8sXG4gICAgICAvLyBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEge3N0cmluZ30gdG9rZW4gYW5kIHJldHVybnMgdHJ1ZSBpZiBpdFxuICAgICAgLy8gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBidWlsdGluLlxuICAgICAgaXNSZXNlcnZlZElkZW50aWZpZXIgPSBwYXJzZXJDb25maWcuaXNSZXNlcnZlZElkZW50aWZpZXIgfHwgZmFsc2U7XG5cbiAgdmFyIGN1clB1bmMsIGlzRGVmS2V5d29yZDtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGhvb2tzW2NoXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChudW1iZXJTdGFydC50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChudW1iZXIpKSByZXR1cm4gXCJudW1iZXJcIlxuICAgICAgc3RyZWFtLm5leHQoKVxuICAgIH1cbiAgICBpZiAoaXNQdW5jdHVhdGlvbkNoYXIudGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBjaDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5tYXRjaCgvXlxcL1tcXC8qXS8sIGZhbHNlKSAmJiBzdHJlYW0uZWF0KGlzT3BlcmF0b3JDaGFyKSkge31cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZShpc0lkZW50aWZpZXJDaGFyKTtcbiAgICBpZiAobmFtZXNwYWNlU2VwYXJhdG9yKSB3aGlsZSAoc3RyZWFtLm1hdGNoKG5hbWVzcGFjZVNlcGFyYXRvcikpXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNJZGVudGlmaWVyQ2hhcik7XG5cbiAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBpZiAoY29udGFpbnMoa2V5d29yZHMsIGN1cikpIHtcbiAgICAgIGlmIChjb250YWlucyhibG9ja0tleXdvcmRzLCBjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIGlmIChjb250YWlucyhkZWZLZXl3b3JkcywgY3VyKSkgaXNEZWZLZXl3b3JkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zKHR5cGVzLCBjdXIpKSByZXR1cm4gXCJ0eXBlXCI7XG4gICAgaWYgKGNvbnRhaW5zKGJ1aWx0aW4sIGN1cilcbiAgICAgICAgfHwgKGlzUmVzZXJ2ZWRJZGVudGlmaWVyICYmIGlzUmVzZXJ2ZWRJZGVudGlmaWVyKGN1cikpKSB7XG4gICAgICBpZiAoY29udGFpbnMoYmxvY2tLZXl3b3JkcywgY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfVxuICAgIGlmIChjb250YWlucyhhdG9tcywgY3VyKSkgcmV0dXJuIFwiYXRvbVwiO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVFT0woc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChwYXJzZXJDb25maWcudHlwZUZpcnN0RGVmaW5pdGlvbnMgJiYgc3RyZWFtLmVvbCgpICYmIGlzVG9wU2NvcGUoc3RhdGUuY29udGV4dCkpXG4gICAgICBzdGF0ZS50eXBlQXRFbmRPZkxpbmUgPSB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHN0cmVhbS5wb3MpXG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGluZGVudFVuaXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgtaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgbnVsbCwgZmFsc2UpLFxuICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgc3RhcnRPZkxpbmU6IHRydWUsXG4gICAgICAgIHByZXZUb2tlbjogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHsgbWF5YmVFT0woc3RyZWFtLCBzdGF0ZSk7IHJldHVybiBudWxsOyB9XG4gICAgICBjdXJQdW5jID0gaXNEZWZLZXl3b3JkID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiKSByZXR1cm4gc3R5bGU7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgIGlmIChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIgfHwgKGN1clB1bmMgPT0gXCIsXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKig/OlxcL1xcLy4qKT8kLywgZmFsc2UpKSlcbiAgICAgICAgd2hpbGUgKHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IGN0eC50eXBlKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGluZGVudFN0YXRlbWVudHMgJiZcbiAgICAgICAgICAgICAgICgoKGN0eC50eXBlID09IFwifVwiIHx8IGN0eC50eXBlID09IFwidG9wXCIpICYmIGN1clB1bmMgIT0gXCI7XCIpIHx8XG4gICAgICAgICAgICAgICAgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSkpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIgJiZcbiAgICAgICAgICAoKHN0YXRlLnByZXZUb2tlbiA9PSBcImRlZlwiIHx8XG4gICAgICAgICAgICAocGFyc2VyQ29uZmlnLnR5cGVGaXJzdERlZmluaXRpb25zICYmIHR5cGVCZWZvcmUoc3RyZWFtLCBzdGF0ZSwgc3RyZWFtLnN0YXJ0KSAmJlxuICAgICAgICAgICAgIGlzVG9wU2NvcGUoc3RhdGUuY29udGV4dCkgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKlxcKC8sIGZhbHNlKSkpKSlcbiAgICAgICAgc3R5bGUgPSBcImRlZlwiO1xuXG4gICAgICBpZiAoaG9va3MudG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGhvb2tzLnRva2VuKHN0cmVhbSwgc3RhdGUsIHN0eWxlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHlsZSA9IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlID09IFwiZGVmXCIgJiYgcGFyc2VyQ29uZmlnLnN0eWxlRGVmcyA9PT0gZmFsc2UpIHN0eWxlID0gXCJ2YXJpYWJsZVwiO1xuXG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgc3RhdGUucHJldlRva2VuID0gaXNEZWZLZXl3b3JkID8gXCJkZWZcIiA6IHN0eWxlIHx8IGN1clB1bmM7XG4gICAgICBtYXliZUVPTChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjb250ZXh0KSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9IG51bGwgfHwgc3RhdGUudHlwZUF0RW5kT2ZMaW5lKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBjbG9zaW5nID0gZmlyc3RDaGFyID09IGN0eC50eXBlO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBjdHggPSBjdHgucHJldjtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZG9udEluZGVudFN0YXRlbWVudHMpXG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIHBhcnNlckNvbmZpZy5kb250SW5kZW50U3RhdGVtZW50cy50ZXN0KGN0eC5pbmZvKSlcbiAgICAgICAgICBjdHggPSBjdHgucHJldlxuICAgICAgaWYgKGhvb2tzLmluZGVudCkge1xuICAgICAgICB2YXIgaG9vayA9IGhvb2tzLmluZGVudChzdGF0ZSwgY3R4LCB0ZXh0QWZ0ZXIsIGNvbnRleHQudW5pdCk7XG4gICAgICAgIGlmICh0eXBlb2YgaG9vayA9PSBcIm51bWJlclwiKSByZXR1cm4gaG9va1xuICAgICAgfVxuICAgICAgdmFyIHN3aXRjaEJsb2NrID0gY3R4LnByZXYgJiYgY3R4LnByZXYuaW5mbyA9PSBcInN3aXRjaFwiO1xuICAgICAgaWYgKHBhcnNlckNvbmZpZy5hbGxtYW5JbmRlbnRhdGlvbiAmJiAvW3soXS8udGVzdChmaXJzdENoYXIpKSB7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSAhPSBcInRvcFwiICYmIGN0eC50eXBlICE9IFwifVwiKSBjdHggPSBjdHgucHJldlxuICAgICAgICByZXR1cm4gY3R4LmluZGVudGVkXG4gICAgICB9XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIilcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogc3RhdGVtZW50SW5kZW50VW5pdCB8fCBjb250ZXh0LnVuaXQpO1xuICAgICAgaWYgKGN0eC5hbGlnbiAmJiAoIWRvbnRBbGlnbkNhbGxzIHx8IGN0eC50eXBlICE9IFwiKVwiKSlcbiAgICAgICAgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcIilcIiAmJiAhY2xvc2luZylcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChzdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGNvbnRleHQudW5pdCk7XG5cbiAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBjb250ZXh0LnVuaXQpICtcbiAgICAgICAgKCFjbG9zaW5nICYmIHN3aXRjaEJsb2NrICYmICEvXig/OmNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSA/IGNvbnRleHQudW5pdCA6IDApO1xuICAgIH0sXG5cbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgIGluZGVudE9uSW5wdXQ6IGluZGVudFN3aXRjaCA/IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHtcXH0/fFxcfSkkLyA6IC9eXFxzKlt7fV0kLyxcbiAgICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX0sXG4gICAgICBhdXRvY29tcGxldGU6IE9iamVjdC5rZXlzKGtleXdvcmRzKS5jb25jYXQoT2JqZWN0LmtleXModHlwZXMpKS5jb25jYXQoT2JqZWN0LmtleXMoYnVpbHRpbikpLmNvbmNhdChPYmplY3Qua2V5cyhhdG9tcykpLFxuICAgICAgLi4ucGFyc2VyQ29uZmlnLmxhbmd1YWdlRGF0YVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBjb250YWlucyh3b3Jkcywgd29yZCkge1xuICBpZiAodHlwZW9mIHdvcmRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gd29yZHMod29yZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpO1xuICB9XG59XG52YXIgY0tleXdvcmRzID0gXCJhdXRvIGlmIGJyZWFrIGNhc2UgcmVnaXN0ZXIgY29udGludWUgcmV0dXJuIGRlZmF1bHQgZG8gc2l6ZW9mIFwiICtcbiAgICBcInN0YXRpYyBlbHNlIHN0cnVjdCBzd2l0Y2ggZXh0ZXJuIHR5cGVkZWYgdW5pb24gZm9yIGdvdG8gd2hpbGUgZW51bSBjb25zdCBcIiArXG4gICAgXCJ2b2xhdGlsZSBpbmxpbmUgcmVzdHJpY3QgYXNtIGZvcnRyYW5cIjtcblxuLy8gS2V5d29yZHMgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAva2V5d29yZCBpbmNsdWRlcyBDKysyMC5cbnZhciBjcHBLZXl3b3JkcyA9IFwiYWxpZ25hcyBhbGlnbm9mIGFuZCBhbmRfZXEgYXVkaXQgYXhpb20gYml0YW5kIGJpdG9yIGNhdGNoIFwiICtcbiAgICBcImNsYXNzIGNvbXBsIGNvbmNlcHQgY29uc3RleHByIGNvbnN0X2Nhc3QgZGVjbHR5cGUgZGVsZXRlIGR5bmFtaWNfY2FzdCBcIiArXG4gICAgXCJleHBsaWNpdCBleHBvcnQgZmluYWwgZnJpZW5kIGltcG9ydCBtb2R1bGUgbXV0YWJsZSBuYW1lc3BhY2UgbmV3IG5vZXhjZXB0IFwiICtcbiAgICBcIm5vdCBub3RfZXEgb3BlcmF0b3Igb3Igb3JfZXEgb3ZlcnJpZGUgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIFwiICtcbiAgICBcInJlaW50ZXJwcmV0X2Nhc3QgcmVxdWlyZXMgc3RhdGljX2Fzc2VydCBzdGF0aWNfY2FzdCB0ZW1wbGF0ZSB0aGlzIFwiICtcbiAgICBcInRocmVhZF9sb2NhbCB0aHJvdyB0cnkgdHlwZWlkIHR5cGVuYW1lIHVzaW5nIHZpcnR1YWwgeG9yIHhvcl9lcVwiO1xuXG52YXIgb2JqQ0tleXdvcmRzID0gXCJieWNvcHkgYnlyZWYgaW4gaW5vdXQgb25ld2F5IG91dCBzZWxmIHN1cGVyIGF0b21pYyBub25hdG9taWMgcmV0YWluIGNvcHkgXCIgK1xuICAgIFwicmVhZHdyaXRlIHJlYWRvbmx5IHN0cm9uZyB3ZWFrIGFzc2lnbiB0eXBlb2YgbnVsbGFibGUgbm9ubnVsbCBudWxsX3Jlc2V0dGFibGUgX2NtZCBcIiArXG4gICAgXCJAaW50ZXJmYWNlIEBpbXBsZW1lbnRhdGlvbiBAZW5kIEBwcm90b2NvbCBAZW5jb2RlIEBwcm9wZXJ0eSBAc3ludGhlc2l6ZSBAZHluYW1pYyBAY2xhc3MgXCIgK1xuICAgIFwiQHB1YmxpYyBAcGFja2FnZSBAcHJpdmF0ZSBAcHJvdGVjdGVkIEByZXF1aXJlZCBAb3B0aW9uYWwgQHRyeSBAY2F0Y2ggQGZpbmFsbHkgQGltcG9ydCBcIiArXG4gICAgXCJAc2VsZWN0b3IgQGVuY29kZSBAZGVmcyBAc3luY2hyb25pemVkIEBhdXRvcmVsZWFzZXBvb2wgQGNvbXBhdGliaWxpdHlfYWxpYXMgQGF2YWlsYWJsZVwiO1xuXG52YXIgb2JqQ0J1aWx0aW5zID0gXCJGT1VOREFUSU9OX0VYUE9SVCBGT1VOREFUSU9OX0VYVEVSTiBOU19JTkxJTkUgTlNfRk9STUFUX0ZVTkNUSU9OIFwiICtcbiAgICBcIiBOU19SRVRVUk5TX1JFVEFJTkVETlNfRVJST1JfRU5VTSBOU19SRVRVUk5TX05PVF9SRVRBSU5FRCBOU19SRVRVUk5TX0lOTkVSX1BPSU5URVIgXCIgK1xuICAgIFwiTlNfREVTSUdOQVRFRF9JTklUSUFMSVpFUiBOU19FTlVNIE5TX09QVElPTlMgTlNfUkVRVUlSRVNfTklMX1RFUk1JTkFUSU9OIFwiICtcbiAgICBcIk5TX0FTU1VNRV9OT05OVUxMX0JFR0lOIE5TX0FTU1VNRV9OT05OVUxMX0VORCBOU19TV0lGVF9OQU1FIE5TX1JFRklORURfRk9SX1NXSUZUXCJcblxuLy8gRG8gbm90IHVzZSB0aGlzLiBVc2UgdGhlIGNUeXBlcyBmdW5jdGlvbiBiZWxvdy4gVGhpcyBpcyBnbG9iYWwganVzdCB0byBhdm9pZFxuLy8gZXhjZXNzaXZlIGNhbGxzIHdoZW4gY1R5cGVzIGlzIGJlaW5nIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBwYXJzZS5cbnZhciBiYXNpY0NUeXBlcyA9IHdvcmRzKFwiaW50IGxvbmcgY2hhciBzaG9ydCBkb3VibGUgZmxvYXQgdW5zaWduZWQgc2lnbmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidm9pZCBib29sXCIpO1xuXG4vLyBEbyBub3QgdXNlIHRoaXMuIFVzZSB0aGUgb2JqQ1R5cGVzIGZ1bmN0aW9uIGJlbG93LiBUaGlzIGlzIGdsb2JhbCBqdXN0IHRvIGF2b2lkXG4vLyBleGNlc3NpdmUgY2FsbHMgd2hlbiBvYmpDVHlwZXMgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIHBhcnNlLlxudmFyIGJhc2ljT2JqQ1R5cGVzID0gd29yZHMoXCJTRUwgaW5zdGFuY2V0eXBlIGlkIENsYXNzIFByb3RvY29sIEJPT0xcIik7XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBpZGVudGlmaWVyIGlzIGEgXCJDXCIgdHlwZS5cbi8vIEMgdHlwZSBpcyBkZWZpbmVkIGFzIHRob3NlIHRoYXQgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb21waWxlciAoYmFzaWNUeXBlcyksXG4vLyBhbmQgdGhvc2UgdGhhdCBlbmQgaW4gX3QgKFJlc2VydmVkIGJ5IFBPU0lYIGZvciB0eXBlcylcbi8vIGh0dHA6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9saWJjL21hbnVhbC9odG1sX25vZGUvUmVzZXJ2ZWQtTmFtZXMuaHRtbFxuZnVuY3Rpb24gY1R5cGVzKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIGNvbnRhaW5zKGJhc2ljQ1R5cGVzLCBpZGVudGlmaWVyKSB8fCAvLitfdCQvLnRlc3QoaWRlbnRpZmllcik7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBpZGVudGlmaWVyIGlzIGEgXCJPYmplY3RpdmUgQ1wiIHR5cGUuXG5mdW5jdGlvbiBvYmpDVHlwZXMoaWRlbnRpZmllcikge1xuICByZXR1cm4gY1R5cGVzKGlkZW50aWZpZXIpIHx8IGNvbnRhaW5zKGJhc2ljT2JqQ1R5cGVzLCBpZGVudGlmaWVyKTtcbn1cblxudmFyIGNCbG9ja0tleXdvcmRzID0gXCJjYXNlIGRvIGVsc2UgZm9yIGlmIHN3aXRjaCB3aGlsZSBzdHJ1Y3QgZW51bSB1bmlvblwiO1xudmFyIGNEZWZLZXl3b3JkcyA9IFwic3RydWN0IGVudW0gdW5pb25cIjtcblxuZnVuY3Rpb24gY3BwSG9vayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuc3RhcnRPZkxpbmUpIHJldHVybiBmYWxzZVxuICBmb3IgKHZhciBjaCwgbmV4dCA9IG51bGw7IGNoID0gc3RyZWFtLnBlZWsoKTspIHtcbiAgICBpZiAoY2ggPT0gXCJcXFxcXCIgJiYgc3RyZWFtLm1hdGNoKC9eLiQvKSkge1xuICAgICAgbmV4dCA9IGNwcEhvb2tcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0ubWF0Y2goL15cXC9bXFwvXFwqXS8sIGZhbHNlKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgc3RyZWFtLm5leHQoKVxuICB9XG4gIHN0YXRlLnRva2VuaXplID0gbmV4dFxuICByZXR1cm4gXCJtZXRhXCJcbn1cblxuZnVuY3Rpb24gcG9pbnRlckhvb2soX3N0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnByZXZUb2tlbiA9PSBcInR5cGVcIikgcmV0dXJuIFwidHlwZVwiO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZvciBDIGFuZCBDKysgKGFuZCBPYmpDKTogaWRlbnRpZmllcnMgc3RhcnRpbmcgd2l0aCBfX1xuLy8gb3IgXyBmb2xsb3dlZCBieSBhIGNhcGl0YWwgbGV0dGVyIGFyZSByZXNlcnZlZCBmb3IgdGhlIGNvbXBpbGVyLlxuZnVuY3Rpb24gY0lzUmVzZXJ2ZWRJZGVudGlmaWVyKHRva2VuKSB7XG4gIGlmICghdG9rZW4gfHwgdG9rZW4ubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICBpZiAodG9rZW5bMF0gIT0gJ18nKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodG9rZW5bMV0gPT0gJ18nKSB8fCAodG9rZW5bMV0gIT09IHRva2VuWzFdLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiBjcHAxNExpdGVyYWwoc3RyZWFtKSB7XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLiddLyk7XG4gIHJldHVybiBcIm51bWJlclwiO1xufVxuXG5mdW5jdGlvbiBjcHAxMVN0cmluZ0hvb2soc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uYmFja1VwKDEpO1xuICAvLyBSYXcgc3RyaW5ncy5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OlJ8dThSfHVSfFVSfExSKS8pKSB7XG4gICAgdmFyIG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXCIoW15cXHNcXFxcKCldezAsMTZ9KVxcKC8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbSA9IG1hdGNoWzFdO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5SYXdTdHJpbmc7XG4gICAgcmV0dXJuIHRva2VuUmF3U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIC8vIFVuaWNvZGUgc3RyaW5ncy9jaGFycy5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OnU4fHV8VXxMKS8pKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXltcIiddLywgLyogZWF0ICovIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJZ25vcmUgdGhpcyBob29rLlxuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNwcExvb2tzTGlrZUNvbnN0cnVjdG9yKHdvcmQpIHtcbiAgdmFyIGxhc3RUd28gPSAvKFxcdyspOjp+PyhcXHcrKSQvLmV4ZWMod29yZCk7XG4gIHJldHVybiBsYXN0VHdvICYmIGxhc3RUd29bMV0gPT0gbGFzdFR3b1syXTtcbn1cblxuLy8gQyMtc3R5bGUgc3RyaW5ncyB3aGVyZSBcIlwiIGVzY2FwZXMgYSBxdW90ZS5cbmZ1bmN0aW9uIHRva2VuQXRTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChuZXh0ID09ICdcIicgJiYgIXN0cmVhbS5lYXQoJ1wiJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuLy8gQysrMTEgcmF3IHN0cmluZyBsaXRlcmFsIGlzIDxwcmVmaXg+XCI8ZGVsaW0+KCBhbnl0aGluZyApPGRlbGltPlwiLCB3aGVyZVxuLy8gPGRlbGltPiBjYW4gYmUgYSBzdHJpbmcgdXAgdG8gMTYgY2hhcmFjdGVycyBsb25nLlxuZnVuY3Rpb24gdG9rZW5SYXdTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgc3BlY2lhbCByZWdleCBtZWFuaW5ncy5cbiAgdmFyIGRlbGltID0gc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbS5yZXBsYWNlKC9bXlxcd1xcc10vZywgJ1xcXFwkJicpO1xuICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2gobmV3IFJlZ0V4cChcIi4qP1xcXFwpXCIgKyBkZWxpbSArICdcIicpKTtcbiAgaWYgKG1hdGNoKVxuICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgZWxzZVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBjb25zdCBjID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzKSxcbiAgdHlwZXM6IGNUeXBlcyxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzKSxcbiAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gIGF0b21zOiB3b3JkcyhcIk5VTEwgdHJ1ZSBmYWxzZVwiKSxcbiAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgaG9va3M6IHtcbiAgICBcIiNcIjogY3BwSG9vayxcbiAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gIH1cbn0pXG5cbmV4cG9ydCBjb25zdCBjcHAgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhjS2V5d29yZHMgKyBcIiBcIiArIGNwcEtleXdvcmRzKSxcbiAgdHlwZXM6IGNUeXBlcyxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMgKyBcIiBjbGFzcyB0cnkgY2F0Y2hcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhjRGVmS2V5d29yZHMgKyBcIiBjbGFzcyBuYW1lc3BhY2VcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIE5VTEwgbnVsbHB0clwiKSxcbiAgZG9udEluZGVudFN0YXRlbWVudHM6IC9edGVtcGxhdGUkLyxcbiAgaXNJZGVudGlmaWVyQ2hhcjogL1tcXHdcXCRfflxceGExLVxcdWZmZmZdLyxcbiAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgaG9va3M6IHtcbiAgICBcIiNcIjogY3BwSG9vayxcbiAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gICAgXCJ1XCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIlVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiTFwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJSXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIjBcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiMVwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIyXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjNcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI1XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjZcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiN1wiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI4XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjlcIjogY3BwMTRMaXRlcmFsLFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIiAmJiBzdHJlYW0ucGVlaygpID09IFwiKFwiICYmXG4gICAgICAgICAgKHN0YXRlLnByZXZUb2tlbiA9PSBcIjtcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIpICYmXG4gICAgICAgICAgY3BwTG9va3NMaWtlQ29uc3RydWN0b3Ioc3RyZWFtLmN1cnJlbnQoKSkpXG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgfSxcbiAgbmFtZXNwYWNlU2VwYXJhdG9yOiBcIjo6XCJcbn0pO1xuXG5leHBvcnQgY29uc3QgamF2YSA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3QgYXNzZXJ0IGJyZWFrIGNhc2UgY2F0Y2ggY2xhc3MgY29uc3QgY29udGludWUgZGVmYXVsdCBcIiArXG4gICAgICAgICAgICAgICAgICBcImRvIGVsc2UgZW51bSBleHRlbmRzIGZpbmFsIGZpbmFsbHkgZm9yIGdvdG8gaWYgaW1wbGVtZW50cyBpbXBvcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbnN0YW5jZW9mIGludGVyZmFjZSBuYXRpdmUgbmV3IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIFwiICtcbiAgICAgICAgICAgICAgICAgIFwicmV0dXJuIHN0YXRpYyBzdHJpY3RmcCBzdXBlciBzd2l0Y2ggc3luY2hyb25pemVkIHRoaXMgdGhyb3cgdGhyb3dzIHRyYW5zaWVudCBcIiArXG4gICAgICAgICAgICAgICAgICBcInRyeSB2b2xhdGlsZSB3aGlsZSBAaW50ZXJmYWNlXCIpLFxuICB0eXBlczogd29yZHMoXCJ2YXIgYnl0ZSBzaG9ydCBpbnQgbG9uZyBmbG9hdCBkb3VibGUgYm9vbGVhbiBjaGFyIHZvaWQgQm9vbGVhbiBCeXRlIENoYXJhY3RlciBEb3VibGUgRmxvYXQgXCIgK1xuICAgICAgICAgICAgICAgXCJJbnRlZ2VyIExvbmcgTnVtYmVyIE9iamVjdCBTaG9ydCBTdHJpbmcgU3RyaW5nQnVmZmVyIFN0cmluZ0J1aWxkZXIgVm9pZFwiKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGlmIHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhcImNsYXNzIGludGVyZmFjZSBlbnVtIEBpbnRlcmZhY2VcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIG51bWJlcjogL14oPzoweFthLWZcXGRfXSt8MGJbMDFfXSt8KD86W1xcZF9dK1xcLj9cXGQqfFxcLlxcZCspKD86ZVstK10/W1xcZF9dKyk/KSh1fGxsP3xsfGYpPy9pLFxuICBob29rczoge1xuICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIC8vIERvbid0IG1hdGNoIHRoZSBAaW50ZXJmYWNlIGtleXdvcmQuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCdpbnRlcmZhY2UnLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9LFxuICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9cIlwiJC8pKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuVHJpcGxlU3RyaW5nO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxufSlcblxuZXhwb3J0IGNvbnN0IGNzaGFycCA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3QgYXMgYXN5bmMgYXdhaXQgYmFzZSBicmVhayBjYXNlIGNhdGNoIGNoZWNrZWQgY2xhc3MgY29uc3QgY29udGludWVcIiArXG4gICAgICAgICAgICAgICAgICBcIiBkZWZhdWx0IGRlbGVnYXRlIGRvIGVsc2UgZW51bSBldmVudCBleHBsaWNpdCBleHRlcm4gZmluYWxseSBmaXhlZCBmb3JcIiArXG4gICAgICAgICAgICAgICAgICBcIiBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50ZXJmYWNlIGludGVybmFsIGlzIGxvY2sgbmFtZXNwYWNlIG5ld1wiICtcbiAgICAgICAgICAgICAgICAgIFwiIG9wZXJhdG9yIG91dCBvdmVycmlkZSBwYXJhbXMgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHJlYWRvbmx5IHJlZiByZXR1cm4gc2VhbGVkXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgc2l6ZW9mIHN0YWNrYWxsb2Mgc3RhdGljIHN0cnVjdCBzd2l0Y2ggdGhpcyB0aHJvdyB0cnkgdHlwZW9mIHVuY2hlY2tlZFwiICtcbiAgICAgICAgICAgICAgICAgIFwiIHVuc2FmZSB1c2luZyB2aXJ0dWFsIHZvaWQgdm9sYXRpbGUgd2hpbGUgYWRkIGFsaWFzIGFzY2VuZGluZyBkZXNjZW5kaW5nIGR5bmFtaWMgZnJvbSBnZXRcIiArXG4gICAgICAgICAgICAgICAgICBcIiBnbG9iYWwgZ3JvdXAgaW50byBqb2luIGxldCBvcmRlcmJ5IHBhcnRpYWwgcmVtb3ZlIHNlbGVjdCBzZXQgdmFsdWUgdmFyIHlpZWxkXCIpLFxuICB0eXBlczogd29yZHMoXCJBY3Rpb24gQm9vbGVhbiBCeXRlIENoYXIgRGF0ZVRpbWUgRGF0ZVRpbWVPZmZzZXQgRGVjaW1hbCBEb3VibGUgRnVuY1wiICtcbiAgICAgICAgICAgICAgIFwiIEd1aWQgSW50MTYgSW50MzIgSW50NjQgT2JqZWN0IFNCeXRlIFNpbmdsZSBTdHJpbmcgVGFzayBUaW1lU3BhbiBVSW50MTYgVUludDMyXCIgK1xuICAgICAgICAgICAgICAgXCIgVUludDY0IGJvb2wgYnl0ZSBjaGFyIGRlY2ltYWwgZG91YmxlIHNob3J0IGludCBsb25nIG9iamVjdFwiICArXG4gICAgICAgICAgICAgICBcIiBzYnl0ZSBmbG9hdCBzdHJpbmcgdXNob3J0IHVpbnQgdWxvbmdcIiksXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZG8gZWxzZSBmaW5hbGx5IGZvciBmb3JlYWNoIGlmIHN0cnVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBpbnRlcmZhY2UgbmFtZXNwYWNlIHN0cnVjdCB2YXJcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KCdcIicpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdFN0cmluZztcbiAgICAgICAgcmV0dXJuIHRva2VuQXRTdHJpbmcoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRva2VuVHJpcGxlU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICBpZiAoIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdcIlwiXCInKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSBzdHJlYW0ubmV4dCgpID09IFwiXFxcXFwiICYmICFlc2NhcGVkO1xuICB9XG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoXG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiKlwiICYmIHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudChkZXB0aCAtIDEpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGggKyAxKVxuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjYWxhID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXG4gICAgLyogc2NhbGEgKi9cbiAgICBcImFic3RyYWN0IGNhc2UgY2F0Y2ggY2xhc3MgZGVmIGRvIGVsc2UgZXh0ZW5kcyBmaW5hbCBmaW5hbGx5IGZvciBmb3JTb21lIGlmIFwiICtcbiAgICAgIFwiaW1wbGljaXQgaW1wb3J0IGxhenkgbWF0Y2ggbmV3IG51bGwgb2JqZWN0IG92ZXJyaWRlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcmV0dXJuIFwiICtcbiAgICAgIFwic2VhbGVkIHN1cGVyIHRoaXMgdGhyb3cgdHJhaXQgdHJ5IHR5cGUgdmFsIHZhciB3aGlsZSB3aXRoIHlpZWxkIF8gXCIgK1xuXG4gICAgLyogcGFja2FnZSBzY2FsYSAqL1xuICAgIFwiYXNzZXJ0IGFzc3VtZSByZXF1aXJlIHByaW50IHByaW50bG4gcHJpbnRmIHJlYWRMaW5lIHJlYWRCb29sZWFuIHJlYWRCeXRlIHJlYWRTaG9ydCBcIiArXG4gICAgICBcInJlYWRDaGFyIHJlYWRJbnQgcmVhZExvbmcgcmVhZEZsb2F0IHJlYWREb3VibGVcIlxuICApLFxuICB0eXBlczogd29yZHMoXG4gICAgXCJBbnlWYWwgQXBwIEFwcGxpY2F0aW9uIEFycmF5IEJ1ZmZlcmVkSXRlcmF0b3IgQmlnRGVjaW1hbCBCaWdJbnQgQ2hhciBDb25zb2xlIEVpdGhlciBcIiArXG4gICAgICBcIkVudW1lcmF0aW9uIEVxdWl2IEVycm9yIEV4Y2VwdGlvbiBGcmFjdGlvbmFsIEZ1bmN0aW9uIEluZGV4ZWRTZXEgSW50IEludGVncmFsIEl0ZXJhYmxlIFwiICtcbiAgICAgIFwiSXRlcmF0b3IgTGlzdCBNYXAgTnVtZXJpYyBOaWwgTm90TnVsbCBPcHRpb24gT3JkZXJlZCBPcmRlcmluZyBQYXJ0aWFsRnVuY3Rpb24gUGFydGlhbE9yZGVyaW5nIFwiICtcbiAgICAgIFwiUHJvZHVjdCBQcm94eSBSYW5nZSBSZXNwb25kZXIgU2VxIFNlcmlhbGl6YWJsZSBTZXQgU3BlY2lhbGl6YWJsZSBTdHJlYW0gU3RyaW5nQnVpbGRlciBcIiArXG4gICAgICBcIlN0cmluZ0NvbnRleHQgU3ltYm9sIFRocm93YWJsZSBUcmF2ZXJzYWJsZSBUcmF2ZXJzYWJsZU9uY2UgVHVwbGUgVW5pdCBWZWN0b3IgXCIgK1xuXG4gICAgLyogcGFja2FnZSBqYXZhLmxhbmcgKi9cbiAgICBcIkJvb2xlYW4gQnl0ZSBDaGFyYWN0ZXIgQ2hhclNlcXVlbmNlIENsYXNzIENsYXNzTG9hZGVyIENsb25lYWJsZSBDb21wYXJhYmxlIFwiICtcbiAgICAgIFwiQ29tcGlsZXIgRG91YmxlIEV4Y2VwdGlvbiBGbG9hdCBJbnRlZ2VyIExvbmcgTWF0aCBOdW1iZXIgT2JqZWN0IFBhY2thZ2UgUGFpciBQcm9jZXNzIFwiICtcbiAgICAgIFwiUnVudGltZSBSdW5uYWJsZSBTZWN1cml0eU1hbmFnZXIgU2hvcnQgU3RhY2tUcmFjZUVsZW1lbnQgU3RyaWN0TWF0aCBTdHJpbmcgXCIgK1xuICAgICAgXCJTdHJpbmdCdWZmZXIgU3lzdGVtIFRocmVhZCBUaHJlYWRHcm91cCBUaHJlYWRMb2NhbCBUaHJvd2FibGUgVHJpcGxlIFZvaWRcIlxuICApLFxuICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGVudW0gZG8gZWxzZSBmaW5hbGx5IGZvciBmb3JTb21lIGlmIG1hdGNoIHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhcImNsYXNzIGVudW0gZGVmIG9iamVjdCBwYWNrYWdlIHRyYWl0IHR5cGUgdmFsIHZhclwiKSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsXCIpLFxuICBpbmRlbnRTdGF0ZW1lbnRzOiBmYWxzZSxcbiAgaW5kZW50U3dpdGNoOiBmYWxzZSxcbiAgaXNPcGVyYXRvckNoYXI6IC9bK1xcLSomJT08PiE/fFxcLyM6QF0vLFxuICBob29rczoge1xuICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfSxcbiAgICAnXCInOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaCgnXCJcIicpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuVHJpcGxlU3RyaW5nO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG4gICAgXCInXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX1xceGExLVxcdWZmZmZdLyk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfSxcbiAgICBcIj1cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN4ID0gc3RhdGUuY29udGV4dFxuICAgICAgaWYgKGN4LnR5cGUgPT0gXCJ9XCIgJiYgY3guYWxpZ24gJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGN4LmluZGVudGVkLCBjeC5jb2x1bW4sIGN4LnR5cGUsIGN4LmluZm8sIG51bGwsIGN4LnByZXYpXG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudCgxKVxuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgJ1wiXCJcIiddfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdG9rZW5Lb3RsaW5TdHJpbmcodHJpcGxlU3RyaW5nKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmICghdHJpcGxlU3RyaW5nICYmICFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnXCInKSApIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICBpZiAodHJpcGxlU3RyaW5nICYmIHN0cmVhbS5tYXRjaCgnXCJcIlwiJykpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICBuZXh0ID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmKCFlc2NhcGVkICYmIG5leHQgPT0gXCIkXCIgJiYgc3RyZWFtLm1hdGNoKCd7JykpXG4gICAgICAgIHN0cmVhbS5za2lwVG8oXCJ9XCIpO1xuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCIgJiYgIXRyaXBsZVN0cmluZztcbiAgICB9XG4gICAgaWYgKGVuZCB8fCAhdHJpcGxlU3RyaW5nKVxuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBrb3RsaW4gPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhcbiAgICAvKmtleXdvcmRzKi9cbiAgICBcInBhY2thZ2UgYXMgdHlwZWFsaWFzIGNsYXNzIGludGVyZmFjZSB0aGlzIHN1cGVyIHZhbCBvcGVyYXRvciBcIiArXG4gICAgICBcInZhciBmdW4gZm9yIGlzIGluIFRoaXMgdGhyb3cgcmV0dXJuIGFubm90YXRpb24gXCIgK1xuICAgICAgXCJicmVhayBjb250aW51ZSBvYmplY3QgaWYgZWxzZSB3aGlsZSBkbyB0cnkgd2hlbiAhaW4gIWlzIGFzPyBcIiArXG5cbiAgICAvKnNvZnQga2V5d29yZHMqL1xuICAgIFwiZmlsZSBpbXBvcnQgd2hlcmUgYnkgZ2V0IHNldCBhYnN0cmFjdCBlbnVtIG9wZW4gaW5uZXIgb3ZlcnJpZGUgcHJpdmF0ZSBwdWJsaWMgaW50ZXJuYWwgXCIgK1xuICAgICAgXCJwcm90ZWN0ZWQgY2F0Y2ggZmluYWxseSBvdXQgZmluYWwgdmFyYXJnIHJlaWZpZWQgZHluYW1pYyBjb21wYW5pb24gY29uc3RydWN0b3IgaW5pdCBcIiArXG4gICAgICBcInNlYWxlZCBmaWVsZCBwcm9wZXJ0eSByZWNlaXZlciBwYXJhbSBzcGFyYW0gbGF0ZWluaXQgZGF0YSBpbmxpbmUgbm9pbmxpbmUgdGFpbHJlYyBcIiArXG4gICAgICBcImV4dGVybmFsIGFubm90YXRpb24gY3Jvc3NpbmxpbmUgY29uc3Qgb3BlcmF0b3IgaW5maXggc3VzcGVuZCBhY3R1YWwgZXhwZWN0IHNldHBhcmFtXCJcbiAgKSxcbiAgdHlwZXM6IHdvcmRzKFxuICAgIC8qIHBhY2thZ2UgamF2YS5sYW5nICovXG4gICAgXCJCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIENoYXJTZXF1ZW5jZSBDbGFzcyBDbGFzc0xvYWRlciBDbG9uZWFibGUgQ29tcGFyYWJsZSBcIiArXG4gICAgICBcIkNvbXBpbGVyIERvdWJsZSBFeGNlcHRpb24gRmxvYXQgSW50ZWdlciBMb25nIE1hdGggTnVtYmVyIE9iamVjdCBQYWNrYWdlIFBhaXIgUHJvY2VzcyBcIiArXG4gICAgICBcIlJ1bnRpbWUgUnVubmFibGUgU2VjdXJpdHlNYW5hZ2VyIFNob3J0IFN0YWNrVHJhY2VFbGVtZW50IFN0cmljdE1hdGggU3RyaW5nIFwiICtcbiAgICAgIFwiU3RyaW5nQnVmZmVyIFN5c3RlbSBUaHJlYWQgVGhyZWFkR3JvdXAgVGhyZWFkTG9jYWwgVGhyb3dhYmxlIFRyaXBsZSBWb2lkIEFubm90YXRpb24gQW55IEJvb2xlYW5BcnJheSBcIiArXG4gICAgICBcIkJ5dGVBcnJheSBDaGFyIENoYXJBcnJheSBEZXByZWNhdGlvbkxldmVsIERvdWJsZUFycmF5IEVudW0gRmxvYXRBcnJheSBGdW5jdGlvbiBJbnQgSW50QXJyYXkgTGF6eSBcIiArXG4gICAgICBcIkxhenlUaHJlYWRTYWZldHlNb2RlIExvbmdBcnJheSBOb3RoaW5nIFNob3J0QXJyYXkgVW5pdFwiXG4gICksXG4gIGludGVuZFN3aXRjaDogZmFsc2UsXG4gIGluZGVudFN0YXRlbWVudHM6IGZhbHNlLFxuICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlLFxuICBudW1iZXI6IC9eKD86MHhbYS1mXFxkX10rfDBiWzAxX10rfCg/OltcXGRfXSsoXFwuXFxkKyk/fFxcLlxcZCspKD86ZVstK10/W1xcZF9dKyk/KSh1fGxsP3xsfGYpPy9pLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgaWYgd2hlcmUgdHJ5IHdoaWxlIGVudW1cIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhcImNsYXNzIHZhbCB2YXIgb2JqZWN0IGludGVyZmFjZSBmdW5cIiksXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbCB0aGlzXCIpLFxuICBob29rczoge1xuICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfSxcbiAgICAnKic6IGZ1bmN0aW9uKF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUucHJldlRva2VuID09ICcuJyA/ICd2YXJpYWJsZScgOiAnb3BlcmF0b3InO1xuICAgIH0sXG4gICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbktvdGxpblN0cmluZyhzdHJlYW0ubWF0Y2goJ1wiXCInKSk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoMSk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICB9LFxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIGN0eCwgdGV4dEFmdGVyLCBpbmRlbnRVbml0KSB7XG4gICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICBpZiAoKHN0YXRlLnByZXZUb2tlbiA9PSBcIn1cIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gXCIpXCIpICYmIHRleHRBZnRlciA9PSBcIlwiKVxuICAgICAgICByZXR1cm4gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICBpZiAoKHN0YXRlLnByZXZUb2tlbiA9PSBcIm9wZXJhdG9yXCIgJiYgdGV4dEFmdGVyICE9IFwifVwiICYmIHN0YXRlLmNvbnRleHQudHlwZSAhPSBcIn1cIikgfHxcbiAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ2YXJpYWJsZVwiICYmIGZpcnN0Q2hhciA9PSBcIi5cIiB8fFxuICAgICAgICAgIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIgfHwgc3RhdGUucHJldlRva2VuID09IFwiKVwiKSAmJiBmaXJzdENoYXIgPT0gXCIuXCIpXG4gICAgICAgIHJldHVybiBpbmRlbnRVbml0ICogMiArIGN0eC5pbmRlbnRlZDtcbiAgICAgIGlmIChjdHguYWxpZ24gJiYgY3R4LnR5cGUgPT0gXCJ9XCIpXG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoc3RhdGUuY29udGV4dC50eXBlID09ICh0ZXh0QWZ0ZXIgfHwgXCJcIikuY2hhckF0KDApID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH1cbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czoge2JyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsICdcIlwiXCInXX1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBzaGFkZXIgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhcInNhbXBsZXIxRCBzYW1wbGVyMkQgc2FtcGxlcjNEIHNhbXBsZXJDdWJlIFwiICtcbiAgICAgICAgICAgICAgICAgIFwic2FtcGxlcjFEU2hhZG93IHNhbXBsZXIyRFNoYWRvdyBcIiArXG4gICAgICAgICAgICAgICAgICBcImNvbnN0IGF0dHJpYnV0ZSB1bmlmb3JtIHZhcnlpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJicmVhayBjb250aW51ZSBkaXNjYXJkIHJldHVybiBcIiArXG4gICAgICAgICAgICAgICAgICBcImZvciB3aGlsZSBkbyBpZiBlbHNlIHN0cnVjdCBcIiArXG4gICAgICAgICAgICAgICAgICBcImluIG91dCBpbm91dFwiKSxcbiAgdHlwZXM6IHdvcmRzKFwiZmxvYXQgaW50IGJvb2wgdm9pZCBcIiArXG4gICAgICAgICAgICAgICBcInZlYzIgdmVjMyB2ZWM0IGl2ZWMyIGl2ZWMzIGl2ZWM0IGJ2ZWMyIGJ2ZWMzIGJ2ZWM0IFwiICtcbiAgICAgICAgICAgICAgIFwibWF0MiBtYXQzIG1hdDRcIiksXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3RydWN0XCIpLFxuICBidWlsdGluOiB3b3JkcyhcInJhZGlhbnMgZGVncmVlcyBzaW4gY29zIHRhbiBhc2luIGFjb3MgYXRhbiBcIiArXG4gICAgICAgICAgICAgICAgIFwicG93IGV4cCBsb2cgZXhwMiBzcXJ0IGludmVyc2VzcXJ0IFwiICtcbiAgICAgICAgICAgICAgICAgXCJhYnMgc2lnbiBmbG9vciBjZWlsIGZyYWN0IG1vZCBtaW4gbWF4IGNsYW1wIG1peCBzdGVwIHNtb290aHN0ZXAgXCIgK1xuICAgICAgICAgICAgICAgICBcImxlbmd0aCBkaXN0YW5jZSBkb3QgY3Jvc3Mgbm9ybWFsaXplIGZ0cmFuc2Zvcm0gZmFjZWZvcndhcmQgXCIgK1xuICAgICAgICAgICAgICAgICBcInJlZmxlY3QgcmVmcmFjdCBtYXRyaXhDb21wTXVsdCBcIiArXG4gICAgICAgICAgICAgICAgIFwibGVzc1RoYW4gbGVzc1RoYW5FcXVhbCBncmVhdGVyVGhhbiBncmVhdGVyVGhhbkVxdWFsIFwiICtcbiAgICAgICAgICAgICAgICAgXCJlcXVhbCBub3RFcXVhbCBhbnkgYWxsIG5vdCBcIiArXG4gICAgICAgICAgICAgICAgIFwidGV4dHVyZTFEIHRleHR1cmUxRFByb2ogdGV4dHVyZTFETG9kIHRleHR1cmUxRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICBcInRleHR1cmUyRCB0ZXh0dXJlMkRQcm9qIHRleHR1cmUyRExvZCB0ZXh0dXJlMkRQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlM0QgdGV4dHVyZTNEUHJvaiB0ZXh0dXJlM0RMb2QgdGV4dHVyZTNEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgIFwidGV4dHVyZUN1YmUgdGV4dHVyZUN1YmVMb2QgXCIgK1xuICAgICAgICAgICAgICAgICBcInNoYWRvdzFEIHNoYWRvdzJEIHNoYWRvdzFEUHJvaiBzaGFkb3cyRFByb2ogXCIgK1xuICAgICAgICAgICAgICAgICBcInNoYWRvdzFETG9kIHNoYWRvdzJETG9kIHNoYWRvdzFEUHJvakxvZCBzaGFkb3cyRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICBcImRGZHggZEZkeSBmd2lkdGggXCIgK1xuICAgICAgICAgICAgICAgICBcIm5vaXNlMSBub2lzZTIgbm9pc2UzIG5vaXNlNFwiKSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciBnbF9TZWNvbmRhcnlDb2xvciBnbF9Ob3JtYWwgZ2xfVmVydGV4IFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDAgZ2xfTXVsdGlUZXhDb29yZDEgZ2xfTXVsdGlUZXhDb29yZDIgZ2xfTXVsdGlUZXhDb29yZDMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NdWx0aVRleENvb3JkNCBnbF9NdWx0aVRleENvb3JkNSBnbF9NdWx0aVRleENvb3JkNiBnbF9NdWx0aVRleENvb3JkNyBcIiArXG4gICAgICAgICAgICAgICBcImdsX0ZvZ0Nvb3JkIGdsX1BvaW50Q29vcmQgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiBnbF9Qb2ludFNpemUgZ2xfQ2xpcFZlcnRleCBcIiArXG4gICAgICAgICAgICAgICBcImdsX0Zyb250Q29sb3IgZ2xfQmFja0NvbG9yIGdsX0Zyb250U2Vjb25kYXJ5Q29sb3IgZ2xfQmFja1NlY29uZGFyeUNvbG9yIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfVGV4Q29vcmQgZ2xfRm9nRnJhZ0Nvb3JkIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0Nvb3JkIGdsX0Zyb250RmFjaW5nIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0RhdGEgZ2xfRnJhZ0RlcHRoIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTW9kZWxWaWV3TWF0cml4IGdsX1Byb2plY3Rpb25NYXRyaXggZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCBcIiArXG4gICAgICAgICAgICAgICBcImdsX1RleHR1cmVNYXRyaXggZ2xfTm9ybWFsTWF0cml4IGdsX01vZGVsVmlld01hdHJpeEludmVyc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZSBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX1RleHR1cmVNYXRyaXhUcmFuc3Bvc2UgZ2xfTW9kZWxWaWV3TWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeEludmVyc2VUcmFuc3Bvc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9UZXh0dXJlTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX05vcm1hbFNjYWxlIGdsX0RlcHRoUmFuZ2UgZ2xfQ2xpcFBsYW5lIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfUG9pbnQgZ2xfRnJvbnRNYXRlcmlhbCBnbF9CYWNrTWF0ZXJpYWwgZ2xfTGlnaHRTb3VyY2UgZ2xfTGlnaHRNb2RlbCBcIiArXG4gICAgICAgICAgICAgICBcImdsX0Zyb250TGlnaHRNb2RlbFByb2R1Y3QgZ2xfQmFja0xpZ2h0TW9kZWxQcm9kdWN0IFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZUNvbG9yIGdsX0V5ZVBsYW5lUyBnbF9FeWVQbGFuZVQgZ2xfRXllUGxhbmVSIGdsX0V5ZVBsYW5lUSBcIiArXG4gICAgICAgICAgICAgICBcImdsX0ZvZ1BhcmFtZXRlcnMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NYXhMaWdodHMgZ2xfTWF4Q2xpcFBsYW5lcyBnbF9NYXhUZXh0dXJlVW5pdHMgZ2xfTWF4VGV4dHVyZUNvb3JkcyBcIiArXG4gICAgICAgICAgICAgICBcImdsX01heFZlcnRleEF0dHJpYnMgZ2xfTWF4VmVydGV4VW5pZm9ybUNvbXBvbmVudHMgZ2xfTWF4VmFyeWluZ0Zsb2F0cyBcIiArXG4gICAgICAgICAgICAgICBcImdsX01heFZlcnRleFRleHR1cmVJbWFnZVVuaXRzIGdsX01heFRleHR1cmVJbWFnZVVuaXRzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTWF4RnJhZ21lbnRVbmlmb3JtQ29tcG9uZW50cyBnbF9NYXhDb21iaW5lVGV4dHVyZUltYWdlVW5pdHMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NYXhEcmF3QnVmZmVyc1wiKSxcbiAgaW5kZW50U3dpdGNoOiBmYWxzZSxcbiAgaG9va3M6IHtcIiNcIjogY3BwSG9va31cbn0pXG5cbmV4cG9ydCBjb25zdCBuZXNDID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgYXMgYXRvbWljIGFzeW5jIGNhbGwgY29tbWFuZCBjb21wb25lbnQgY29tcG9uZW50cyBjb25maWd1cmF0aW9uIGV2ZW50IGdlbmVyaWMgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbXBsZW1lbnRhdGlvbiBpbmNsdWRlcyBpbnRlcmZhY2UgbW9kdWxlIG5ldyBub3JhY2Ugbnhfc3RydWN0IG54X3VuaW9uIHBvc3QgcHJvdmlkZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJzaWduYWwgdGFzayB1c2VzIGFic3RyYWN0IGV4dGVuZHNcIiksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzKSxcbiAgYXRvbXM6IHdvcmRzKFwibnVsbCB0cnVlIGZhbHNlXCIpLFxuICBob29rczoge1wiI1wiOiBjcHBIb29rfVxufSlcblxuZXhwb3J0IGNvbnN0IG9iamVjdGl2ZUMgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhjS2V5d29yZHMgKyBcIiBcIiArIG9iakNLZXl3b3JkcyksXG4gIHR5cGVzOiBvYmpDVHlwZXMsXG4gIGJ1aWx0aW46IHdvcmRzKG9iakNCdWlsdGlucyksXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzICsgXCIgQHN5bnRoZXNpemUgQHRyeSBAY2F0Y2ggQGZpbmFsbHkgQGF1dG9yZWxlYXNlcG9vbCBAc3luY2hyb25pemVkXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgQGludGVyZmFjZSBAaW1wbGVtZW50YXRpb24gQHByb3RvY29sIEBjbGFzc1wiKSxcbiAgZG9udEluZGVudFN0YXRlbWVudHM6IC9eQC4qJC8sXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJZRVMgTk8gTlVMTCBOaWwgbmlsIHRydWUgZmFsc2UgbnVsbHB0clwiKSxcbiAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgaG9va3M6IHtcbiAgICBcIiNcIjogY3BwSG9vayxcbiAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gIH1cbn0pXG5cbmV4cG9ydCBjb25zdCBvYmplY3RpdmVDcHAgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhjS2V5d29yZHMgKyBcIiBcIiArIG9iakNLZXl3b3JkcyArIFwiIFwiICsgY3BwS2V5d29yZHMpLFxuICB0eXBlczogb2JqQ1R5cGVzLFxuICBidWlsdGluOiB3b3JkcyhvYmpDQnVpbHRpbnMpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhjQmxvY2tLZXl3b3JkcyArIFwiIEBzeW50aGVzaXplIEB0cnkgQGNhdGNoIEBmaW5hbGx5IEBhdXRvcmVsZWFzZXBvb2wgQHN5bmNocm9uaXplZCBjbGFzcyB0cnkgY2F0Y2hcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhjRGVmS2V5d29yZHMgKyBcIiBAaW50ZXJmYWNlIEBpbXBsZW1lbnRhdGlvbiBAcHJvdG9jb2wgQGNsYXNzIGNsYXNzIG5hbWVzcGFjZVwiKSxcbiAgZG9udEluZGVudFN0YXRlbWVudHM6IC9eQC4qJHxedGVtcGxhdGUkLyxcbiAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gIGF0b21zOiB3b3JkcyhcIllFUyBOTyBOVUxMIE5pbCBuaWwgdHJ1ZSBmYWxzZSBudWxscHRyXCIpLFxuICBpc1Jlc2VydmVkSWRlbnRpZmllcjogY0lzUmVzZXJ2ZWRJZGVudGlmaWVyLFxuICBob29rczoge1xuICAgIFwiI1wiOiBjcHBIb29rLFxuICAgIFwiKlwiOiBwb2ludGVySG9vayxcbiAgICBcInVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiVVwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJMXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIlJcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiMFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIxXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjJcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiM1wiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI0XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjVcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNlwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI3XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjhcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiOVwiOiBjcHAxNExpdGVyYWwsXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUsIHN0eWxlKSB7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiICYmIHN0cmVhbS5wZWVrKCkgPT0gXCIoXCIgJiZcbiAgICAgICAgICAoc3RhdGUucHJldlRva2VuID09IFwiO1wiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBudWxsIHx8XG4gICAgICAgICAgIHN0YXRlLnByZXZUb2tlbiA9PSBcIn1cIikgJiZcbiAgICAgICAgICBjcHBMb29rc0xpa2VDb25zdHJ1Y3RvcihzdHJlYW0uY3VycmVudCgpKSlcbiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuICB9LFxuICBuYW1lc3BhY2VTZXBhcmF0b3I6IFwiOjpcIlxufSlcblxuZXhwb3J0IGNvbnN0IHNxdWlycmVsID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXCJiYXNlIGJyZWFrIGNsb25lIGNvbnRpbnVlIGNvbnN0IGRlZmF1bHQgZGVsZXRlIGVudW0gZXh0ZW5kcyBmdW5jdGlvbiBpbiBjbGFzc1wiICtcbiAgICAgICAgICAgICAgICAgIFwiIGZvcmVhY2ggbG9jYWwgcmVzdW1lIHJldHVybiB0aGlzIHRocm93IHR5cGVvZiB5aWVsZCBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIHN0YXRpY1wiKSxcbiAgdHlwZXM6IGNUeXBlcyxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXNlIGNhdGNoIGNsYXNzIGVsc2UgZm9yIGZvcmVhY2ggaWYgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiZnVuY3Rpb24gbG9jYWwgY2xhc3NcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGhvb2tzOiB7XCIjXCI6IGNwcEhvb2t9XG59KVxuXG4vLyBDZXlsb24gU3RyaW5ncyBuZWVkIHRvIGRlYWwgd2l0aCBpbnRlcnBvbGF0aW9uXG52YXIgc3RyaW5nVG9rZW5pemVyID0gbnVsbDtcbmZ1bmN0aW9uIHRva2VuQ2V5bG9uU3RyaW5nKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnXCInKSAmJlxuICAgICAgICAgICh0eXBlID09IFwic2luZ2xlXCIgfHwgc3RyZWFtLm1hdGNoKCdcIlwiJykpKSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnYGAnKSkge1xuICAgICAgICBzdHJpbmdUb2tlbml6ZXIgPSB0b2tlbkNleWxvblN0cmluZyh0eXBlKTtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0ID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGVzY2FwZWQgPSB0eXBlID09IFwic2luZ2xlXCIgJiYgIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZClcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2V5bG9uID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXCJhYnN0cmFjdHMgYWxpYXMgYXNzZW1ibHkgYXNzZXJ0IGFzc2lnbiBicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNvbnRpbnVlIGR5bmFtaWMgZWxzZVwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGV4aXN0cyBleHRlbmRzIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGdpdmVuIGlmIGltcG9ydCBpbiBpbnRlcmZhY2UgaXMgbGV0IG1vZHVsZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICBcIiBub25lbXB0eSBvYmplY3Qgb2Ygb3V0IG91dGVyIHBhY2thZ2UgcmV0dXJuIHNhdGlzZmllcyBzdXBlciBzd2l0Y2ggdGhlbiB0aGlzIHRocm93XCIgK1xuICAgICAgICAgICAgICAgICAgXCIgdHJ5IHZhbHVlIHZvaWQgd2hpbGVcIiksXG4gIHR5cGVzOiBmdW5jdGlvbih3b3JkKSB7XG4gICAgLy8gSW4gQ2V5bG9uIGFsbCBpZGVudGlmaWVycyB0aGF0IHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGFyZSB0eXBlc1xuICAgIHZhciBmaXJzdCA9IHdvcmQuY2hhckF0KDApO1xuICAgIHJldHVybiAoZmlyc3QgPT09IGZpcnN0LnRvVXBwZXJDYXNlKCkgJiYgZmlyc3QgIT09IGZpcnN0LnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhc2UgY2F0Y2ggY2xhc3MgZHluYW1pYyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGludGVyZmFjZSBtb2R1bGUgbmV3IG9iamVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBkeW5hbWljIGZ1bmN0aW9uIGludGVyZmFjZSBtb2R1bGUgb2JqZWN0IHBhY2thZ2UgdmFsdWVcIiksXG4gIGJ1aWx0aW46IHdvcmRzKFwiYWJzdHJhY3QgYWN0dWFsIGFsaWFzZWQgYW5ub3RhdGlvbiBieSBkZWZhdWx0IGRlcHJlY2F0ZWQgZG9jIGZpbmFsIGZvcm1hbCBsYXRlIGxpY2Vuc2VcIiArXG4gICAgICAgICAgICAgICAgIFwiIG5hdGl2ZSBvcHRpb25hbCBzZWFsZWQgc2VlIHNlcmlhbGl6YWJsZSBzaGFyZWQgc3VwcHJlc3NXYXJuaW5ncyB0YWdnZWQgdGhyb3dzIHZhcmlhYmxlXCIpLFxuICBpc1B1bmN0dWF0aW9uQ2hhcjogL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuYF0vLFxuICBpc09wZXJhdG9yQ2hhcjogL1srXFwtKiYlPTw+IT98Xn46XFwvXS8sXG4gIG51bWJlclN0YXJ0OiAvW1xcZCMkXS8sXG4gIG51bWJlcjogL14oPzojW1xcZGEtZkEtRl9dK3xcXCRbMDFfXSt8W1xcZF9dK1trTUdUUG11bnBmXT98W1xcZF9dK1xcLltcXGRfXSsoPzpbZUVdWy0rXT9cXGQrfFtrTUdUUG11bnBmXXwpfCkvaSxcbiAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbCBsYXJnZXIgc21hbGxlciBlcXVhbCBlbXB0eSBmaW5pc2hlZFwiKSxcbiAgaW5kZW50U3dpdGNoOiBmYWxzZSxcbiAgc3R5bGVEZWZzOiBmYWxzZSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG4gICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNleWxvblN0cmluZyhzdHJlYW0ubWF0Y2goJ1wiXCInKSA/IFwidHJpcGxlXCIgOiBcInNpbmdsZVwiKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuICAgICdgJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJpbmdUb2tlbml6ZXIgfHwgIXN0cmVhbS5tYXRjaCgnYCcpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHN0cmluZ1Rva2VuaXplcjtcbiAgICAgIHN0cmluZ1Rva2VuaXplciA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBcIidcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vKTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihfc3RyZWFtLCBzdGF0ZSwgc3R5bGUpIHtcbiAgICAgIGlmICgoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiIHx8IHN0eWxlID09IFwidHlwZVwiKSAmJlxuICAgICAgICAgIHN0YXRlLnByZXZUb2tlbiA9PSBcIi5cIikge1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czoge2JyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsICdcIlwiXCInXX1cbiAgfVxufSlcblxuZnVuY3Rpb24gcHVzaEludGVycG9sYXRpb25TdGFjayhzdGF0ZSkge1xuICAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrIHx8IChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgPSBbXSkpLnB1c2goc3RhdGUudG9rZW5pemUpO1xufVxuXG5mdW5jdGlvbiBwb3BJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgfHwgKHN0YXRlLmludGVycG9sYXRpb25TdGFjayA9IFtdKSkucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHNpemVJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmludGVycG9sYXRpb25TdGFjayA/IHN0YXRlLmludGVycG9sYXRpb25TdGFjay5sZW5ndGggOiAwO1xufVxuXG5mdW5jdGlvbiB0b2tlbkRhcnRTdHJpbmcocXVvdGUsIHN0cmVhbSwgc3RhdGUsIHJhdykge1xuICB2YXIgdHJpcGxlUXVvdGVkID0gZmFsc2U7XG4gIGlmIChzdHJlYW0uZWF0KHF1b3RlKSkge1xuICAgIGlmIChzdHJlYW0uZWF0KHF1b3RlKSkgdHJpcGxlUXVvdGVkID0gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBcInN0cmluZ1wiOyAvL2VtcHR5IHN0cmluZ1xuICB9XG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nSGVscGVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoIXJhdyAmJiAhZXNjYXBlZCAmJiBzdHJlYW0ucGVlaygpID09IFwiJFwiKSB7XG4gICAgICAgIHB1c2hJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSW50ZXJwb2xhdGlvbjtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCAmJiAoIXRyaXBsZVF1b3RlZCB8fCBzdHJlYW0ubWF0Y2gocXVvdGUgKyBxdW90ZSkpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIXJhdyAmJiAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nSGVscGVyO1xuICByZXR1cm4gdG9rZW5TdHJpbmdIZWxwZXIoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHRva2VuSW50ZXJwb2xhdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5lYXQoXCIkXCIpO1xuICBpZiAoc3RyZWFtLmVhdChcIntcIikpIHtcbiAgICAvLyBsZXQgY2xpa2UgaGFuZGxlIHRoZSBjb250ZW50IG9mICR7Li4ufSxcbiAgICAvLyB3ZSB0YWtlIG92ZXIgYWdhaW4gd2hlbiBcIn1cIiBhcHBlYXJzIChzZWUgaG9va3MpLlxuICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSW50ZXJwb2xhdGlvbklkZW50aWZpZXI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRva2VuSW50ZXJwb2xhdGlvbklkZW50aWZpZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cbmV4cG9ydCBjb25zdCBkYXJ0ID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXCJ0aGlzIHN1cGVyIHN0YXRpYyBmaW5hbCBjb25zdCBhYnN0cmFjdCBjbGFzcyBleHRlbmRzIGV4dGVybmFsIGZhY3RvcnkgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbXBsZW1lbnRzIG1peGluIGdldCBuYXRpdmUgc2V0IHR5cGVkZWYgd2l0aCBlbnVtIHRocm93IHJldGhyb3cgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJhc3NlcnQgYnJlYWsgY2FzZSBjb250aW51ZSBkZWZhdWx0IGluIHJldHVybiBuZXcgZGVmZXJyZWQgYXN5bmMgYXdhaXQgY292YXJpYW50IFwiICtcbiAgICAgICAgICAgICAgICAgIFwidHJ5IGNhdGNoIGZpbmFsbHkgZG8gZWxzZSBmb3IgaWYgc3dpdGNoIHdoaWxlIGltcG9ydCBsaWJyYXJ5IGV4cG9ydCBcIiArXG4gICAgICAgICAgICAgICAgICBcInBhcnQgb2Ygc2hvdyBoaWRlIGlzIGFzIGV4dGVuc2lvbiBvbiB5aWVsZCBsYXRlIHJlcXVpcmVkXCIpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcInRyeSBjYXRjaCBmaW5hbGx5IGRvIGVsc2UgZm9yIGlmIHN3aXRjaCB3aGlsZVwiKSxcbiAgYnVpbHRpbjogd29yZHMoXCJ2b2lkIGJvb2wgbnVtIGludCBkb3VibGUgZHluYW1pYyB2YXIgU3RyaW5nIE51bGwgTmV2ZXJcIiksXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFwuXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG5cbiAgICAvLyBjdXN0b20gc3RyaW5nIGhhbmRsaW5nIHRvIGRlYWwgd2l0aCB0cmlwbGUtcXVvdGVkIHN0cmluZ3MgYW5kIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gICAgXCInXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiB0b2tlbkRhcnRTdHJpbmcoXCInXCIsIHN0cmVhbSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIFwiXFxcIlwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gdG9rZW5EYXJ0U3RyaW5nKFwiXFxcIlwiLCBzdHJlYW0sIHN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBcInJcIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgaWYgKHBlZWsgPT0gXCInXCIgfHwgcGVlayA9PSBcIlxcXCJcIikge1xuICAgICAgICByZXR1cm4gdG9rZW5EYXJ0U3RyaW5nKHN0cmVhbS5uZXh0KCksIHN0cmVhbSwgc3RhdGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBcIn1cIjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgIC8vIFwifVwiIGlzIGVuZCBvZiBpbnRlcnBvbGF0aW9uLCBpZiBpbnRlcnBvbGF0aW9uIHN0YWNrIGlzIG5vbi1lbXB0eVxuICAgICAgaWYgKHNpemVJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpID4gMCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudCgxKVxuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBfLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICAvLyBBc3N1bWUgdXBwZXJjYXNlIHN5bWJvbHMgYXJlIGNsYXNzZXNcbiAgICAgICAgdmFyIGlzVXBwZXIgPSBSZWdFeHAoJ15bXyRdKltBLVpdW2EtekEtWjAtOV8kXSokJywnZycpO1xuICAgICAgICBpZiAoaXNVcHBlci50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgcmV0dXJuICd0eXBlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==