"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_nginx_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/nginx.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/nginx.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nginx": () => (/* binding */ nginx)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = words(
  /* ngxDirectiveControl */ "break return rewrite set" +
    /* ngxDirective */ " accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23"
);

var keywords_block = words(
  /* ngxDirectiveBlock */ "http mail events server types location upstream charset_map limit_except if geo map"
);

var keywords_important = words(
  /* ngxDirectiveImportant */ "include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files"
);

var type;
function ret(style, tp) {type = tp; return style;}

function tokenBase(stream, state) {


  stream.eatWhile(/[\w\$_]/);

  var cur = stream.current();


  if (keywords.propertyIsEnumerable(cur)) {
    return "keyword";
  }
  else if (keywords_block.propertyIsEnumerable(cur)) {
    return "controlKeyword";
  }
  else if (keywords_important.propertyIsEnumerable(cur)) {
    return "controlKeyword";
  }
  /**/

  var ch = stream.next();
  if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("meta", stream.current());}
  else if (ch == "/" && stream.eat("*")) {
    state.tokenize = tokenCComment;
    return tokenCComment(stream, state);
  }
  else if (ch == "<" && stream.eat("!")) {
    state.tokenize = tokenSGMLComment;
    return tokenSGMLComment(stream, state);
  }
  else if (ch == "=") ret(null, "compare");
  else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
  else if (ch == "\"" || ch == "'") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }
  else if (ch == "#") {
    stream.skipToEnd();
    return ret("comment", "comment");
  }
  else if (ch == "!") {
    stream.match(/^\s*\w*/);
    return ret("keyword", "important");
  }
  else if (/\d/.test(ch)) {
    stream.eatWhile(/[\w.%]/);
    return ret("number", "unit");
  }
  else if (/[,.+>*\/]/.test(ch)) {
    return ret(null, "select-op");
  }
  else if (/[;{}:\[\]]/.test(ch)) {
    return ret(null, ch);
  }
  else {
    stream.eatWhile(/[\w\\\-]/);
    return ret("variable", "variable");
  }
}

function tokenCComment(stream, state) {
  var maybeEnd = false, ch;
  while ((ch = stream.next()) != null) {
    if (maybeEnd && ch == "/") {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return ret("comment", "comment");
}

function tokenSGMLComment(stream, state) {
  var dashes = 0, ch;
  while ((ch = stream.next()) != null) {
    if (dashes >= 2 && ch == ">") {
      state.tokenize = tokenBase;
      break;
    }
    dashes = (ch == "-") ? dashes + 1 : 0;
  }
  return ret("comment", "comment");
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped)
        break;
      escaped = !escaped && ch == "\\";
    }
    if (!escaped) state.tokenize = tokenBase;
    return ret("string", "string");
  };
}

const nginx = {
  startState: function() {
    return {tokenize: tokenBase,
            baseIndent: 0,
            stack: []};
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    type = null;
    var style = state.tokenize(stream, state);

    var context = state.stack[state.stack.length-1];
    if (type == "hash" && context == "rule") style = "atom";
    else if (style == "variable") {
      if (context == "rule") style = "number";
      else if (!context || context == "@media{") style = "tag";
    }

    if (context == "rule" && /^[\{\};]$/.test(type))
      state.stack.pop();
    if (type == "{") {
      if (context == "@media") state.stack[state.stack.length-1] = "@media{";
      else state.stack.push("{");
    }
    else if (type == "}") state.stack.pop();
    else if (type == "@media") state.stack.push("@media");
    else if (context == "{" && type != "comment") state.stack.push("rule");
    return style;
  },

  indent: function(state, textAfter, cx) {
    var n = state.stack.length;
    if (/^\}/.test(textAfter))
      n -= state.stack[state.stack.length-1] == "rule" ? 2 : 1;
    return state.baseIndent + n * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*\}$/
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfbmdpbnhfanMuYmE5MDkzOWUwODc4MzM2YzhkMTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFdBQVc7O0FBRXBDOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0Esa0JBQWtCO0FBQ2xCLDJFQUEyRTtBQUMzRSw4QkFBOEI7QUFDOUI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvbmdpbnguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGtleXdvcmRzID0gd29yZHMoXG4gIC8qIG5neERpcmVjdGl2ZUNvbnRyb2wgKi8gXCJicmVhayByZXR1cm4gcmV3cml0ZSBzZXRcIiArXG4gICAgLyogbmd4RGlyZWN0aXZlICovIFwiIGFjY2VwdF9tdXRleCBhY2NlcHRfbXV0ZXhfZGVsYXkgYWNjZXNzX2xvZyBhZGRfYWZ0ZXJfYm9keSBhZGRfYmVmb3JlX2JvZHkgYWRkX2hlYWRlciBhZGRpdGlvbl90eXBlcyBhaW8gYWxpYXMgYWxsb3cgYW5jaWVudF9icm93c2VyIGFuY2llbnRfYnJvd3Nlcl92YWx1ZSBhdXRoX2Jhc2ljIGF1dGhfYmFzaWNfdXNlcl9maWxlIGF1dGhfaHR0cCBhdXRoX2h0dHBfaGVhZGVyIGF1dGhfaHR0cF90aW1lb3V0IGF1dG9pbmRleCBhdXRvaW5kZXhfZXhhY3Rfc2l6ZSBhdXRvaW5kZXhfbG9jYWx0aW1lIGNoYXJzZXQgY2hhcnNldF90eXBlcyBjbGllbnRfYm9keV9idWZmZXJfc2l6ZSBjbGllbnRfYm9keV9pbl9maWxlX29ubHkgY2xpZW50X2JvZHlfaW5fc2luZ2xlX2J1ZmZlciBjbGllbnRfYm9keV90ZW1wX3BhdGggY2xpZW50X2JvZHlfdGltZW91dCBjbGllbnRfaGVhZGVyX2J1ZmZlcl9zaXplIGNsaWVudF9oZWFkZXJfdGltZW91dCBjbGllbnRfbWF4X2JvZHlfc2l6ZSBjb25uZWN0aW9uX3Bvb2xfc2l6ZSBjcmVhdGVfZnVsbF9wdXRfcGF0aCBkYWVtb24gZGF2X2FjY2VzcyBkYXZfbWV0aG9kcyBkZWJ1Z19jb25uZWN0aW9uIGRlYnVnX3BvaW50cyBkZWZhdWx0X3R5cGUgZGVncmFkYXRpb24gZGVncmFkZSBkZW55IGRldnBvbGxfY2hhbmdlcyBkZXZwb2xsX2V2ZW50cyBkaXJlY3RpbyBkaXJlY3Rpb19hbGlnbm1lbnQgZW1wdHlfZ2lmIGVudiBlcG9sbF9ldmVudHMgZXJyb3JfbG9nIGV2ZW50cG9ydF9ldmVudHMgZXhwaXJlcyBmYXN0Y2dpX2JpbmQgZmFzdGNnaV9idWZmZXJfc2l6ZSBmYXN0Y2dpX2J1ZmZlcnMgZmFzdGNnaV9idXN5X2J1ZmZlcnNfc2l6ZSBmYXN0Y2dpX2NhY2hlIGZhc3RjZ2lfY2FjaGVfa2V5IGZhc3RjZ2lfY2FjaGVfbWV0aG9kcyBmYXN0Y2dpX2NhY2hlX21pbl91c2VzIGZhc3RjZ2lfY2FjaGVfcGF0aCBmYXN0Y2dpX2NhY2hlX3VzZV9zdGFsZSBmYXN0Y2dpX2NhY2hlX3ZhbGlkIGZhc3RjZ2lfY2F0Y2hfc3RkZXJyIGZhc3RjZ2lfY29ubmVjdF90aW1lb3V0IGZhc3RjZ2lfaGlkZV9oZWFkZXIgZmFzdGNnaV9pZ25vcmVfY2xpZW50X2Fib3J0IGZhc3RjZ2lfaWdub3JlX2hlYWRlcnMgZmFzdGNnaV9pbmRleCBmYXN0Y2dpX2ludGVyY2VwdF9lcnJvcnMgZmFzdGNnaV9tYXhfdGVtcF9maWxlX3NpemUgZmFzdGNnaV9uZXh0X3Vwc3RyZWFtIGZhc3RjZ2lfcGFyYW0gZmFzdGNnaV9wYXNzX2hlYWRlciBmYXN0Y2dpX3Bhc3NfcmVxdWVzdF9ib2R5IGZhc3RjZ2lfcGFzc19yZXF1ZXN0X2hlYWRlcnMgZmFzdGNnaV9yZWFkX3RpbWVvdXQgZmFzdGNnaV9zZW5kX2xvd2F0IGZhc3RjZ2lfc2VuZF90aW1lb3V0IGZhc3RjZ2lfc3BsaXRfcGF0aF9pbmZvIGZhc3RjZ2lfc3RvcmUgZmFzdGNnaV9zdG9yZV9hY2Nlc3MgZmFzdGNnaV90ZW1wX2ZpbGVfd3JpdGVfc2l6ZSBmYXN0Y2dpX3RlbXBfcGF0aCBmYXN0Y2dpX3Vwc3RyZWFtX2ZhaWxfdGltZW91dCBmYXN0Y2dpX3Vwc3RyZWFtX21heF9mYWlscyBmbHYgZ2VvaXBfY2l0eSBnZW9pcF9jb3VudHJ5IGdvb2dsZV9wZXJmdG9vbHNfcHJvZmlsZXMgZ3ppcCBnemlwX2J1ZmZlcnMgZ3ppcF9jb21wX2xldmVsIGd6aXBfZGlzYWJsZSBnemlwX2hhc2ggZ3ppcF9odHRwX3ZlcnNpb24gZ3ppcF9taW5fbGVuZ3RoIGd6aXBfbm9fYnVmZmVyIGd6aXBfcHJveGllZCBnemlwX3N0YXRpYyBnemlwX3R5cGVzIGd6aXBfdmFyeSBnemlwX3dpbmRvdyBpZl9tb2RpZmllZF9zaW5jZSBpZ25vcmVfaW52YWxpZF9oZWFkZXJzIGltYWdlX2ZpbHRlciBpbWFnZV9maWx0ZXJfYnVmZmVyIGltYWdlX2ZpbHRlcl9qcGVnX3F1YWxpdHkgaW1hZ2VfZmlsdGVyX3RyYW5zcGFyZW5jeSBpbWFwX2F1dGggaW1hcF9jYXBhYmlsaXRpZXMgaW1hcF9jbGllbnRfYnVmZmVyIGluZGV4IGlwX2hhc2gga2VlcGFsaXZlX3JlcXVlc3RzIGtlZXBhbGl2ZV90aW1lb3V0IGtxdWV1ZV9jaGFuZ2VzIGtxdWV1ZV9ldmVudHMgbGFyZ2VfY2xpZW50X2hlYWRlcl9idWZmZXJzIGxpbWl0X2Nvbm4gbGltaXRfY29ubl9sb2dfbGV2ZWwgbGltaXRfcmF0ZSBsaW1pdF9yYXRlX2FmdGVyIGxpbWl0X3JlcSBsaW1pdF9yZXFfbG9nX2xldmVsIGxpbWl0X3JlcV96b25lIGxpbWl0X3pvbmUgbGluZ2VyaW5nX3RpbWUgbGluZ2VyaW5nX3RpbWVvdXQgbG9ja19maWxlIGxvZ19mb3JtYXQgbG9nX25vdF9mb3VuZCBsb2dfc3VicmVxdWVzdCBtYXBfaGFzaF9idWNrZXRfc2l6ZSBtYXBfaGFzaF9tYXhfc2l6ZSBtYXN0ZXJfcHJvY2VzcyBtZW1jYWNoZWRfYmluZCBtZW1jYWNoZWRfYnVmZmVyX3NpemUgbWVtY2FjaGVkX2Nvbm5lY3RfdGltZW91dCBtZW1jYWNoZWRfbmV4dF91cHN0cmVhbSBtZW1jYWNoZWRfcmVhZF90aW1lb3V0IG1lbWNhY2hlZF9zZW5kX3RpbWVvdXQgbWVtY2FjaGVkX3Vwc3RyZWFtX2ZhaWxfdGltZW91dCBtZW1jYWNoZWRfdXBzdHJlYW1fbWF4X2ZhaWxzIG1lcmdlX3NsYXNoZXMgbWluX2RlbGV0ZV9kZXB0aCBtb2Rlcm5fYnJvd3NlciBtb2Rlcm5fYnJvd3Nlcl92YWx1ZSBtc2llX3BhZGRpbmcgbXNpZV9yZWZyZXNoIG11bHRpX2FjY2VwdCBvcGVuX2ZpbGVfY2FjaGUgb3Blbl9maWxlX2NhY2hlX2Vycm9ycyBvcGVuX2ZpbGVfY2FjaGVfZXZlbnRzIG9wZW5fZmlsZV9jYWNoZV9taW5fdXNlcyBvcGVuX2ZpbGVfY2FjaGVfdmFsaWQgb3Blbl9sb2dfZmlsZV9jYWNoZSBvdXRwdXRfYnVmZmVycyBvdmVycmlkZV9jaGFyc2V0IHBlcmwgcGVybF9tb2R1bGVzIHBlcmxfcmVxdWlyZSBwZXJsX3NldCBwaWQgcG9wM19hdXRoIHBvcDNfY2FwYWJpbGl0aWVzIHBvcnRfaW5fcmVkaXJlY3QgcG9zdHBvbmVfZ3ppcHBpbmcgcG9zdHBvbmVfb3V0cHV0IHByb3RvY29sIHByb3h5IHByb3h5X2JpbmQgcHJveHlfYnVmZmVyIHByb3h5X2J1ZmZlcl9zaXplIHByb3h5X2J1ZmZlcmluZyBwcm94eV9idWZmZXJzIHByb3h5X2J1c3lfYnVmZmVyc19zaXplIHByb3h5X2NhY2hlIHByb3h5X2NhY2hlX2tleSBwcm94eV9jYWNoZV9tZXRob2RzIHByb3h5X2NhY2hlX21pbl91c2VzIHByb3h5X2NhY2hlX3BhdGggcHJveHlfY2FjaGVfdXNlX3N0YWxlIHByb3h5X2NhY2hlX3ZhbGlkIHByb3h5X2Nvbm5lY3RfdGltZW91dCBwcm94eV9oZWFkZXJzX2hhc2hfYnVja2V0X3NpemUgcHJveHlfaGVhZGVyc19oYXNoX21heF9zaXplIHByb3h5X2hpZGVfaGVhZGVyIHByb3h5X2lnbm9yZV9jbGllbnRfYWJvcnQgcHJveHlfaWdub3JlX2hlYWRlcnMgcHJveHlfaW50ZXJjZXB0X2Vycm9ycyBwcm94eV9tYXhfdGVtcF9maWxlX3NpemUgcHJveHlfbWV0aG9kIHByb3h5X25leHRfdXBzdHJlYW0gcHJveHlfcGFzc19lcnJvcl9tZXNzYWdlIHByb3h5X3Bhc3NfaGVhZGVyIHByb3h5X3Bhc3NfcmVxdWVzdF9ib2R5IHByb3h5X3Bhc3NfcmVxdWVzdF9oZWFkZXJzIHByb3h5X3JlYWRfdGltZW91dCBwcm94eV9yZWRpcmVjdCBwcm94eV9zZW5kX2xvd2F0IHByb3h5X3NlbmRfdGltZW91dCBwcm94eV9zZXRfYm9keSBwcm94eV9zZXRfaGVhZGVyIHByb3h5X3NzbF9zZXNzaW9uX3JldXNlIHByb3h5X3N0b3JlIHByb3h5X3N0b3JlX2FjY2VzcyBwcm94eV90ZW1wX2ZpbGVfd3JpdGVfc2l6ZSBwcm94eV90ZW1wX3BhdGggcHJveHlfdGltZW91dCBwcm94eV91cHN0cmVhbV9mYWlsX3RpbWVvdXQgcHJveHlfdXBzdHJlYW1fbWF4X2ZhaWxzIHJhbmRvbV9pbmRleCByZWFkX2FoZWFkIHJlYWxfaXBfaGVhZGVyIHJlY3Vyc2l2ZV9lcnJvcl9wYWdlcyByZXF1ZXN0X3Bvb2xfc2l6ZSByZXNldF90aW1lZG91dF9jb25uZWN0aW9uIHJlc29sdmVyIHJlc29sdmVyX3RpbWVvdXQgcmV3cml0ZV9sb2cgcnRzaWdfb3ZlcmZsb3dfZXZlbnRzIHJ0c2lnX292ZXJmbG93X3Rlc3QgcnRzaWdfb3ZlcmZsb3dfdGhyZXNob2xkIHJ0c2lnX3NpZ25vIHNhdGlzZnkgc2VjdXJlX2xpbmtfc2VjcmV0IHNlbmRfbG93YXQgc2VuZF90aW1lb3V0IHNlbmRmaWxlIHNlbmRmaWxlX21heF9jaHVuayBzZXJ2ZXJfbmFtZV9pbl9yZWRpcmVjdCBzZXJ2ZXJfbmFtZXNfaGFzaF9idWNrZXRfc2l6ZSBzZXJ2ZXJfbmFtZXNfaGFzaF9tYXhfc2l6ZSBzZXJ2ZXJfdG9rZW5zIHNldF9yZWFsX2lwX2Zyb20gc210cF9hdXRoIHNtdHBfY2FwYWJpbGl0aWVzIHNtdHBfY2xpZW50X2J1ZmZlciBzbXRwX2dyZWV0aW5nX2RlbGF5IHNvX2tlZXBhbGl2ZSBzb3VyY2VfY2hhcnNldCBzc2kgc3NpX2lnbm9yZV9yZWN5Y2xlZF9idWZmZXJzIHNzaV9taW5fZmlsZV9jaHVuayBzc2lfc2lsZW50X2Vycm9ycyBzc2lfdHlwZXMgc3NpX3ZhbHVlX2xlbmd0aCBzc2wgc3NsX2NlcnRpZmljYXRlIHNzbF9jZXJ0aWZpY2F0ZV9rZXkgc3NsX2NpcGhlcnMgc3NsX2NsaWVudF9jZXJ0aWZpY2F0ZSBzc2xfY3JsIHNzbF9kaHBhcmFtIHNzbF9lbmdpbmUgc3NsX3ByZWZlcl9zZXJ2ZXJfY2lwaGVycyBzc2xfcHJvdG9jb2xzIHNzbF9zZXNzaW9uX2NhY2hlIHNzbF9zZXNzaW9uX3RpbWVvdXQgc3NsX3ZlcmlmeV9jbGllbnQgc3NsX3ZlcmlmeV9kZXB0aCBzdGFydHRscyBzdHViX3N0YXR1cyBzdWJfZmlsdGVyIHN1Yl9maWx0ZXJfb25jZSBzdWJfZmlsdGVyX3R5cGVzIHRjcF9ub2RlbGF5IHRjcF9ub3B1c2ggdGhyZWFkX3N0YWNrX3NpemUgdGltZW91dCB0aW1lcl9yZXNvbHV0aW9uIHR5cGVzX2hhc2hfYnVja2V0X3NpemUgdHlwZXNfaGFzaF9tYXhfc2l6ZSB1bmRlcnNjb3Jlc19pbl9oZWFkZXJzIHVuaW5pdGlhbGl6ZWRfdmFyaWFibGVfd2FybiB1c2UgdXNlciB1c2VyaWQgdXNlcmlkX2RvbWFpbiB1c2VyaWRfZXhwaXJlcyB1c2VyaWRfbWFyayB1c2VyaWRfbmFtZSB1c2VyaWRfcDNwIHVzZXJpZF9wYXRoIHVzZXJpZF9zZXJ2aWNlIHZhbGlkX3JlZmVyZXJzIHZhcmlhYmxlc19oYXNoX2J1Y2tldF9zaXplIHZhcmlhYmxlc19oYXNoX21heF9zaXplIHdvcmtlcl9jb25uZWN0aW9ucyB3b3JrZXJfY3B1X2FmZmluaXR5IHdvcmtlcl9wcmlvcml0eSB3b3JrZXJfcHJvY2Vzc2VzIHdvcmtlcl9ybGltaXRfY29yZSB3b3JrZXJfcmxpbWl0X25vZmlsZSB3b3JrZXJfcmxpbWl0X3NpZ3BlbmRpbmcgd29ya2VyX3RocmVhZHMgd29ya2luZ19kaXJlY3RvcnkgeGNsaWVudCB4bWxfZW50aXRpZXMgeHNsdF9zdHlsZXNoZWV0IHhzbHRfdHlwZXNkcmV3QGxpMjI5LTIzXCJcbik7XG5cbnZhciBrZXl3b3Jkc19ibG9jayA9IHdvcmRzKFxuICAvKiBuZ3hEaXJlY3RpdmVCbG9jayAqLyBcImh0dHAgbWFpbCBldmVudHMgc2VydmVyIHR5cGVzIGxvY2F0aW9uIHVwc3RyZWFtIGNoYXJzZXRfbWFwIGxpbWl0X2V4Y2VwdCBpZiBnZW8gbWFwXCJcbik7XG5cbnZhciBrZXl3b3Jkc19pbXBvcnRhbnQgPSB3b3JkcyhcbiAgLyogbmd4RGlyZWN0aXZlSW1wb3J0YW50ICovIFwiaW5jbHVkZSByb290IHNlcnZlciBzZXJ2ZXJfbmFtZSBsaXN0ZW4gaW50ZXJuYWwgcHJveHlfcGFzcyBtZW1jYWNoZWRfcGFzcyBmYXN0Y2dpX3Bhc3MgdHJ5X2ZpbGVzXCJcbik7XG5cbnZhciB0eXBlO1xuZnVuY3Rpb24gcmV0KHN0eWxlLCB0cCkge3R5cGUgPSB0cDsgcmV0dXJuIHN0eWxlO31cblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcblxuXG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG5cbiAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG5cblxuICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuICBlbHNlIGlmIChrZXl3b3Jkc19ibG9jay5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgcmV0dXJuIFwiY29udHJvbEtleXdvcmRcIjtcbiAgfVxuICBlbHNlIGlmIChrZXl3b3Jkc19pbXBvcnRhbnQucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgIHJldHVybiBcImNvbnRyb2xLZXl3b3JkXCI7XG4gIH1cbiAgLyoqL1xuXG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSBcIkBcIikge3N0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7IHJldHVybiByZXQoXCJtZXRhXCIsIHN0cmVhbS5jdXJyZW50KCkpO31cbiAgZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0NvbW1lbnQ7XG4gICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZWxzZSBpZiAoY2ggPT0gXCI8XCIgJiYgc3RyZWFtLmVhdChcIiFcIikpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU0dNTENvbW1lbnQ7XG4gICAgcmV0dXJuIHRva2VuU0dNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHJldChudWxsLCBcImNvbXBhcmVcIik7XG4gIGVsc2UgaWYgKChjaCA9PSBcIn5cIiB8fCBjaCA9PSBcInxcIikgJiYgc3RyZWFtLmVhdChcIj1cIikpIHJldHVybiByZXQobnVsbCwgXCJjb21wYXJlXCIpO1xuICBlbHNlIGlmIChjaCA9PSBcIlxcXCJcIiB8fCBjaCA9PSBcIidcIikge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cbiAgZWxzZSBpZiAoY2ggPT0gXCIhXCIpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXHMqXFx3Ki8pO1xuICAgIHJldHVybiByZXQoXCJrZXl3b3JkXCIsIFwiaW1wb3J0YW50XCIpO1xuICB9XG4gIGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcInVuaXRcIik7XG4gIH1cbiAgZWxzZSBpZiAoL1ssLis+KlxcL10vLnRlc3QoY2gpKSB7XG4gICAgcmV0dXJuIHJldChudWxsLCBcInNlbGVjdC1vcFwiKTtcbiAgfVxuICBlbHNlIGlmICgvWzt7fTpcXFtcXF1dLy50ZXN0KGNoKSkge1xuICAgIHJldHVybiByZXQobnVsbCwgY2gpO1xuICB9XG4gIGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgcmV0dXJuIHJldChcInZhcmlhYmxlXCIsIFwidmFyaWFibGVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG59XG5cbmZ1bmN0aW9uIHRva2VuU0dNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgZGFzaGVzID0gMCwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKGRhc2hlcyA+PSAyICYmIGNoID09IFwiPlwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXNoZXMgPSAoY2ggPT0gXCItXCIpID8gZGFzaGVzICsgMSA6IDA7XG4gIH1cbiAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICBpZiAoIWVzY2FwZWQpIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBuZ2lueCA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgICAgYmFzZUluZGVudDogMCxcbiAgICAgICAgICAgIHN0YWNrOiBbXX07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHR5cGUgPSBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgdmFyIGNvbnRleHQgPSBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV07XG4gICAgaWYgKHR5cGUgPT0gXCJoYXNoXCIgJiYgY29udGV4dCA9PSBcInJ1bGVcIikgc3R5bGUgPSBcImF0b21cIjtcbiAgICBlbHNlIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIGlmIChjb250ZXh0ID09IFwicnVsZVwiKSBzdHlsZSA9IFwibnVtYmVyXCI7XG4gICAgICBlbHNlIGlmICghY29udGV4dCB8fCBjb250ZXh0ID09IFwiQG1lZGlhe1wiKSBzdHlsZSA9IFwidGFnXCI7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgPT0gXCJydWxlXCIgJiYgL15bXFx7XFx9O10kLy50ZXN0KHR5cGUpKVxuICAgICAgc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHtcbiAgICAgIGlmIChjb250ZXh0ID09IFwiQG1lZGlhXCIpIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9IFwiQG1lZGlhe1wiO1xuICAgICAgZWxzZSBzdGF0ZS5zdGFjay5wdXNoKFwie1wiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSBcIn1cIikgc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgZWxzZSBpZiAodHlwZSA9PSBcIkBtZWRpYVwiKSBzdGF0ZS5zdGFjay5wdXNoKFwiQG1lZGlhXCIpO1xuICAgIGVsc2UgaWYgKGNvbnRleHQgPT0gXCJ7XCIgJiYgdHlwZSAhPSBcImNvbW1lbnRcIikgc3RhdGUuc3RhY2sucHVzaChcInJ1bGVcIik7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLmxlbmd0aDtcbiAgICBpZiAoL15cXH0vLnRlc3QodGV4dEFmdGVyKSlcbiAgICAgIG4gLT0gc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdID09IFwicnVsZVwiID8gMiA6IDE7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VJbmRlbnQgKyBuICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypcXH0kL1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9