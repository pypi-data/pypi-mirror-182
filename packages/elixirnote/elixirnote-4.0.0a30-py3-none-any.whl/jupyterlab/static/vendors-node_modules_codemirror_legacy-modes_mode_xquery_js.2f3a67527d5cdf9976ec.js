"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_xquery_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "xQuery": () => (/* binding */ xQuery)
/* harmony export */ });
// The keywords object is set to the result of this self executing
// function. Each keyword is a property of the keywords object whose
// value is {type: atype, style: astyle}
var keywords = function(){
  // convenience functions used to build keywords object
  function kw(type) {return {type: type, style: "keyword"};}
  var operator = kw("operator")
  , atom = {type: "atom", style: "atom"}
  , punctuation = {type: "punctuation", style: null}
  , qualifier = {type: "axis_specifier", style: "qualifier"};

  // kwObj is what is return from this function at the end
  var kwObj = {
    ',': punctuation
  };

  // a list of 'basic' keywords. For each add a property to kwObj with the value of
  // {type: basic[i], style: "keyword"} e.g. 'after' --> {type: "after", style: "keyword"}
  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',
               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',
               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',
               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',
               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',
               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',
               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',
               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',
               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',
               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',
               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',
               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',
               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',
               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',
               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',
               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',
               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',
               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',
               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',
               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];
  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};

  // a list of types. For each add a property to kwObj with the value of
  // {type: "atom", style: "atom"}
  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',
               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',
               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',
               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',
               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',
               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',
               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',
               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',
               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',
               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];
  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};

  // each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];
  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};

  // each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
  var axis_specifiers = ["self::", "attribute::", "child::", "descendant::", "descendant-or-self::", "parent::",
                         "ancestor::", "ancestor-or-self::", "following::", "preceding::", "following-sibling::", "preceding-sibling::"];
  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };

  return kwObj;
}();

function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

// the primary mode tokenizer
function tokenBase(stream, state) {
  var ch = stream.next(),
      mightBeFunction = false,
      isEQName = isEQNameAhead(stream);

  // an XML tag (if not in some sub, chained tokenizer)
  if (ch == "<") {
    if(stream.match("!--", true))
      return chain(stream, state, tokenXMLComment);

    if(stream.match("![CDATA", false)) {
      state.tokenize = tokenCDATA;
      return "tag";
    }

    if(stream.match("?", false)) {
      return chain(stream, state, tokenPreProcessing);
    }

    var isclose = stream.eat("/");
    stream.eatSpace();
    var tagName = "", c;
    while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;

    return chain(stream, state, tokenTag(tagName, isclose));
  }
  // start code block
  else if(ch == "{") {
    pushStateStack(state, { type: "codeblock"});
    return null;
  }
  // end code block
  else if(ch == "}") {
    popStateStack(state);
    return null;
  }
  // if we're in an XML block
  else if(isInXmlBlock(state)) {
    if(ch == ">")
      return "tag";
    else if(ch == "/" && stream.eat(">")) {
      popStateStack(state);
      return "tag";
    }
    else
      return "variable";
  }
  // if a number
  else if (/\d/.test(ch)) {
    stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
    return "atom";
  }
  // comment start
  else if (ch === "(" && stream.eat(":")) {
    pushStateStack(state, { type: "comment"});
    return chain(stream, state, tokenComment);
  }
  // quoted string
  else if (!isEQName && (ch === '"' || ch === "'"))
    return chain(stream, state, tokenString(ch));
  // variable
  else if(ch === "$") {
    return chain(stream, state, tokenVariable);
  }
  // assignment
  else if(ch ===":" && stream.eat("=")) {
    return "keyword";
  }
  // open paren
  else if(ch === "(") {
    pushStateStack(state, { type: "paren"});
    return null;
  }
  // close paren
  else if(ch === ")") {
    popStateStack(state);
    return null;
  }
  // open paren
  else if(ch === "[") {
    pushStateStack(state, { type: "bracket"});
    return null;
  }
  // close paren
  else if(ch === "]") {
    popStateStack(state);
    return null;
  }
  else {
    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];

    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function
    if(isEQName && ch === '\"') while(stream.next() !== '"'){}
    if(isEQName && ch === '\'') while(stream.next() !== '\''){}

    // gobble up a word if the character is not known
    if(!known) stream.eatWhile(/[\w\$_-]/);

    // gobble a colon in the case that is a lib func type call fn:doc
    var foundColon = stream.eat(":");

    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
    // which should get matched as a keyword
    if(!stream.eat(":") && foundColon) {
      stream.eatWhile(/[\w\$_-]/);
    }
    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
    if(stream.match(/^[ \t]*\(/, false)) {
      mightBeFunction = true;
    }
    // is the word a keyword?
    var word = stream.current();
    known = keywords.propertyIsEnumerable(word) && keywords[word];

    // if we think it's a function call but not yet known,
    // set style to variable for now for lack of something better
    if(mightBeFunction && !known) known = {type: "function_call", style: "def"};

    // if the previous word was element, attribute, axis specifier, this word should be the name of that
    if(isInXmlConstructor(state)) {
      popStateStack(state);
      return "variable";
    }
    // as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
    // push the stack so we know to look for it on the next word
    if(word == "element" || word == "attribute" || known.type == "axis_specifier") pushStateStack(state, {type: "xmlconstructor"});

    // if the word is known, return the details of that else just call this a generic 'word'
    return known ? known.style : "variable";
  }
}

// handle comments, including nested
function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while (ch = stream.next()) {
    if (ch == ")" && maybeEnd) {
      if(nestedCount > 0)
        nestedCount--;
      else {
        popStateStack(state);
        break;
      }
    }
    else if(ch == ":" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == ":");
    maybeNested = (ch == "(");
  }

  return "comment";
}

// tokenizer for string literals
// optionally pass a tokenizer function to set state.tokenize back to when finished
function tokenString(quote, f) {
  return function(stream, state) {
    var ch;

    if(isInString(state) && stream.current() == quote) {
      popStateStack(state);
      if(f) state.tokenize = f;
      return "string";
    }

    pushStateStack(state, { type: "string", name: quote, tokenize: tokenString(quote, f) });

    // if we're in a string and in an XML block, allow an embedded code block
    if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
      state.tokenize = tokenBase;
      return "string";
    }


    while (ch = stream.next()) {
      if (ch ==  quote) {
        popStateStack(state);
        if(f) state.tokenize = f;
        break;
      }
      else {
        // if we're in a string and in an XML block, allow an embedded code block in an attribute
        if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
          state.tokenize = tokenBase;
          return "string";
        }

      }
    }

    return "string";
  };
}

// tokenizer for variables
function tokenVariable(stream, state) {
  var isVariableChar = /[\w\$_-]/;

  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
  if(stream.eat("\"")) {
    while(stream.next() !== '\"'){};
    stream.eat(":");
  } else {
    stream.eatWhile(isVariableChar);
    if(!stream.match(":=", false)) stream.eat(":");
  }
  stream.eatWhile(isVariableChar);
  state.tokenize = tokenBase;
  return "variable";
}

// tokenizer for XML tags
function tokenTag(name, isclose) {
  return function(stream, state) {
    stream.eatSpace();
    if(isclose && stream.eat(">")) {
      popStateStack(state);
      state.tokenize = tokenBase;
      return "tag";
    }
    // self closing tag without attributes?
    if(!stream.eat("/"))
      pushStateStack(state, { type: "tag", name: name, tokenize: tokenBase});
    if(!stream.eat(">")) {
      state.tokenize = tokenAttribute;
      return "tag";
    }
    else {
      state.tokenize = tokenBase;
    }
    return "tag";
  };
}

// tokenizer for XML attributes
function tokenAttribute(stream, state) {
  var ch = stream.next();

  if(ch == "/" && stream.eat(">")) {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    if(isInXmlBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == ">") {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == "=")
    return null;
  // quoted string
  if (ch == '"' || ch == "'")
    return chain(stream, state, tokenString(ch, tokenAttribute));

  if(!isInXmlAttributeBlock(state))
    pushStateStack(state, { type: "attribute", tokenize: tokenAttribute});

  stream.eat(/[a-zA-Z_:]/);
  stream.eatWhile(/[-a-zA-Z0-9_:.]/);
  stream.eatSpace();

  // the case where the attribute has not value and the tag was closed
  if(stream.match(">", false) || stream.match("/", false)) {
    popStateStack(state);
    state.tokenize = tokenBase;
  }

  return "attribute";
}

// handle comments, including nested
function tokenXMLComment(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "-" && stream.match("->", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}


// handle CDATA
function tokenCDATA(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "]" && stream.match("]", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}

// handle preprocessing instructions
function tokenPreProcessing(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "?" && stream.match(">", true)) {
      state.tokenize = tokenBase;
      return "processingInstruction";
    }
  }
}


// functions to test the current context of the state
function isInXmlBlock(state) { return isIn(state, "tag"); }
function isInXmlAttributeBlock(state) { return isIn(state, "attribute"); }
function isInXmlConstructor(state) { return isIn(state, "xmlconstructor"); }
function isInString(state) { return isIn(state, "string"); }

function isEQNameAhead(stream) {
  // assume we've already eaten a quote (")
  if(stream.current() === '"')
    return stream.match(/^[^\"]+\"\:/, false);
  else if(stream.current() === '\'')
    return stream.match(/^[^\"]+\'\:/, false);
  else
    return false;
}

function isIn(state, type) {
  return (state.stack.length && state.stack[state.stack.length - 1].type == type);
}

function pushStateStack(state, newState) {
  state.stack.push(newState);
}

function popStateStack(state) {
  state.stack.pop();
  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;
  state.tokenize = reinstateTokenize || tokenBase;
}

// the interface for the mode API
const xQuery = {
  startState: function() {
    return {
      tokenize: tokenBase,
      cc: [],
      stack: []
    };
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);
    return style;
  },

  languageData: {
    commentTokens: {block: {open: "(:", close: ":)"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV94cXVlcnlfanMuMmYzYTY3NTI3ZDVjZGY5OTc2ZWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBa0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxPQUFPOztBQUU3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU87O0FBRTdDLCtEQUErRDtBQUMvRDtBQUNBLG1DQUFtQyxPQUFPLE9BQU87O0FBRWpELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTzs7QUFFdkQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHVCQUF1Qjs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw4REFBOEQ7O0FBRTFGO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDRDQUE0Qzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3hxdWVyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUga2V5d29yZHMgb2JqZWN0IGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoaXMgc2VsZiBleGVjdXRpbmdcbi8vIGZ1bmN0aW9uLiBFYWNoIGtleXdvcmQgaXMgYSBwcm9wZXJ0eSBvZiB0aGUga2V5d29yZHMgb2JqZWN0IHdob3NlXG4vLyB2YWx1ZSBpcyB7dHlwZTogYXR5cGUsIHN0eWxlOiBhc3R5bGV9XG52YXIga2V5d29yZHMgPSBmdW5jdGlvbigpe1xuICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbnMgdXNlZCB0byBidWlsZCBrZXl3b3JkcyBvYmplY3RcbiAgZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG4gIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIilcbiAgLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9XG4gICwgcHVuY3R1YXRpb24gPSB7dHlwZTogXCJwdW5jdHVhdGlvblwiLCBzdHlsZTogbnVsbH1cbiAgLCBxdWFsaWZpZXIgPSB7dHlwZTogXCJheGlzX3NwZWNpZmllclwiLCBzdHlsZTogXCJxdWFsaWZpZXJcIn07XG5cbiAgLy8ga3dPYmogaXMgd2hhdCBpcyByZXR1cm4gZnJvbSB0aGlzIGZ1bmN0aW9uIGF0IHRoZSBlbmRcbiAgdmFyIGt3T2JqID0ge1xuICAgICcsJzogcHVuY3R1YXRpb25cbiAgfTtcblxuICAvLyBhIGxpc3Qgb2YgJ2Jhc2ljJyBrZXl3b3Jkcy4gRm9yIGVhY2ggYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB0aGUgdmFsdWUgb2ZcbiAgLy8ge3R5cGU6IGJhc2ljW2ldLCBzdHlsZTogXCJrZXl3b3JkXCJ9IGUuZy4gJ2FmdGVyJyAtLT4ge3R5cGU6IFwiYWZ0ZXJcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICB2YXIgYmFzaWMgPSBbJ2FmdGVyJywgJ2FsbCcsICdhbGxvd2luZycsICdhbmNlc3RvcicsICdhbmNlc3Rvci1vci1zZWxmJywgJ2FueScsICdhcnJheScsICdhcycsXG4gICAgICAgICAgICAgICAnYXNjZW5kaW5nJywgJ2F0JywgJ2F0dHJpYnV0ZScsICdiYXNlLXVyaScsICdiZWZvcmUnLCAnYm91bmRhcnktc3BhY2UnLCAnYnknLCAnY2FzZScsICdjYXN0JyxcbiAgICAgICAgICAgICAgICdjYXN0YWJsZScsICdjYXRjaCcsICdjaGlsZCcsICdjb2xsYXRpb24nLCAnY29tbWVudCcsICdjb25zdHJ1Y3Rpb24nLCAnY29udGFpbnMnLCAnY29udGVudCcsXG4gICAgICAgICAgICAgICAnY29udGV4dCcsICdjb3B5JywgJ2NvcHktbmFtZXNwYWNlcycsICdjb3VudCcsICdkZWNpbWFsLWZvcm1hdCcsICdkZWNsYXJlJywgJ2RlZmF1bHQnLCAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICdkZXNjZW5kYW50JywgJ2Rlc2NlbmRhbnQtb3Itc2VsZicsICdkZXNjZW5kaW5nJywgJ2RpYWNyaXRpY3MnLCAnZGlmZmVyZW50JywgJ2Rpc3RhbmNlJyxcbiAgICAgICAgICAgICAgICdkb2N1bWVudCcsICdkb2N1bWVudC1ub2RlJywgJ2VsZW1lbnQnLCAnZWxzZScsICdlbXB0eScsICdlbXB0eS1zZXF1ZW5jZScsICdlbmNvZGluZycsICdlbmQnLFxuICAgICAgICAgICAgICAgJ2VudGlyZScsICdldmVyeScsICdleGFjdGx5JywgJ2V4Y2VwdCcsICdleHRlcm5hbCcsICdmaXJzdCcsICdmb2xsb3dpbmcnLCAnZm9sbG93aW5nLXNpYmxpbmcnLFxuICAgICAgICAgICAgICAgJ2ZvcicsICdmcm9tJywgJ2Z0YW5kJywgJ2Z0bm90JywgJ2Z0LW9wdGlvbicsICdmdG9yJywgJ2Z1bmN0aW9uJywgJ2Z1enp5JywgJ2dyZWF0ZXN0JywgJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICdpZicsICdpbXBvcnQnLCAnaW4nLCAnaW5oZXJpdCcsICdpbnNlbnNpdGl2ZScsICdpbnNlcnQnLCAnaW5zdGFuY2UnLCAnaW50ZXJzZWN0JywgJ2ludG8nLFxuICAgICAgICAgICAgICAgJ2ludm9rZScsICdpcycsICdpdGVtJywgJ2xhbmd1YWdlJywgJ2xhc3QnLCAnbGF4JywgJ2xlYXN0JywgJ2xldCcsICdsZXZlbHMnLCAnbG93ZXJjYXNlJywgJ21hcCcsXG4gICAgICAgICAgICAgICAnbW9kaWZ5JywgJ21vZHVsZScsICdtb3N0JywgJ25hbWVzcGFjZScsICduZXh0JywgJ25vJywgJ25vZGUnLCAnbm9kZXMnLCAnbm8taW5oZXJpdCcsXG4gICAgICAgICAgICAgICAnbm8tcHJlc2VydmUnLCAnbm90JywgJ29jY3VycycsICdvZicsICdvbmx5JywgJ29wdGlvbicsICdvcmRlcicsICdvcmRlcmVkJywgJ29yZGVyaW5nJyxcbiAgICAgICAgICAgICAgICdwYXJhZ3JhcGgnLCAncGFyYWdyYXBocycsICdwYXJlbnQnLCAncGhyYXNlJywgJ3ByZWNlZGluZycsICdwcmVjZWRpbmctc2libGluZycsICdwcmVzZXJ2ZScsXG4gICAgICAgICAgICAgICAncHJldmlvdXMnLCAncHJvY2Vzc2luZy1pbnN0cnVjdGlvbicsICdyZWxhdGlvbnNoaXAnLCAncmVuYW1lJywgJ3JlcGxhY2UnLCAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICdyZXZhbGlkYXRpb24nLCAnc2FtZScsICdzYXRpc2ZpZXMnLCAnc2NoZW1hJywgJ3NjaGVtYS1hdHRyaWJ1dGUnLCAnc2NoZW1hLWVsZW1lbnQnLCAnc2NvcmUnLFxuICAgICAgICAgICAgICAgJ3NlbGYnLCAnc2Vuc2l0aXZlJywgJ3NlbnRlbmNlJywgJ3NlbnRlbmNlcycsICdzZXF1ZW5jZScsICdza2lwJywgJ3NsaWRpbmcnLCAnc29tZScsICdzdGFibGUnLFxuICAgICAgICAgICAgICAgJ3N0YXJ0JywgJ3N0ZW1taW5nJywgJ3N0b3AnLCAnc3RyaWN0JywgJ3N0cmlwJywgJ3N3aXRjaCcsICd0ZXh0JywgJ3RoZW4nLCAndGhlc2F1cnVzJywgJ3RpbWVzJyxcbiAgICAgICAgICAgICAgICd0bycsICd0cmFuc2Zvcm0nLCAndHJlYXQnLCAndHJ5JywgJ3R1bWJsaW5nJywgJ3R5cGUnLCAndHlwZXN3aXRjaCcsICd1bmlvbicsICd1bm9yZGVyZWQnLFxuICAgICAgICAgICAgICAgJ3VwZGF0ZScsICd1cGRhdGluZycsICd1cHBlcmNhc2UnLCAndXNpbmcnLCAndmFsaWRhdGUnLCAndmFsdWUnLCAndmFyaWFibGUnLCAndmVyc2lvbicsXG4gICAgICAgICAgICAgICAnd2VpZ2h0JywgJ3doZW4nLCAnd2hlcmUnLCAnd2lsZGNhcmRzJywgJ3dpbmRvdycsICd3aXRoJywgJ3dpdGhvdXQnLCAnd29yZCcsICd3b3JkcycsICd4cXVlcnknXTtcbiAgZm9yKHZhciBpPTAsIGw9YmFzaWMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW2Jhc2ljW2ldXSA9IGt3KGJhc2ljW2ldKTt9O1xuXG4gIC8vIGEgbGlzdCBvZiB0eXBlcy4gRm9yIGVhY2ggYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB0aGUgdmFsdWUgb2ZcbiAgLy8ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9XG4gIHZhciB0eXBlcyA9IFsneHM6YW55QXRvbWljVHlwZScsICd4czphbnlTaW1wbGVUeXBlJywgJ3hzOmFueVR5cGUnLCAneHM6YW55VVJJJyxcbiAgICAgICAgICAgICAgICd4czpiYXNlNjRCaW5hcnknLCAneHM6Ym9vbGVhbicsICd4czpieXRlJywgJ3hzOmRhdGUnLCAneHM6ZGF0ZVRpbWUnLCAneHM6ZGF0ZVRpbWVTdGFtcCcsXG4gICAgICAgICAgICAgICAneHM6ZGF5VGltZUR1cmF0aW9uJywgJ3hzOmRlY2ltYWwnLCAneHM6ZG91YmxlJywgJ3hzOmR1cmF0aW9uJywgJ3hzOkVOVElUSUVTJywgJ3hzOkVOVElUWScsXG4gICAgICAgICAgICAgICAneHM6ZmxvYXQnLCAneHM6Z0RheScsICd4czpnTW9udGgnLCAneHM6Z01vbnRoRGF5JywgJ3hzOmdZZWFyJywgJ3hzOmdZZWFyTW9udGgnLCAneHM6aGV4QmluYXJ5JyxcbiAgICAgICAgICAgICAgICd4czpJRCcsICd4czpJRFJFRicsICd4czpJRFJFRlMnLCAneHM6aW50JywgJ3hzOmludGVnZXInLCAneHM6aXRlbScsICd4czpqYXZhJywgJ3hzOmxhbmd1YWdlJyxcbiAgICAgICAgICAgICAgICd4czpsb25nJywgJ3hzOk5hbWUnLCAneHM6TkNOYW1lJywgJ3hzOm5lZ2F0aXZlSW50ZWdlcicsICd4czpOTVRPS0VOJywgJ3hzOk5NVE9LRU5TJyxcbiAgICAgICAgICAgICAgICd4czpub25OZWdhdGl2ZUludGVnZXInLCAneHM6bm9uUG9zaXRpdmVJbnRlZ2VyJywgJ3hzOm5vcm1hbGl6ZWRTdHJpbmcnLCAneHM6Tk9UQVRJT04nLFxuICAgICAgICAgICAgICAgJ3hzOm51bWVyaWMnLCAneHM6cG9zaXRpdmVJbnRlZ2VyJywgJ3hzOnByZWNpc2lvbkRlY2ltYWwnLCAneHM6UU5hbWUnLCAneHM6c2hvcnQnLCAneHM6c3RyaW5nJyxcbiAgICAgICAgICAgICAgICd4czp0aW1lJywgJ3hzOnRva2VuJywgJ3hzOnVuc2lnbmVkQnl0ZScsICd4czp1bnNpZ25lZEludCcsICd4czp1bnNpZ25lZExvbmcnLFxuICAgICAgICAgICAgICAgJ3hzOnVuc2lnbmVkU2hvcnQnLCAneHM6dW50eXBlZCcsICd4czp1bnR5cGVkQXRvbWljJywgJ3hzOnllYXJNb250aER1cmF0aW9uJ107XG4gIGZvcih2YXIgaT0wLCBsPXR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialt0eXBlc1tpXV0gPSBhdG9tO307XG5cbiAgLy8gZWFjaCBvcGVyYXRvciB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwib3BlcmF0b3JcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICB2YXIgb3BlcmF0b3JzID0gWydlcScsICduZScsICdsdCcsICdsZScsICdndCcsICdnZScsICc6PScsICc9JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICcuJywgJ3wnLCAnPycsICdhbmQnLCAnb3InLCAnZGl2JywgJ2lkaXYnLCAnbW9kJywgJyonLCAnLycsICcrJywgJy0nXTtcbiAgZm9yKHZhciBpPTAsIGw9b3BlcmF0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtvcGVyYXRvcnNbaV1dID0gb3BlcmF0b3I7fTtcblxuICAvLyBlYWNoIGF4aXNfc3BlY2lmaWVycyB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9XG4gIHZhciBheGlzX3NwZWNpZmllcnMgPSBbXCJzZWxmOjpcIiwgXCJhdHRyaWJ1dGU6OlwiLCBcImNoaWxkOjpcIiwgXCJkZXNjZW5kYW50OjpcIiwgXCJkZXNjZW5kYW50LW9yLXNlbGY6OlwiLCBcInBhcmVudDo6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmNlc3Rvcjo6XCIsIFwiYW5jZXN0b3Itb3Itc2VsZjo6XCIsIFwiZm9sbG93aW5nOjpcIiwgXCJwcmVjZWRpbmc6OlwiLCBcImZvbGxvd2luZy1zaWJsaW5nOjpcIiwgXCJwcmVjZWRpbmctc2libGluZzo6XCJdO1xuICBmb3IodmFyIGk9MCwgbD1heGlzX3NwZWNpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW2F4aXNfc3BlY2lmaWVyc1tpXV0gPSBxdWFsaWZpZXI7IH07XG5cbiAgcmV0dXJuIGt3T2JqO1xufSgpO1xuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIHRoZSBwcmltYXJ5IG1vZGUgdG9rZW5pemVyXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpLFxuICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gZmFsc2UsXG4gICAgICBpc0VRTmFtZSA9IGlzRVFOYW1lQWhlYWQoc3RyZWFtKTtcblxuICAvLyBhbiBYTUwgdGFnIChpZiBub3QgaW4gc29tZSBzdWIsIGNoYWluZWQgdG9rZW5pemVyKVxuICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICBpZihzdHJlYW0ubWF0Y2goXCIhLS1cIiwgdHJ1ZSkpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5YTUxDb21tZW50KTtcblxuICAgIGlmKHN0cmVhbS5tYXRjaChcIiFbQ0RBVEFcIiwgZmFsc2UpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0RBVEE7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG5cbiAgICBpZihzdHJlYW0ubWF0Y2goXCI/XCIsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuUHJlUHJvY2Vzc2luZyk7XG4gICAgfVxuXG4gICAgdmFyIGlzY2xvc2UgPSBzdHJlYW0uZWF0KFwiL1wiKTtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICB2YXIgdGFnTmFtZSA9IFwiXCIsIGM7XG4gICAgd2hpbGUgKChjID0gc3RyZWFtLmVhdCgvW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcLz9dLykpKSB0YWdOYW1lICs9IGM7XG5cbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5UYWcodGFnTmFtZSwgaXNjbG9zZSkpO1xuICB9XG4gIC8vIHN0YXJ0IGNvZGUgYmxvY2tcbiAgZWxzZSBpZihjaCA9PSBcIntcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29kZWJsb2NrXCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBlbmQgY29kZSBibG9ja1xuICBlbHNlIGlmKGNoID09IFwifVwiKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gaWYgd2UncmUgaW4gYW4gWE1MIGJsb2NrXG4gIGVsc2UgaWYoaXNJblhtbEJsb2NrKHN0YXRlKSkge1xuICAgIGlmKGNoID09IFwiPlwiKVxuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgZWxzZSBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuICAvLyBpZiBhIG51bWJlclxuICBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKT8oPzpFWytcXC1dP1xcZCspPy8pO1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuICAvLyBjb21tZW50IHN0YXJ0XG4gIGVsc2UgaWYgKGNoID09PSBcIihcIiAmJiBzdHJlYW0uZWF0KFwiOlwiKSkge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29tbWVudFwifSk7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQ29tbWVudCk7XG4gIH1cbiAgLy8gcXVvdGVkIHN0cmluZ1xuICBlbHNlIGlmICghaXNFUU5hbWUgJiYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikpXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gIC8vIHZhcmlhYmxlXG4gIGVsc2UgaWYoY2ggPT09IFwiJFwiKSB7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVmFyaWFibGUpO1xuICB9XG4gIC8vIGFzc2lnbm1lbnRcbiAgZWxzZSBpZihjaCA9PT1cIjpcIiAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiKFwiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJwYXJlblwifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gY2xvc2UgcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCIpXCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiW1wiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJicmFja2V0XCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBjbG9zZSBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIl1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGNoKSAmJiBrZXl3b3Jkc1tjaF07XG5cbiAgICAvLyBpZiB0aGVyZSdzIGEgRVFOYW1lIGFoZWFkLCBjb25zdW1lIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgcG9ydGlvbiwgaXQncyBsaWtlbHkgYSBmdW5jdGlvblxuICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFxcIicpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcIicpe31cbiAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcJycpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXCcnKXt9XG5cbiAgICAvLyBnb2JibGUgdXAgYSB3b3JkIGlmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGtub3duXG4gICAgaWYoIWtub3duKSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcblxuICAgIC8vIGdvYmJsZSBhIGNvbG9uIGluIHRoZSBjYXNlIHRoYXQgaXMgYSBsaWIgZnVuYyB0eXBlIGNhbGwgZm46ZG9jXG4gICAgdmFyIGZvdW5kQ29sb24gPSBzdHJlYW0uZWF0KFwiOlwiKTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgbm90IGEgc2Vjb25kIGNvbG9uLCBnb2JibGUgYW5vdGhlciB3b3JkLiBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgYW4gYXhpcyBzcGVjaWZpZXJcbiAgICAvLyB3aGljaCBzaG91bGQgZ2V0IG1hdGNoZWQgYXMgYSBrZXl3b3JkXG4gICAgaWYoIXN0cmVhbS5lYXQoXCI6XCIpICYmIGZvdW5kQ29sb24pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF8tXS8pO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbmV4dCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgYW4gb3BlbiBwYXJlbiwgdGhpcyBpcyBwcm9iYWJseSBhIGZ1bmN0aW9uIChpZiBub3QgYSBrZXl3b3JkIG9mIG90aGVyIHNvcnQpXG4gICAgaWYoc3RyZWFtLm1hdGNoKC9eWyBcXHRdKlxcKC8sIGZhbHNlKSkge1xuICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaXMgdGhlIHdvcmQgYSBrZXl3b3JkP1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpICYmIGtleXdvcmRzW3dvcmRdO1xuXG4gICAgLy8gaWYgd2UgdGhpbmsgaXQncyBhIGZ1bmN0aW9uIGNhbGwgYnV0IG5vdCB5ZXQga25vd24sXG4gICAgLy8gc2V0IHN0eWxlIHRvIHZhcmlhYmxlIGZvciBub3cgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlclxuICAgIGlmKG1pZ2h0QmVGdW5jdGlvbiAmJiAha25vd24pIGtub3duID0ge3R5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLCBzdHlsZTogXCJkZWZcIn07XG5cbiAgICAvLyBpZiB0aGUgcHJldmlvdXMgd29yZCB3YXMgZWxlbWVudCwgYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgdGhpcyB3b3JkIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGF0XG4gICAgaWYoaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICAvLyBhcyBwcmV2aW91c2x5IGNoZWNrZWQsIGlmIHRoZSB3b3JkIGlzIGVsZW1lbnQsYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgY2FsbCBpdCBhbiBcInhtbGNvbnN0cnVjdG9yXCIgYW5kXG4gICAgLy8gcHVzaCB0aGUgc3RhY2sgc28gd2Uga25vdyB0byBsb29rIGZvciBpdCBvbiB0aGUgbmV4dCB3b3JkXG4gICAgaWYod29yZCA9PSBcImVsZW1lbnRcIiB8fCB3b3JkID09IFwiYXR0cmlidXRlXCIgfHwga25vd24udHlwZSA9PSBcImF4aXNfc3BlY2lmaWVyXCIpIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7dHlwZTogXCJ4bWxjb25zdHJ1Y3RvclwifSk7XG5cbiAgICAvLyBpZiB0aGUgd29yZCBpcyBrbm93biwgcmV0dXJuIHRoZSBkZXRhaWxzIG9mIHRoYXQgZWxzZSBqdXN0IGNhbGwgdGhpcyBhIGdlbmVyaWMgJ3dvcmQnXG4gICAgcmV0dXJuIGtub3duID8ga25vd24uc3R5bGUgOiBcInZhcmlhYmxlXCI7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgbWF5YmVOZXN0ZWQgPSBmYWxzZSwgbmVzdGVkQ291bnQgPSAwLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIilcIiAmJiBtYXliZUVuZCkge1xuICAgICAgaWYobmVzdGVkQ291bnQgPiAwKVxuICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZihjaCA9PSBcIjpcIiAmJiBtYXliZU5lc3RlZCkge1xuICAgICAgbmVzdGVkQ291bnQrKztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCI6XCIpO1xuICAgIG1heWJlTmVzdGVkID0gKGNoID09IFwiKFwiKTtcbiAgfVxuXG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuLy8gdG9rZW5pemVyIGZvciBzdHJpbmcgbGl0ZXJhbHNcbi8vIG9wdGlvbmFsbHkgcGFzcyBhIHRva2VuaXplciBmdW5jdGlvbiB0byBzZXQgc3RhdGUudG9rZW5pemUgYmFjayB0byB3aGVuIGZpbmlzaGVkXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcblxuICAgIGlmKGlzSW5TdHJpbmcoc3RhdGUpICYmIHN0cmVhbS5jdXJyZW50KCkgPT0gcXVvdGUpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgaWYoZikgc3RhdGUudG9rZW5pemUgPSBmO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogcXVvdGUsIHRva2VuaXplOiB0b2tlblN0cmluZyhxdW90ZSwgZikgfSk7XG5cbiAgICAvLyBpZiB3ZSdyZSBpbiBhIHN0cmluZyBhbmQgaW4gYW4gWE1MIGJsb2NrLCBhbGxvdyBhbiBlbWJlZGRlZCBjb2RlIGJsb2NrXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwie1wiLCBmYWxzZSkgJiYgaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG5cblxuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSAgcXVvdGUpIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gYSBzdHJpbmcgYW5kIGluIGFuIFhNTCBibG9jaywgYWxsb3cgYW4gZW1iZWRkZWQgY29kZSBibG9jayBpbiBhbiBhdHRyaWJ1dGVcbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKFwie1wiLCBmYWxzZSkgJiYgaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfTtcbn1cblxuLy8gdG9rZW5pemVyIGZvciB2YXJpYWJsZXNcbmZ1bmN0aW9uIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgaXNWYXJpYWJsZUNoYXIgPSAvW1xcd1xcJF8tXS87XG5cbiAgLy8gYSB2YXJpYWJsZSBtYXkgc3RhcnQgd2l0aCBhIHF1b3RlZCBFUU5hbWUgc28gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHF1b3RlLCBjb25zdW1lIHRvIHRoZSBuZXh0IHF1b3RlXG4gIGlmKHN0cmVhbS5lYXQoXCJcXFwiXCIpKSB7XG4gICAgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcXCInKXt9O1xuICAgIHN0cmVhbS5lYXQoXCI6XCIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gICAgaWYoIXN0cmVhbS5tYXRjaChcIjo9XCIsIGZhbHNlKSkgc3RyZWFtLmVhdChcIjpcIik7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIHRhZ3NcbmZ1bmN0aW9uIHRva2VuVGFnKG5hbWUsIGlzY2xvc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBpZihpc2Nsb3NlICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIC8vIHNlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhdHRyaWJ1dGVzP1xuICAgIGlmKCFzdHJlYW0uZWF0KFwiL1wiKSlcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwidGFnXCIsIG5hbWU6IG5hbWUsIHRva2VuaXplOiB0b2tlbkJhc2V9KTtcbiAgICBpZighc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdHRyaWJ1dGU7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH07XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIHRva2VuQXR0cmlidXRlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBcInRhZ1wiO1xuICB9XG4gIGlmKGNoID09IFwiPlwiKSB7XG4gICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH1cbiAgaWYoY2ggPT0gXCI9XCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoLCB0b2tlbkF0dHJpYnV0ZSkpO1xuXG4gIGlmKCFpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKVxuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiYXR0cmlidXRlXCIsIHRva2VuaXplOiB0b2tlbkF0dHJpYnV0ZX0pO1xuXG4gIHN0cmVhbS5lYXQoL1thLXpBLVpfOl0vKTtcbiAgc3RyZWFtLmVhdFdoaWxlKC9bLWEtekEtWjAtOV86Ll0vKTtcbiAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgLy8gdGhlIGNhc2Ugd2hlcmUgdGhlIGF0dHJpYnV0ZSBoYXMgbm90IHZhbHVlIGFuZCB0aGUgdGFnIHdhcyBjbG9zZWRcbiAgaWYoc3RyZWFtLm1hdGNoKFwiPlwiLCBmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKFwiL1wiLCBmYWxzZSkpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuXG4gIHJldHVybiBcImF0dHJpYnV0ZVwiO1xufVxuXG4vLyBoYW5kbGUgY29tbWVudHMsIGluY2x1ZGluZyBuZXN0ZWRcbmZ1bmN0aW9uIHRva2VuWE1MQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0ubWF0Y2goXCItPlwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICB9XG59XG5cblxuLy8gaGFuZGxlIENEQVRBXG5mdW5jdGlvbiB0b2tlbkNEQVRBKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiXVwiICYmIHN0cmVhbS5tYXRjaChcIl1cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxufVxuXG4vLyBoYW5kbGUgcHJlcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbmZ1bmN0aW9uIHRva2VuUHJlUHJvY2Vzc2luZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIj9cIiAmJiBzdHJlYW0ubWF0Y2goXCI+XCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIGZ1bmN0aW9ucyB0byB0ZXN0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHN0YXRlXG5mdW5jdGlvbiBpc0luWG1sQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwidGFnXCIpOyB9XG5mdW5jdGlvbiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwiYXR0cmlidXRlXCIpOyB9XG5mdW5jdGlvbiBpc0luWG1sQ29uc3RydWN0b3Ioc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwieG1sY29uc3RydWN0b3JcIik7IH1cbmZ1bmN0aW9uIGlzSW5TdHJpbmcoc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwic3RyaW5nXCIpOyB9XG5cbmZ1bmN0aW9uIGlzRVFOYW1lQWhlYWQoc3RyZWFtKSB7XG4gIC8vIGFzc3VtZSB3ZSd2ZSBhbHJlYWR5IGVhdGVuIGEgcXVvdGUgKFwiKVxuICBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXCInKVxuICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcXCJcXDovLCBmYWxzZSk7XG4gIGVsc2UgaWYoc3RyZWFtLmN1cnJlbnQoKSA9PT0gJ1xcJycpXG4gICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFwnXFw6LywgZmFsc2UpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0luKHN0YXRlLCB0eXBlKSB7XG4gIHJldHVybiAoc3RhdGUuc3RhY2subGVuZ3RoICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aCAtIDFdLnR5cGUgPT0gdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCBuZXdTdGF0ZSkge1xuICBzdGF0ZS5zdGFjay5wdXNoKG5ld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gcG9wU3RhdGVTdGFjayhzdGF0ZSkge1xuICBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgdmFyIHJlaW5zdGF0ZVRva2VuaXplID0gc3RhdGUuc3RhY2subGVuZ3RoICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXS50b2tlbml6ZTtcbiAgc3RhdGUudG9rZW5pemUgPSByZWluc3RhdGVUb2tlbml6ZSB8fCB0b2tlbkJhc2U7XG59XG5cbi8vIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBtb2RlIEFQSVxuZXhwb3J0IGNvbnN0IHhRdWVyeSA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBjYzogW10sXG4gICAgICBzdGFjazogW11cbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2Jsb2NrOiB7b3BlbjogXCIoOlwiLCBjbG9zZTogXCI6KVwifX1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==