"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_webidl_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/webidl.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/webidl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "webIDL": () => (/* binding */ webIDL)
/* harmony export */ });
function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
};

var builtinArray = [
  "Clamp",
  "Constructor",
  "EnforceRange",
  "Exposed",
  "ImplicitThis",
  "Global", "PrimaryGlobal",
  "LegacyArrayClass",
  "LegacyUnenumerableNamedProperties",
  "LenientThis",
  "NamedConstructor",
  "NewObject",
  "NoInterfaceObject",
  "OverrideBuiltins",
  "PutForwards",
  "Replaceable",
  "SameObject",
  "TreatNonObjectAsNull",
  "TreatNullAs",
    "EmptyString",
  "Unforgeable",
  "Unscopeable"
];
var builtins = wordRegexp(builtinArray);

var typeArray = [
  "unsigned", "short", "long",                  // UnsignedIntegerType
  "unrestricted", "float", "double",            // UnrestrictedFloatType
  "boolean", "byte", "octet",                   // Rest of PrimitiveType
  "Promise",                                    // PromiseType
  "ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array",
  "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray",
  "Float32Array", "Float64Array",               // BufferRelatedType
  "ByteString", "DOMString", "USVString", "sequence", "object", "RegExp",
  "Error", "DOMException", "FrozenArray",       // Rest of NonAnyType
  "any",                                        // Rest of SingleType
  "void"                                        // Rest of ReturnType
];
var types = wordRegexp(typeArray);

var keywordArray = [
  "attribute", "callback", "const", "deleter", "dictionary", "enum", "getter",
  "implements", "inherit", "interface", "iterable", "legacycaller", "maplike",
  "partial", "required", "serializer", "setlike", "setter", "static",
  "stringifier", "typedef",                     // ArgumentNameKeyword except
                                                // "unrestricted"
  "optional", "readonly", "or"
];
var keywords = wordRegexp(keywordArray);

var atomArray = [
  "true", "false",                              // BooleanLiteral
  "Infinity", "NaN",                            // FloatLiteral
  "null"                                        // Rest of ConstValue
];
var atoms = wordRegexp(atomArray);

var startDefArray = ["callback", "dictionary", "enum", "interface"];
var startDefs = wordRegexp(startDefArray);

var endDefArray = ["typedef"];
var endDefs = wordRegexp(endDefArray);

var singleOperators = /^[:<=>?]/;
var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;
var floats = /^-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;
var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;
var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\s*;)/;
var strings = /^"[^"]*"/;
var multilineComments = /^\/\*.*?\*\//;
var multilineCommentsStart = /^\/\*.*/;
var multilineCommentsEnd = /^.*?\*\//;

function readToken(stream, state) {
  // whitespace
  if (stream.eatSpace()) return null;

  // comment
  if (state.inComment) {
    if (stream.match(multilineCommentsEnd)) {
      state.inComment = false;
      return "comment";
    }
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match("//")) {
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match(multilineComments)) return "comment";
  if (stream.match(multilineCommentsStart)) {
    state.inComment = true;
    return "comment";
  }

  // integer and float
  if (stream.match(/^-?[0-9\.]/, false)) {
    if (stream.match(integers) || stream.match(floats)) return "number";
  }

  // string
  if (stream.match(strings)) return "string";

  // identifier
  if (state.startDef && stream.match(identifiers)) return "def";

  if (state.endDef && stream.match(identifiersEnd)) {
    state.endDef = false;
    return "def";
  }

  if (stream.match(keywords)) return "keyword";

  if (stream.match(types)) {
    var lastToken = state.lastToken;
    var nextToken = (stream.match(/^\s*(.+?)\b/, false) || [])[1];

    if (lastToken === ":" || lastToken === "implements" ||
        nextToken === "implements" || nextToken === "=") {
      // Used as identifier
      return "builtin";
    } else {
      // Used as type
      return "type";
    }
  }

  if (stream.match(builtins)) return "builtin";
  if (stream.match(atoms)) return "atom";
  if (stream.match(identifiers)) return "variable";

  // other
  if (stream.match(singleOperators)) return "operator";

  // unrecognized
  stream.next();
  return null;
};

const webIDL = {
  startState: function() {
    return {
      // Is in multiline comment
      inComment: false,
      // Last non-whitespace, matched token
      lastToken: "",
      // Next token is a definition
      startDef: false,
      // Last token of the statement is a definition
      endDef: false
    };
  },
  token: function(stream, state) {
    var style = readToken(stream, state);

    if (style) {
      var cur = stream.current();
      state.lastToken = cur;
      if (style === "keyword") {
        state.startDef = startDefs.test(cur);
        state.endDef = state.endDef || endDefs.test(cur);
      } else {
        state.startDef = false;
      }
    }

    return style;
  },

  languageData: {
    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfd2ViaWRsX2pzLjM3OWE3MWVjZjBhYjM4MjkzODhlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS93ZWJpZGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbn07XG5cbnZhciBidWlsdGluQXJyYXkgPSBbXG4gIFwiQ2xhbXBcIixcbiAgXCJDb25zdHJ1Y3RvclwiLFxuICBcIkVuZm9yY2VSYW5nZVwiLFxuICBcIkV4cG9zZWRcIixcbiAgXCJJbXBsaWNpdFRoaXNcIixcbiAgXCJHbG9iYWxcIiwgXCJQcmltYXJ5R2xvYmFsXCIsXG4gIFwiTGVnYWN5QXJyYXlDbGFzc1wiLFxuICBcIkxlZ2FjeVVuZW51bWVyYWJsZU5hbWVkUHJvcGVydGllc1wiLFxuICBcIkxlbmllbnRUaGlzXCIsXG4gIFwiTmFtZWRDb25zdHJ1Y3RvclwiLFxuICBcIk5ld09iamVjdFwiLFxuICBcIk5vSW50ZXJmYWNlT2JqZWN0XCIsXG4gIFwiT3ZlcnJpZGVCdWlsdGluc1wiLFxuICBcIlB1dEZvcndhcmRzXCIsXG4gIFwiUmVwbGFjZWFibGVcIixcbiAgXCJTYW1lT2JqZWN0XCIsXG4gIFwiVHJlYXROb25PYmplY3RBc051bGxcIixcbiAgXCJUcmVhdE51bGxBc1wiLFxuICAgIFwiRW1wdHlTdHJpbmdcIixcbiAgXCJVbmZvcmdlYWJsZVwiLFxuICBcIlVuc2NvcGVhYmxlXCJcbl07XG52YXIgYnVpbHRpbnMgPSB3b3JkUmVnZXhwKGJ1aWx0aW5BcnJheSk7XG5cbnZhciB0eXBlQXJyYXkgPSBbXG4gIFwidW5zaWduZWRcIiwgXCJzaG9ydFwiLCBcImxvbmdcIiwgICAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZEludGVnZXJUeXBlXG4gIFwidW5yZXN0cmljdGVkXCIsIFwiZmxvYXRcIiwgXCJkb3VibGVcIiwgICAgICAgICAgICAvLyBVbnJlc3RyaWN0ZWRGbG9hdFR5cGVcbiAgXCJib29sZWFuXCIsIFwiYnl0ZVwiLCBcIm9jdGV0XCIsICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgUHJpbWl0aXZlVHlwZVxuICBcIlByb21pc2VcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9taXNlVHlwZVxuICBcIkFycmF5QnVmZmVyXCIsIFwiRGF0YVZpZXdcIiwgXCJJbnQ4QXJyYXlcIiwgXCJJbnQxNkFycmF5XCIsIFwiSW50MzJBcnJheVwiLFxuICBcIlVpbnQ4QXJyYXlcIiwgXCJVaW50MTZBcnJheVwiLCBcIlVpbnQzMkFycmF5XCIsIFwiVWludDhDbGFtcGVkQXJyYXlcIixcbiAgXCJGbG9hdDMyQXJyYXlcIiwgXCJGbG9hdDY0QXJyYXlcIiwgICAgICAgICAgICAgICAvLyBCdWZmZXJSZWxhdGVkVHlwZVxuICBcIkJ5dGVTdHJpbmdcIiwgXCJET01TdHJpbmdcIiwgXCJVU1ZTdHJpbmdcIiwgXCJzZXF1ZW5jZVwiLCBcIm9iamVjdFwiLCBcIlJlZ0V4cFwiLFxuICBcIkVycm9yXCIsIFwiRE9NRXhjZXB0aW9uXCIsIFwiRnJvemVuQXJyYXlcIiwgICAgICAgLy8gUmVzdCBvZiBOb25BbnlUeXBlXG4gIFwiYW55XCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgU2luZ2xlVHlwZVxuICBcInZvaWRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0IG9mIFJldHVyblR5cGVcbl07XG52YXIgdHlwZXMgPSB3b3JkUmVnZXhwKHR5cGVBcnJheSk7XG5cbnZhciBrZXl3b3JkQXJyYXkgPSBbXG4gIFwiYXR0cmlidXRlXCIsIFwiY2FsbGJhY2tcIiwgXCJjb25zdFwiLCBcImRlbGV0ZXJcIiwgXCJkaWN0aW9uYXJ5XCIsIFwiZW51bVwiLCBcImdldHRlclwiLFxuICBcImltcGxlbWVudHNcIiwgXCJpbmhlcml0XCIsIFwiaW50ZXJmYWNlXCIsIFwiaXRlcmFibGVcIiwgXCJsZWdhY3ljYWxsZXJcIiwgXCJtYXBsaWtlXCIsXG4gIFwicGFydGlhbFwiLCBcInJlcXVpcmVkXCIsIFwic2VyaWFsaXplclwiLCBcInNldGxpa2VcIiwgXCJzZXR0ZXJcIiwgXCJzdGF0aWNcIixcbiAgXCJzdHJpbmdpZmllclwiLCBcInR5cGVkZWZcIiwgICAgICAgICAgICAgICAgICAgICAvLyBBcmd1bWVudE5hbWVLZXl3b3JkIGV4Y2VwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJ1bnJlc3RyaWN0ZWRcIlxuICBcIm9wdGlvbmFsXCIsIFwicmVhZG9ubHlcIiwgXCJvclwiXG5dO1xudmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChrZXl3b3JkQXJyYXkpO1xuXG52YXIgYXRvbUFycmF5ID0gW1xuICBcInRydWVcIiwgXCJmYWxzZVwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW5MaXRlcmFsXG4gIFwiSW5maW5pdHlcIiwgXCJOYU5cIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvYXRMaXRlcmFsXG4gIFwibnVsbFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgQ29uc3RWYWx1ZVxuXTtcbnZhciBhdG9tcyA9IHdvcmRSZWdleHAoYXRvbUFycmF5KTtcblxudmFyIHN0YXJ0RGVmQXJyYXkgPSBbXCJjYWxsYmFja1wiLCBcImRpY3Rpb25hcnlcIiwgXCJlbnVtXCIsIFwiaW50ZXJmYWNlXCJdO1xudmFyIHN0YXJ0RGVmcyA9IHdvcmRSZWdleHAoc3RhcnREZWZBcnJheSk7XG5cbnZhciBlbmREZWZBcnJheSA9IFtcInR5cGVkZWZcIl07XG52YXIgZW5kRGVmcyA9IHdvcmRSZWdleHAoZW5kRGVmQXJyYXkpO1xuXG52YXIgc2luZ2xlT3BlcmF0b3JzID0gL15bOjw9Pj9dLztcbnZhciBpbnRlZ2VycyA9IC9eLT8oWzEtOV1bMC05XSp8MFtYeF1bMC05QS1GYS1mXSt8MFswLTddKikvO1xudmFyIGZsb2F0cyA9IC9eLT8oKFswLTldK1xcLlswLTldKnxbMC05XSpcXC5bMC05XSspKFtFZV1bKy1dP1swLTldKyk/fFswLTldK1tFZV1bKy1dP1swLTldKykvO1xudmFyIGlkZW50aWZpZXJzID0gL15fP1tBLVphLXpdWzAtOUEtWl9hLXotXSovO1xudmFyIGlkZW50aWZpZXJzRW5kID0gL15fP1tBLVphLXpdWzAtOUEtWl9hLXotXSooPz1cXHMqOykvO1xudmFyIHN0cmluZ3MgPSAvXlwiW15cIl0qXCIvO1xudmFyIG11bHRpbGluZUNvbW1lbnRzID0gL15cXC9cXCouKj9cXCpcXC8vO1xudmFyIG11bHRpbGluZUNvbW1lbnRzU3RhcnQgPSAvXlxcL1xcKi4qLztcbnZhciBtdWx0aWxpbmVDb21tZW50c0VuZCA9IC9eLio/XFwqXFwvLztcblxuZnVuY3Rpb24gcmVhZFRva2VuKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gd2hpdGVzcGFjZVxuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gIC8vIGNvbW1lbnRcbiAgaWYgKHN0YXRlLmluQ29tbWVudCkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2gobXVsdGlsaW5lQ29tbWVudHNFbmQpKSB7XG4gICAgICBzdGF0ZS5pbkNvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKFwiLy9cIikpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2gobXVsdGlsaW5lQ29tbWVudHMpKSByZXR1cm4gXCJjb21tZW50XCI7XG4gIGlmIChzdHJlYW0ubWF0Y2gobXVsdGlsaW5lQ29tbWVudHNTdGFydCkpIHtcbiAgICBzdGF0ZS5pbkNvbW1lbnQgPSB0cnVlO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIGludGVnZXIgYW5kIGZsb2F0XG4gIGlmIChzdHJlYW0ubWF0Y2goL14tP1swLTlcXC5dLywgZmFsc2UpKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChpbnRlZ2VycykgfHwgc3RyZWFtLm1hdGNoKGZsb2F0cykpIHJldHVybiBcIm51bWJlclwiO1xuICB9XG5cbiAgLy8gc3RyaW5nXG4gIGlmIChzdHJlYW0ubWF0Y2goc3RyaW5ncykpIHJldHVybiBcInN0cmluZ1wiO1xuXG4gIC8vIGlkZW50aWZpZXJcbiAgaWYgKHN0YXRlLnN0YXJ0RGVmICYmIHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHJldHVybiBcImRlZlwiO1xuXG4gIGlmIChzdGF0ZS5lbmREZWYgJiYgc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzRW5kKSkge1xuICAgIHN0YXRlLmVuZERlZiA9IGZhbHNlO1xuICAgIHJldHVybiBcImRlZlwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHJldHVybiBcImtleXdvcmRcIjtcblxuICBpZiAoc3RyZWFtLm1hdGNoKHR5cGVzKSkge1xuICAgIHZhciBsYXN0VG9rZW4gPSBzdGF0ZS5sYXN0VG9rZW47XG4gICAgdmFyIG5leHRUb2tlbiA9IChzdHJlYW0ubWF0Y2goL15cXHMqKC4rPylcXGIvLCBmYWxzZSkgfHwgW10pWzFdO1xuXG4gICAgaWYgKGxhc3RUb2tlbiA9PT0gXCI6XCIgfHwgbGFzdFRva2VuID09PSBcImltcGxlbWVudHNcIiB8fFxuICAgICAgICBuZXh0VG9rZW4gPT09IFwiaW1wbGVtZW50c1wiIHx8IG5leHRUb2tlbiA9PT0gXCI9XCIpIHtcbiAgICAgIC8vIFVzZWQgYXMgaWRlbnRpZmllclxuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2VkIGFzIHR5cGVcbiAgICAgIHJldHVybiBcInR5cGVcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGJ1aWx0aW5zKSkgcmV0dXJuIFwiYnVpbHRpblwiO1xuICBpZiAoc3RyZWFtLm1hdGNoKGF0b21zKSkgcmV0dXJuIFwiYXRvbVwiO1xuICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkgcmV0dXJuIFwidmFyaWFibGVcIjtcblxuICAvLyBvdGhlclxuICBpZiAoc3RyZWFtLm1hdGNoKHNpbmdsZU9wZXJhdG9ycykpIHJldHVybiBcIm9wZXJhdG9yXCI7XG5cbiAgLy8gdW5yZWNvZ25pemVkXG4gIHN0cmVhbS5uZXh0KCk7XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IHdlYklETCA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIElzIGluIG11bHRpbGluZSBjb21tZW50XG4gICAgICBpbkNvbW1lbnQ6IGZhbHNlLFxuICAgICAgLy8gTGFzdCBub24td2hpdGVzcGFjZSwgbWF0Y2hlZCB0b2tlblxuICAgICAgbGFzdFRva2VuOiBcIlwiLFxuICAgICAgLy8gTmV4dCB0b2tlbiBpcyBhIGRlZmluaXRpb25cbiAgICAgIHN0YXJ0RGVmOiBmYWxzZSxcbiAgICAgIC8vIExhc3QgdG9rZW4gb2YgdGhlIHN0YXRlbWVudCBpcyBhIGRlZmluaXRpb25cbiAgICAgIGVuZERlZjogZmFsc2VcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHJlYWRUb2tlbihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXI7XG4gICAgICBpZiAoc3R5bGUgPT09IFwia2V5d29yZFwiKSB7XG4gICAgICAgIHN0YXRlLnN0YXJ0RGVmID0gc3RhcnREZWZzLnRlc3QoY3VyKTtcbiAgICAgICAgc3RhdGUuZW5kRGVmID0gc3RhdGUuZW5kRGVmIHx8IGVuZERlZnMudGVzdChjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc3RhcnREZWYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgYXV0b2NvbXBsZXRlOiBidWlsdGluQXJyYXkuY29uY2F0KHR5cGVBcnJheSkuY29uY2F0KGtleXdvcmRBcnJheSkuY29uY2F0KGF0b21BcnJheSlcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==