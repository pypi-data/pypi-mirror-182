"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_commonlisp_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/commonlisp.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/commonlisp.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "commonLisp": () => (/* binding */ commonLisp)
/* harmony export */ });
var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;
var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;
var numLiteral = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/;
var symbol = /[^\s'`,@()\[\]";]/;
var type;

function readSym(stream) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "\\") stream.next();
    else if (!symbol.test(ch)) { stream.backUp(1); break; }
  }
  return stream.current();
}

function base(stream, state) {
  if (stream.eatSpace()) {type = "ws"; return null;}
  if (stream.match(numLiteral)) return "number";
  var ch = stream.next();
  if (ch == "\\") ch = stream.next();

  if (ch == '"') return (state.tokenize = inString)(stream, state);
  else if (ch == "(") { type = "open"; return "bracket"; }
  else if (ch == ")" || ch == "]") { type = "close"; return "bracket"; }
  else if (ch == ";") { stream.skipToEnd(); type = "ws"; return "comment"; }
  else if (/['`,@]/.test(ch)) return null;
  else if (ch == "|") {
    if (stream.skipTo("|")) { stream.next(); return "variableName"; }
    else { stream.skipToEnd(); return "error"; }
  } else if (ch == "#") {
    var ch = stream.next();
    if (ch == "(") { type = "open"; return "bracket"; }
    else if (/[+\-=\.']/.test(ch)) return null;
    else if (/\d/.test(ch) && stream.match(/^\d*#/)) return null;
    else if (ch == "|") return (state.tokenize = inComment)(stream, state);
    else if (ch == ":") { readSym(stream); return "meta"; }
    else if (ch == "\\") { stream.next(); readSym(stream); return "string.special" }
    else return "error";
  } else {
    var name = readSym(stream);
    if (name == ".") return null;
    type = "symbol";
    if (name == "nil" || name == "t" || name.charAt(0) == ":") return "atom";
    if (state.lastType == "open" && (specialForm.test(name) || assumeBody.test(name))) return "keyword";
    if (name.charAt(0) == "&") return "variableName.special";
    return "variableName";
  }
}

function inString(stream, state) {
  var escaped = false, next;
  while (next = stream.next()) {
    if (next == '"' && !escaped) { state.tokenize = base; break; }
    escaped = !escaped && next == "\\";
  }
  return "string";
}

function inComment(stream, state) {
  var next, last;
  while (next = stream.next()) {
    if (next == "#" && last == "|") { state.tokenize = base; break; }
    last = next;
  }
  type = "ws";
  return "comment";
}

const commonLisp = {
  startState: function () {
    return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};
  },

  token: function (stream, state) {
    if (stream.sol() && typeof state.ctx.indentTo != "number")
      state.ctx.indentTo = state.ctx.start + 1;

    type = null;
    var style = state.tokenize(stream, state);
    if (type != "ws") {
      if (state.ctx.indentTo == null) {
        if (type == "symbol" && assumeBody.test(stream.current()))
          state.ctx.indentTo = state.ctx.start + stream.indentUnit;
        else
          state.ctx.indentTo = "next";
      } else if (state.ctx.indentTo == "next") {
        state.ctx.indentTo = stream.column();
      }
      state.lastType = type;
    }
    if (type == "open") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
    else if (type == "close") state.ctx = state.ctx.prev || state.ctx;
    return style;
  },

  indent: function (state) {
    var i = state.ctx.indentTo;
    return typeof i == "number" ? i : state.ctx.start + 1;
  },

  languageData: {
    commentTokens: {line: ";;", block: {open: "#|", close: "|#"}},
    closeBrackets: {brackets: ["(", "[", "{", '"']}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfY29tbW9ubGlzcF9qcy4wZDFmODc4YTk2NjUwZjk1YzczOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QyxxQ0FBcUMsZ0JBQWdCO0FBQ3JELG1CQUFtQixLQUFLLG9CQUFvQixhQUFhO0FBQ3pEO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxXQUFXLG9CQUFvQjtBQUMvQixJQUFJO0FBQ0o7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDJCQUEyQixlQUFlLGlCQUFpQjtBQUMzRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFlBQVksTUFBTSxrQ0FBa0M7QUFDcEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFNBQVMsV0FBVyx5QkFBeUI7QUFDakUsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9jb21tb25saXNwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzcGVjaWFsRm9ybSA9IC9eKGJsb2NrfGxldCp8cmV0dXJuLWZyb218Y2F0Y2h8bG9hZC10aW1lLXZhbHVlfHNldHF8ZXZhbC13aGVufGxvY2FsbHl8c3ltYm9sLW1hY3JvbGV0fGZsZXR8bWFjcm9sZXR8dGFnYm9keXxmdW5jdGlvbnxtdWx0aXBsZS12YWx1ZS1jYWxsfHRoZXxnb3xtdWx0aXBsZS12YWx1ZS1wcm9nMXx0aHJvd3xpZnxwcm9nbnx1bndpbmQtcHJvdGVjdHxsYWJlbHN8cHJvZ3Z8bGV0fHF1b3RlKSQvO1xudmFyIGFzc3VtZUJvZHkgPSAvXndpdGh8XmRlZnxeZG98XnByb2d8Y2FzZSR8XmNvbmQkfGJpbmQkfHdoZW4kfHVubGVzcyQvO1xudmFyIG51bUxpdGVyYWwgPSAvXig/OlsrXFwtXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSg/OltlZmRdWytcXC1dP1xcZCspP3xbK1xcLV0/XFxkKyg/OlxcL1srXFwtXT9cXGQrKT98I2JbK1xcLV0/WzAxXSt8I29bK1xcLV0/WzAtN10rfCN4WytcXC1dP1tcXGRhLWZdKykvO1xudmFyIHN5bWJvbCA9IC9bXlxccydgLEAoKVxcW1xcXVwiO10vO1xudmFyIHR5cGU7XG5cbmZ1bmN0aW9uIHJlYWRTeW0oc3RyZWFtKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIlxcXFxcIikgc3RyZWFtLm5leHQoKTtcbiAgICBlbHNlIGlmICghc3ltYm9sLnRlc3QoY2gpKSB7IHN0cmVhbS5iYWNrVXAoMSk7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHN0cmVhbS5jdXJyZW50KCk7XG59XG5cbmZ1bmN0aW9uIGJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHt0eXBlID0gXCJ3c1wiOyByZXR1cm4gbnVsbDt9XG4gIGlmIChzdHJlYW0ubWF0Y2gobnVtTGl0ZXJhbCkpIHJldHVybiBcIm51bWJlclwiO1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gXCJcXFxcXCIpIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICBpZiAoY2ggPT0gJ1wiJykgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKShzdHJlYW0sIHN0YXRlKTtcbiAgZWxzZSBpZiAoY2ggPT0gXCIoXCIpIHsgdHlwZSA9IFwib3BlblwiOyByZXR1cm4gXCJicmFja2V0XCI7IH1cbiAgZWxzZSBpZiAoY2ggPT0gXCIpXCIgfHwgY2ggPT0gXCJdXCIpIHsgdHlwZSA9IFwiY2xvc2VcIjsgcmV0dXJuIFwiYnJhY2tldFwiOyB9XG4gIGVsc2UgaWYgKGNoID09IFwiO1wiKSB7IHN0cmVhbS5za2lwVG9FbmQoKTsgdHlwZSA9IFwid3NcIjsgcmV0dXJuIFwiY29tbWVudFwiOyB9XG4gIGVsc2UgaWYgKC9bJ2AsQF0vLnRlc3QoY2gpKSByZXR1cm4gbnVsbDtcbiAgZWxzZSBpZiAoY2ggPT0gXCJ8XCIpIHtcbiAgICBpZiAoc3RyZWFtLnNraXBUbyhcInxcIikpIHsgc3RyZWFtLm5leHQoKTsgcmV0dXJuIFwidmFyaWFibGVOYW1lXCI7IH1cbiAgICBlbHNlIHsgc3RyZWFtLnNraXBUb0VuZCgpOyByZXR1cm4gXCJlcnJvclwiOyB9XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIihcIikgeyB0eXBlID0gXCJvcGVuXCI7IHJldHVybiBcImJyYWNrZXRcIjsgfVxuICAgIGVsc2UgaWYgKC9bK1xcLT1cXC4nXS8udGVzdChjaCkpIHJldHVybiBudWxsO1xuICAgIGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpICYmIHN0cmVhbS5tYXRjaCgvXlxcZCojLykpIHJldHVybiBudWxsO1xuICAgIGVsc2UgaWYgKGNoID09IFwifFwiKSByZXR1cm4gKHN0YXRlLnRva2VuaXplID0gaW5Db21tZW50KShzdHJlYW0sIHN0YXRlKTtcbiAgICBlbHNlIGlmIChjaCA9PSBcIjpcIikgeyByZWFkU3ltKHN0cmVhbSk7IHJldHVybiBcIm1ldGFcIjsgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiXFxcXFwiKSB7IHN0cmVhbS5uZXh0KCk7IHJlYWRTeW0oc3RyZWFtKTsgcmV0dXJuIFwic3RyaW5nLnNwZWNpYWxcIiB9XG4gICAgZWxzZSByZXR1cm4gXCJlcnJvclwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gcmVhZFN5bShzdHJlYW0pO1xuICAgIGlmIChuYW1lID09IFwiLlwiKSByZXR1cm4gbnVsbDtcbiAgICB0eXBlID0gXCJzeW1ib2xcIjtcbiAgICBpZiAobmFtZSA9PSBcIm5pbFwiIHx8IG5hbWUgPT0gXCJ0XCIgfHwgbmFtZS5jaGFyQXQoMCkgPT0gXCI6XCIpIHJldHVybiBcImF0b21cIjtcbiAgICBpZiAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVuXCIgJiYgKHNwZWNpYWxGb3JtLnRlc3QobmFtZSkgfHwgYXNzdW1lQm9keS50ZXN0KG5hbWUpKSkgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PSBcIiZcIikgcmV0dXJuIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWVcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gIHdoaWxlIChuZXh0ID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChuZXh0ID09ICdcIicgJiYgIWVzY2FwZWQpIHsgc3RhdGUudG9rZW5pemUgPSBiYXNlOyBicmVhazsgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICB9XG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmV4dCwgbGFzdDtcbiAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKG5leHQgPT0gXCIjXCIgJiYgbGFzdCA9PSBcInxcIikgeyBzdGF0ZS50b2tlbml6ZSA9IGJhc2U7IGJyZWFrOyB9XG4gICAgbGFzdCA9IG5leHQ7XG4gIH1cbiAgdHlwZSA9IFwid3NcIjtcbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5leHBvcnQgY29uc3QgY29tbW9uTGlzcCA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7Y3R4OiB7cHJldjogbnVsbCwgc3RhcnQ6IDAsIGluZGVudFRvOiAwfSwgbGFzdFR5cGU6IG51bGwsIHRva2VuaXplOiBiYXNlfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHR5cGVvZiBzdGF0ZS5jdHguaW5kZW50VG8gIT0gXCJudW1iZXJcIilcbiAgICAgIHN0YXRlLmN0eC5pbmRlbnRUbyA9IHN0YXRlLmN0eC5zdGFydCArIDE7XG5cbiAgICB0eXBlID0gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSAhPSBcIndzXCIpIHtcbiAgICAgIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PSBcInN5bWJvbFwiICYmIGFzc3VtZUJvZHkudGVzdChzdHJlYW0uY3VycmVudCgpKSlcbiAgICAgICAgICBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdGF0ZS5jdHguc3RhcnQgKyBzdHJlYW0uaW5kZW50VW5pdDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmN0eC5pbmRlbnRUbyA9IFwibmV4dFwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT0gXCJuZXh0XCIpIHtcbiAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdFR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcIm9wZW5cIikgc3RhdGUuY3R4ID0ge3ByZXY6IHN0YXRlLmN0eCwgc3RhcnQ6IHN0cmVhbS5jb2x1bW4oKSwgaW5kZW50VG86IG51bGx9O1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVwiKSBzdGF0ZS5jdHggPSBzdGF0ZS5jdHgucHJldiB8fCBzdGF0ZS5jdHg7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGkgPSBzdGF0ZS5jdHguaW5kZW50VG87XG4gICAgcmV0dXJuIHR5cGVvZiBpID09IFwibnVtYmVyXCIgPyBpIDogc3RhdGUuY3R4LnN0YXJ0ICsgMTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCI7O1wiLCBibG9jazoge29wZW46IFwiI3xcIiwgY2xvc2U6IFwifCNcIn19LFxuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsICdcIiddfVxuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=