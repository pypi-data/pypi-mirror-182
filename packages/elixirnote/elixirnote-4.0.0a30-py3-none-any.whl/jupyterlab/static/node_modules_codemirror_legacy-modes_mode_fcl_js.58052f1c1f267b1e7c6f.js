"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_fcl_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/fcl.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/fcl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fcl": () => (/* binding */ fcl)
/* harmony export */ });
var keywords = {
  "term": true,
  "method": true, "accu": true,
  "rule": true, "then": true, "is": true, "and": true, "or": true,
  "if": true, "default": true
};

var start_blocks = {
  "var_input": true,
  "var_output": true,
  "fuzzify": true,
  "defuzzify": true,
  "function_block": true,
  "ruleblock": true
};

var end_blocks = {
  "end_ruleblock": true,
  "end_defuzzify": true,
  "end_function_block": true,
  "end_fuzzify": true,
  "end_var": true
};

var atoms = {
  "true": true, "false": true, "nan": true,
  "real": true, "min": true, "max": true, "cog": true, "cogs": true
};

var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

function tokenBase(stream, state) {
  var ch = stream.next();

  if (/[\d\.]/.test(ch)) {
    if (ch == ".") {
      stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
    } else if (ch == "0") {
      stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
    } else {
      stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
    }
    return "number";
  }

  if (ch == "/" || ch == "(") {
    if (stream.eat("*")) {
      state.tokenize = tokenComment;
      return tokenComment(stream, state);
    }
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
  }
  if (isOperatorChar.test(ch)) {
    stream.eatWhile(isOperatorChar);
    return "operator";
  }
  stream.eatWhile(/[\w\$_\xa1-\uffff]/);

  var cur = stream.current().toLowerCase();
  if (keywords.propertyIsEnumerable(cur) ||
      start_blocks.propertyIsEnumerable(cur) ||
      end_blocks.propertyIsEnumerable(cur)) {
    return "keyword";
  }
  if (atoms.propertyIsEnumerable(cur)) return "atom";
  return "variable";
}


function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if ((ch == "/" || ch == ")") && maybeEnd) {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function Context(indented, column, type, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.align = align;
  this.prev = prev;
}

function pushContext(state, col, type) {
  return state.context = new Context(state.indented, col, type, null, state.context);
}

function popContext(state) {
  if (!state.context.prev) return;
  var t = state.context.type;
  if (t == "end_block")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

// Interface

const fcl = {
  startState: function(indentUnit) {
    return {
      tokenize: null,
      context: new Context(-indentUnit, 0, "top", false),
      indented: 0,
      startOfLine: true
    };
  },

  token: function(stream, state) {
    var ctx = state.context;
    if (stream.sol()) {
      if (ctx.align == null) ctx.align = false;
      state.indented = stream.indentation();
      state.startOfLine = true;
    }
    if (stream.eatSpace()) return null;

    var style = (state.tokenize || tokenBase)(stream, state);
    if (style == "comment") return style;
    if (ctx.align == null) ctx.align = true;

    var cur = stream.current().toLowerCase();

    if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), "end_block");
    else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);

    state.startOfLine = false;
    return style;
  },

  indent: function(state, textAfter, cx) {
    if (state.tokenize != tokenBase && state.tokenize != null) return 0;
    var ctx = state.context;

    var closing = end_blocks.propertyIsEnumerable(textAfter);
    if (ctx.align) return ctx.column + (closing ? 0 : 1);
    else return ctx.indented + (closing ? 0 : cx.unit);
  },

  languageData: {
    commentTokens: {line: "//", block: {open: "(*", close: "*)"}}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZmNsX2pzLjU4MDUyZjFjMWYyNjdiMWU3YzZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9mY2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGtleXdvcmRzID0ge1xuICBcInRlcm1cIjogdHJ1ZSxcbiAgXCJtZXRob2RcIjogdHJ1ZSwgXCJhY2N1XCI6IHRydWUsXG4gIFwicnVsZVwiOiB0cnVlLCBcInRoZW5cIjogdHJ1ZSwgXCJpc1wiOiB0cnVlLCBcImFuZFwiOiB0cnVlLCBcIm9yXCI6IHRydWUsXG4gIFwiaWZcIjogdHJ1ZSwgXCJkZWZhdWx0XCI6IHRydWVcbn07XG5cbnZhciBzdGFydF9ibG9ja3MgPSB7XG4gIFwidmFyX2lucHV0XCI6IHRydWUsXG4gIFwidmFyX291dHB1dFwiOiB0cnVlLFxuICBcImZ1enppZnlcIjogdHJ1ZSxcbiAgXCJkZWZ1enppZnlcIjogdHJ1ZSxcbiAgXCJmdW5jdGlvbl9ibG9ja1wiOiB0cnVlLFxuICBcInJ1bGVibG9ja1wiOiB0cnVlXG59O1xuXG52YXIgZW5kX2Jsb2NrcyA9IHtcbiAgXCJlbmRfcnVsZWJsb2NrXCI6IHRydWUsXG4gIFwiZW5kX2RlZnV6emlmeVwiOiB0cnVlLFxuICBcImVuZF9mdW5jdGlvbl9ibG9ja1wiOiB0cnVlLFxuICBcImVuZF9mdXp6aWZ5XCI6IHRydWUsXG4gIFwiZW5kX3ZhclwiOiB0cnVlXG59O1xuXG52YXIgYXRvbXMgPSB7XG4gIFwidHJ1ZVwiOiB0cnVlLCBcImZhbHNlXCI6IHRydWUsIFwibmFuXCI6IHRydWUsXG4gIFwicmVhbFwiOiB0cnVlLCBcIm1pblwiOiB0cnVlLCBcIm1heFwiOiB0cnVlLCBcImNvZ1wiOiB0cnVlLCBcImNvZ3NcIjogdHJ1ZVxufTtcblxudmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiZeJTo9PD4hfFxcL10vO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmICgvW1xcZFxcLl0vLnRlc3QoY2gpKSB7XG4gICAgaWYgKGNoID09IFwiLlwiKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15bMC05XSsoW2VFXVtcXC0rXT9bMC05XSspPy8pO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlt4WF1bMC05YS1mQS1GXSsvKSB8fCBzdHJlYW0ubWF0Y2goL14wWzAtN10rLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlswLTldKlxcLj9bMC05XSooW2VFXVtcXC0rXT9bMC05XSspPy8pO1xuICAgIH1cbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIi9cIiB8fCBjaCA9PSBcIihcIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuXG4gIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpIHx8XG4gICAgICBzdGFydF9ibG9ja3MucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSB8fFxuICAgICAgZW5kX2Jsb2Nrcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG4gIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKChjaCA9PSBcIi9cIiB8fCBjaCA9PSBcIilcIikgJiYgbWF5YmVFbmQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlKSB7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuaW5kZW50ZWQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb250ZXh0LnByZXYpIHJldHVybjtcbiAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIGlmICh0ID09IFwiZW5kX2Jsb2NrXCIpXG4gICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbn1cblxuLy8gSW50ZXJmYWNlXG5cbmV4cG9ydCBjb25zdCBmY2wgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGluZGVudFVuaXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgtaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgZmFsc2UpLFxuICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICBzdGFydE9mTGluZTogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoc3RhcnRfYmxvY2tzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiZW5kX2Jsb2NrXCIpO1xuICAgIGVsc2UgaWYgKGVuZF9ibG9ja3MucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgIHBvcENvbnRleHQoc3RhdGUpO1xuXG4gICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG5cbiAgICB2YXIgY2xvc2luZyA9IGVuZF9ibG9ja3MucHJvcGVydHlJc0VudW1lcmFibGUodGV4dEFmdGVyKTtcbiAgICBpZiAoY3R4LmFsaWduKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGN4LnVuaXQpO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIoKlwiLCBjbG9zZTogXCIqKVwifX1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9