"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_elm_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/elm.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/elm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "elm": () => (/* binding */ elm)
/* harmony export */ });
function switchState(source, setState, f)
{
  setState(f);
  return f(source, setState);
}

var lowerRE = /[a-z]/;
var upperRE = /[A-Z]/;
var innerRE = /[a-zA-Z0-9_]/;

var digitRE = /[0-9]/;
var hexRE = /[0-9A-Fa-f]/;
var symbolRE = /[-&*+.\\/<>=?^|:]/;
var specialRE = /[(),[\]{}]/;
var spacesRE = /[ \v\f]/; // newlines are handled in tokenizer

function normal()
{
  return function(source, setState)
  {
    if (source.eatWhile(spacesRE))
    {
      return null;
    }

    var char = source.next();

    if (specialRE.test(char))
    {
      return (char === '{' && source.eat('-'))
        ? switchState(source, setState, chompMultiComment(1))
        : (char === '[' && source.match('glsl|'))
        ? switchState(source, setState, chompGlsl)
        : 'builtin';
    }

    if (char === '\'')
    {
      return switchState(source, setState, chompChar);
    }

    if (char === '"')
    {
      return source.eat('"')
        ? source.eat('"')
        ? switchState(source, setState, chompMultiString)
        : 'string'
      : switchState(source, setState, chompSingleString);
    }

    if (upperRE.test(char))
    {
      source.eatWhile(innerRE);
      return 'type';
    }

    if (lowerRE.test(char))
    {
      var isDef = source.pos === 1;
      source.eatWhile(innerRE);
      return isDef ? "def" : "variable";
    }

    if (digitRE.test(char))
    {
      if (char === '0')
      {
        if (source.eat(/[xX]/))
        {
          source.eatWhile(hexRE); // should require at least 1
          return "number";
        }
      }
      else
      {
        source.eatWhile(digitRE);
      }
      if (source.eat('.'))
      {
        source.eatWhile(digitRE); // should require at least 1
      }
      if (source.eat(/[eE]/))
      {
        source.eat(/[-+]/);
        source.eatWhile(digitRE); // should require at least 1
      }
      return "number";
    }

    if (symbolRE.test(char))
    {
      if (char === '-' && source.eat('-'))
      {
        source.skipToEnd();
        return "comment";
      }
      source.eatWhile(symbolRE);
      return "keyword";
    }

    if (char === '_')
    {
      return "keyword";
    }

    return "error";
  }
}

function chompMultiComment(nest)
{
  if (nest == 0)
  {
    return normal();
  }
  return function(source, setState)
  {
    while (!source.eol())
    {
      var char = source.next();
      if (char == '{' && source.eat('-'))
      {
        ++nest;
      }
      else if (char == '-' && source.eat('}'))
      {
        --nest;
        if (nest === 0)
        {
          setState(normal());
          return 'comment';
        }
      }
    }
    setState(chompMultiComment(nest));
    return 'comment';
  }
}

function chompMultiString(source, setState)
{
  while (!source.eol())
  {
    var char = source.next();
    if (char === '"' && source.eat('"') && source.eat('"'))
    {
      setState(normal());
      return 'string';
    }
  }
  return 'string';
}

function chompSingleString(source, setState)
{
  while (source.skipTo('\\"')) { source.next(); source.next(); }
  if (source.skipTo('"'))
  {
    source.next();
    setState(normal());
    return 'string';
  }
  source.skipToEnd();
  setState(normal());
  return 'error';
}

function chompChar(source, setState)
{
  while (source.skipTo("\\'")) { source.next(); source.next(); }
  if (source.skipTo("'"))
  {
    source.next();
    setState(normal());
    return 'string';
  }
  source.skipToEnd();
  setState(normal());
  return 'error';
}

function chompGlsl(source, setState)
{
  while (!source.eol())
  {
    var char = source.next();
    if (char === '|' && source.eat(']'))
    {
      setState(normal());
      return 'string';
    }
  }
  return 'string';
}

var wellKnownWords = {
  case: 1,
  of: 1,
  as: 1,
  if: 1,
  then: 1,
  else: 1,
  let: 1,
    in: 1,
  type: 1,
  alias: 1,
  module: 1,
  where: 1,
  import: 1,
  exposing: 1,
  port: 1
};

const elm = {
  startState: function ()  { return { f: normal() }; },
  copyState:  function (s) { return { f: s.f }; },

  token: function(stream, state) {
    var type = state.f(stream, function(s) { state.f = s; });
    var word = stream.current();
    return (wellKnownWords.hasOwnProperty(word)) ? 'keyword' : type;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZWxtX2pzLjE3Yzk1NGEwMjBjNmE4NjE1MjYwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCw2QkFBNkIsU0FBUyxnQkFBZ0I7QUFDdEQsNkJBQTZCLFNBQVMsV0FBVzs7QUFFakQ7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZWxtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIGYpXG57XG4gIHNldFN0YXRlKGYpO1xuICByZXR1cm4gZihzb3VyY2UsIHNldFN0YXRlKTtcbn1cblxudmFyIGxvd2VyUkUgPSAvW2Etel0vO1xudmFyIHVwcGVyUkUgPSAvW0EtWl0vO1xudmFyIGlubmVyUkUgPSAvW2EtekEtWjAtOV9dLztcblxudmFyIGRpZ2l0UkUgPSAvWzAtOV0vO1xudmFyIGhleFJFID0gL1swLTlBLUZhLWZdLztcbnZhciBzeW1ib2xSRSA9IC9bLSYqKy5cXFxcLzw+PT9efDpdLztcbnZhciBzcGVjaWFsUkUgPSAvWygpLFtcXF17fV0vO1xudmFyIHNwYWNlc1JFID0gL1sgXFx2XFxmXS87IC8vIG5ld2xpbmVzIGFyZSBoYW5kbGVkIGluIHRva2VuaXplclxuXG5mdW5jdGlvbiBub3JtYWwoKVxue1xuICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSlcbiAge1xuICAgIGlmIChzb3VyY2UuZWF0V2hpbGUoc3BhY2VzUkUpKVxuICAgIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaGFyID0gc291cmNlLm5leHQoKTtcblxuICAgIGlmIChzcGVjaWFsUkUudGVzdChjaGFyKSlcbiAgICB7XG4gICAgICByZXR1cm4gKGNoYXIgPT09ICd7JyAmJiBzb3VyY2UuZWF0KCctJykpXG4gICAgICAgID8gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgY2hvbXBNdWx0aUNvbW1lbnQoMSkpXG4gICAgICAgIDogKGNoYXIgPT09ICdbJyAmJiBzb3VyY2UubWF0Y2goJ2dsc2x8JykpXG4gICAgICAgID8gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgY2hvbXBHbHNsKVxuICAgICAgICA6ICdidWlsdGluJztcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PT0gJ1xcJycpXG4gICAge1xuICAgICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIGNob21wQ2hhcik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICdcIicpXG4gICAge1xuICAgICAgcmV0dXJuIHNvdXJjZS5lYXQoJ1wiJylcbiAgICAgICAgPyBzb3VyY2UuZWF0KCdcIicpXG4gICAgICAgID8gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgY2hvbXBNdWx0aVN0cmluZylcbiAgICAgICAgOiAnc3RyaW5nJ1xuICAgICAgOiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBjaG9tcFNpbmdsZVN0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHVwcGVyUkUudGVzdChjaGFyKSlcbiAgICB7XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoaW5uZXJSRSk7XG4gICAgICByZXR1cm4gJ3R5cGUnO1xuICAgIH1cblxuICAgIGlmIChsb3dlclJFLnRlc3QoY2hhcikpXG4gICAge1xuICAgICAgdmFyIGlzRGVmID0gc291cmNlLnBvcyA9PT0gMTtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShpbm5lclJFKTtcbiAgICAgIHJldHVybiBpc0RlZiA/IFwiZGVmXCIgOiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgaWYgKGRpZ2l0UkUudGVzdChjaGFyKSlcbiAgICB7XG4gICAgICBpZiAoY2hhciA9PT0gJzAnKVxuICAgICAge1xuICAgICAgICBpZiAoc291cmNlLmVhdCgvW3hYXS8pKVxuICAgICAgICB7XG4gICAgICAgICAgc291cmNlLmVhdFdoaWxlKGhleFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KCcuJykpXG4gICAgICB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5lYXQoL1tlRV0vKSlcbiAgICAgIHtcbiAgICAgICAgc291cmNlLmVhdCgvWy0rXS8pO1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUoZGlnaXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xSRS50ZXN0KGNoYXIpKVxuICAgIHtcbiAgICAgIGlmIChjaGFyID09PSAnLScgJiYgc291cmNlLmVhdCgnLScpKVxuICAgICAge1xuICAgICAgICBzb3VyY2Uuc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5lYXRXaGlsZShzeW1ib2xSRSk7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICdfJylcbiAgICB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaG9tcE11bHRpQ29tbWVudChuZXN0KVxue1xuICBpZiAobmVzdCA9PSAwKVxuICB7XG4gICAgcmV0dXJuIG5vcm1hbCgpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIHNldFN0YXRlKVxuICB7XG4gICAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpXG4gICAge1xuICAgICAgdmFyIGNoYXIgPSBzb3VyY2UubmV4dCgpO1xuICAgICAgaWYgKGNoYXIgPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSlcbiAgICAgIHtcbiAgICAgICAgKytuZXN0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2hhciA9PSAnLScgJiYgc291cmNlLmVhdCgnfScpKVxuICAgICAge1xuICAgICAgICAtLW5lc3Q7XG4gICAgICAgIGlmIChuZXN0ID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RhdGUoY2hvbXBNdWx0aUNvbW1lbnQobmVzdCkpO1xuICAgIHJldHVybiAnY29tbWVudCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hvbXBNdWx0aVN0cmluZyhzb3VyY2UsIHNldFN0YXRlKVxue1xuICB3aGlsZSAoIXNvdXJjZS5lb2woKSlcbiAge1xuICAgIHZhciBjaGFyID0gc291cmNlLm5leHQoKTtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiBzb3VyY2UuZWF0KCdcIicpICYmIHNvdXJjZS5lYXQoJ1wiJykpXG4gICAge1xuICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGNob21wU2luZ2xlU3RyaW5nKHNvdXJjZSwgc2V0U3RhdGUpXG57XG4gIHdoaWxlIChzb3VyY2Uuc2tpcFRvKCdcXFxcXCInKSkgeyBzb3VyY2UubmV4dCgpOyBzb3VyY2UubmV4dCgpOyB9XG4gIGlmIChzb3VyY2Uuc2tpcFRvKCdcIicpKVxuICB7XG4gICAgc291cmNlLm5leHQoKTtcbiAgICBzZXRTdGF0ZShub3JtYWwoKSk7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIHNvdXJjZS5za2lwVG9FbmQoKTtcbiAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICByZXR1cm4gJ2Vycm9yJztcbn1cblxuZnVuY3Rpb24gY2hvbXBDaGFyKHNvdXJjZSwgc2V0U3RhdGUpXG57XG4gIHdoaWxlIChzb3VyY2Uuc2tpcFRvKFwiXFxcXCdcIikpIHsgc291cmNlLm5leHQoKTsgc291cmNlLm5leHQoKTsgfVxuICBpZiAoc291cmNlLnNraXBUbyhcIidcIikpXG4gIHtcbiAgICBzb3VyY2UubmV4dCgpO1xuICAgIHNldFN0YXRlKG5vcm1hbCgpKTtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH1cbiAgc291cmNlLnNraXBUb0VuZCgpO1xuICBzZXRTdGF0ZShub3JtYWwoKSk7XG4gIHJldHVybiAnZXJyb3InO1xufVxuXG5mdW5jdGlvbiBjaG9tcEdsc2woc291cmNlLCBzZXRTdGF0ZSlcbntcbiAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpXG4gIHtcbiAgICB2YXIgY2hhciA9IHNvdXJjZS5uZXh0KCk7XG4gICAgaWYgKGNoYXIgPT09ICd8JyAmJiBzb3VyY2UuZWF0KCddJykpXG4gICAge1xuICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3N0cmluZyc7XG59XG5cbnZhciB3ZWxsS25vd25Xb3JkcyA9IHtcbiAgY2FzZTogMSxcbiAgb2Y6IDEsXG4gIGFzOiAxLFxuICBpZjogMSxcbiAgdGhlbjogMSxcbiAgZWxzZTogMSxcbiAgbGV0OiAxLFxuICAgIGluOiAxLFxuICB0eXBlOiAxLFxuICBhbGlhczogMSxcbiAgbW9kdWxlOiAxLFxuICB3aGVyZTogMSxcbiAgaW1wb3J0OiAxLFxuICBleHBvc2luZzogMSxcbiAgcG9ydDogMVxufTtcblxuZXhwb3J0IGNvbnN0IGVsbSA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkgIHsgcmV0dXJuIHsgZjogbm9ybWFsKCkgfTsgfSxcbiAgY29weVN0YXRlOiAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHsgZjogcy5mIH07IH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgdHlwZSA9IHN0YXRlLmYoc3RyZWFtLCBmdW5jdGlvbihzKSB7IHN0YXRlLmYgPSBzOyB9KTtcbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgcmV0dXJuICh3ZWxsS25vd25Xb3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkgPyAna2V5d29yZCcgOiB0eXBlO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9