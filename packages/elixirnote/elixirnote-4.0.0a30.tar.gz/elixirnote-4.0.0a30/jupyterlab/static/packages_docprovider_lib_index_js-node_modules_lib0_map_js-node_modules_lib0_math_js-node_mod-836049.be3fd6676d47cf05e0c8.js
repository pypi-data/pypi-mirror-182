(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["packages_docprovider_lib_index_js-node_modules_lib0_map_js-node_modules_lib0_math_js-node_mod-836049"],{

/***/ "../../packages/docprovider/lib/index.js":
/*!***********************************************!*\
  !*** ../../packages/docprovider/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IDocumentProviderFactory": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDocumentProviderFactory),
/* harmony export */   "ProviderMock": () => (/* reexport safe */ _mock__WEBPACK_IMPORTED_MODULE_0__.ProviderMock),
/* harmony export */   "WebSocketProvider": () => (/* reexport safe */ _yprovider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider)
/* harmony export */ });
/* harmony import */ var _mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mock */ "../../packages/docprovider/lib/mock.js");
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens */ "../../packages/docprovider/lib/tokens.js");
/* harmony import */ var _yprovider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./yprovider */ "../../packages/docprovider/lib/yprovider.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module docprovider
 */





/***/ }),

/***/ "../../packages/docprovider/lib/mock.js":
/*!**********************************************!*\
  !*** ../../packages/docprovider/lib/mock.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProviderMock": () => (/* binding */ ProviderMock)
/* harmony export */ });
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
class ProviderMock {
    destroy() {
        /* nop */
    }
    setPath(path) {
        /* nop */
    }
    get renameAck() {
        return Promise.resolve(false);
    }
}


/***/ }),

/***/ "../../packages/docprovider/lib/tokens.js":
/*!************************************************!*\
  !*** ../../packages/docprovider/lib/tokens.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IDocumentProviderFactory": () => (/* binding */ IDocumentProviderFactory)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * The default document provider token.
 */
const IDocumentProviderFactory = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/docprovider:IDocumentProviderFactory');


/***/ }),

/***/ "../../packages/docprovider/lib/yprovider.js":
/*!***************************************************!*\
  !*** ../../packages/docprovider/lib/yprovider.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketProvider": () => (/* binding */ WebSocketProvider)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding */ "../../node_modules/lib0/decoding.js");
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/encoding */ "../../node_modules/lib0/encoding.js");
/* harmony import */ var y_websocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-websocket */ "webpack/sharing/consume/default/y-websocket/y-websocket");
/* harmony import */ var y_websocket__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(y_websocket__WEBPACK_IMPORTED_MODULE_1__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * A class to provide Yjs synchronization over WebSocket.
 *
 * The user can specify their own user-name and user-color by adding url parameters:
 *   ?username=Alice&usercolor=007007
 * where usercolor must be a six-digit hexadecimal encoded RGB value without the hash token.
 *
 * We specify custom messages that the server can interpret. For reference please look in yjs_ws_server.
 *
 */
class WebSocketProvider extends y_websocket__WEBPACK_IMPORTED_MODULE_1__.WebsocketProvider {
    /**
     * Construct a new WebSocketProvider
     *
     * @param options The instantiation options for a WebSocketProvider
     */
    constructor(options) {
        super(options.url, options.format + ':' + options.contentType + ':' + options.path, options.ymodel.ydoc, {
            awareness: options.ymodel.awareness
        });
        this._path = options.path;
        this._contentType = options.contentType;
        this._format = options.format;
        this._serverUrl = options.url;
        // Message handler that receives the rename acknowledge
        this.messageHandlers[127] = (encoder, decoder, provider, emitSynced, messageType) => {
            this._renameAck.resolve(lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readTailAsUint8Array(decoder)[0] ? true : false);
        };
        const awareness = options.ymodel.awareness;
        const user = options.user;
        const userChanged = () => {
            const name = user.displayName !== '' ? user.displayName : user.name;
            awareness.setLocalStateField('user', Object.assign(Object.assign({}, user.toJSON()), { name }));
        };
        if (user.isReady) {
            userChanged();
        }
        user.ready.connect(userChanged);
        user.changed.connect(userChanged);
    }
    get renameAck() {
        return this._renameAck.promise;
    }
    setPath(newPath) {
        if (newPath !== this._path) {
            this._path = newPath;
            const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_3__.createEncoder();
            this._renameAck = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
            lib0_encoding__WEBPACK_IMPORTED_MODULE_3__.write(encoder, 127);
            // writing a utf8 string to the encoder
            const escapedPath = unescape(encodeURIComponent(this._format + ':' + this._contentType + ':' + newPath));
            for (let i = 0; i < escapedPath.length; i++) {
                lib0_encoding__WEBPACK_IMPORTED_MODULE_3__.write(encoder, 
                /** @type {number} */ escapedPath.codePointAt(i));
            }
            this._sendMessage(lib0_encoding__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder));
            // prevent publishing messages to the old channel id.
            this.disconnectBc();
            // The next time the provider connects, we should connect through a different server url
            this.bcChannel =
                this._serverUrl +
                    '/' +
                    this._format +
                    ':' +
                    this._contentType +
                    ':' +
                    this._path;
            this.url = this.bcChannel;
            this.connectBc();
        }
    }
    /**
     * Send a new message to WebSocket server.
     *
     * @param message The message to send
     */
    _sendMessage(message) {
        // send once connected
        const send = () => {
            setTimeout(() => {
                if (this.wsconnected) {
                    this.ws.send(message);
                }
                else {
                    this.once('status', send);
                }
            }, 0);
        };
        send();
    }
}


/***/ }),

/***/ "../../node_modules/lib0/map.js":
/*!**************************************!*\
  !*** ../../node_modules/lib0/map.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "all": () => (/* binding */ all),
/* harmony export */   "any": () => (/* binding */ any),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "setIfUndefined": () => (/* binding */ setIfUndefined)
/* harmony export */ });
/**
 * Utility module to work with key-value stores.
 *
 * @module map
 */

/**
 * Creates a new Map instance.
 *
 * @function
 * @return {Map<any, any>}
 *
 * @function
 */
const create = () => new Map()

/**
 * Copy a Map object into a fresh Map object.
 *
 * @function
 * @template X,Y
 * @param {Map<X,Y>} m
 * @return {Map<X,Y>}
 */
const copy = m => {
  const r = create()
  m.forEach((v, k) => { r.set(k, v) })
  return r
}

/**
 * Get map property. Create T if property is undefined and set T on map.
 *
 * ```js
 * const listeners = map.setIfUndefined(events, 'eventName', set.create)
 * listeners.add(listener)
 * ```
 *
 * @function
 * @template T,K
 * @param {Map<K, T>} map
 * @param {K} key
 * @param {function():T} createT
 * @return {T}
 */
const setIfUndefined = (map, key, createT) => {
  let set = map.get(key)
  if (set === undefined) {
    map.set(key, set = createT())
  }
  return set
}

/**
 * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.
 *
 * @function
 * @template K
 * @template V
 * @template R
 * @param {Map<K,V>} m
 * @param {function(V,K):R} f
 * @return {Array<R>}
 */
const map = (m, f) => {
  const res = []
  for (const [key, value] of m) {
    res.push(f(value, key))
  }
  return res
}

/**
 * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.
 *
 * @todo should rename to some - similarly to Array.some
 *
 * @function
 * @template K
 * @template V
 * @param {Map<K,V>} m
 * @param {function(V,K):boolean} f
 * @return {boolean}
 */
const any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true
    }
  }
  return false
}

/**
 * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.
 *
 * @function
 * @template K
 * @template V
 * @param {Map<K,V>} m
 * @param {function(V,K):boolean} f
 * @return {boolean}
 */
const all = (m, f) => {
  for (const [key, value] of m) {
    if (!f(value, key)) {
      return false
    }
  }
  return true
}


/***/ }),

/***/ "../../node_modules/lib0/math.js":
/*!***************************************!*\
  !*** ../../node_modules/lib0/math.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "exp10": () => (/* binding */ exp10),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "imul": () => (/* binding */ imul),
/* harmony export */   "isNaN": () => (/* binding */ isNaN),
/* harmony export */   "isNegativeZero": () => (/* binding */ isNegativeZero),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "log10": () => (/* binding */ log10),
/* harmony export */   "log2": () => (/* binding */ log2),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sqrt": () => (/* binding */ sqrt)
/* harmony export */ });
/**
 * Common Math expressions.
 *
 * @module math
 */

const floor = Math.floor
const ceil = Math.ceil
const abs = Math.abs
const imul = Math.imul
const round = Math.round
const log10 = Math.log10
const log2 = Math.log2
const log = Math.log
const sqrt = Math.sqrt

/**
 * @function
 * @param {number} a
 * @param {number} b
 * @return {number} The sum of a and b
 */
const add = (a, b) => a + b

/**
 * @function
 * @param {number} a
 * @param {number} b
 * @return {number} The smaller element of a and b
 */
const min = (a, b) => a < b ? a : b

/**
 * @function
 * @param {number} a
 * @param {number} b
 * @return {number} The bigger element of a and b
 */
const max = (a, b) => a > b ? a : b

const isNaN = Number.isNaN

const pow = Math.pow
/**
 * Base 10 exponential function. Returns the value of 10 raised to the power of pow.
 *
 * @param {number} exp
 * @return {number}
 */
const exp10 = exp => Math.pow(10, exp)

const sign = Math.sign

/**
 * @param {number} n
 * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0
 */
const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0


/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*********************************************!*\
  !*** ../../node_modules/process/browser.js ***!
  \*********************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXNfZG9jcHJvdmlkZXJfbGliX2luZGV4X2pzLW5vZGVfbW9kdWxlc19saWIwX21hcF9qcy1ub2RlX21vZHVsZXNfbGliMF9tYXRoX2pzLW5vZGVfbW9kLTgzNjA0OS5iZTNmZDY2NzZkNDdjZjA1ZTBjOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OytFQUcrRTtBQUMvRTs7O0dBR0c7QUFFb0I7QUFDRTtBQUNHOzs7Ozs7Ozs7Ozs7Ozs7O0FDWDVCOzs7R0FHRztBQUlJLE1BQU0sWUFBWTtJQUN2QixPQUFPO1FBQ0wsU0FBUztJQUNYLENBQUM7SUFDRCxPQUFPLENBQUMsSUFBWTtRQUNsQixTQUFTO0lBQ1gsQ0FBQztJQUNELElBQUksU0FBUztRQUNYLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCRDs7O0dBR0c7QUFHdUM7QUFFMUM7O0dBRUc7QUFDSSxNQUFNLHdCQUF3QixHQUFHLElBQUksb0RBQUssQ0FDL0Msa0RBQWtELENBQ25ELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiRjs7OytFQUcrRTtBQUczQjtBQUNWO0FBQ0E7QUFDNEI7QUFHdEU7Ozs7Ozs7OztHQVNHO0FBQ0ksTUFBTSxpQkFDWCxTQUFRLDBEQUFrQjtJQUcxQjs7OztPQUlHO0lBQ0gsWUFBWSxPQUFtQztRQUM3QyxLQUFLLENBQ0gsT0FBTyxDQUFDLEdBQUcsRUFDWCxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxFQUMvRCxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFDbkI7WUFDRSxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTO1NBQ3BDLENBQ0YsQ0FBQztRQUNGLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztR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QTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZG9jcHJvdmlkZXIvc3JjL2luZGV4LnRzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kb2Nwcm92aWRlci9zcmMvbW9jay50cyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZG9jcHJvdmlkZXIvc3JjL3Rva2Vucy50cyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZG9jcHJvdmlkZXIvc3JjL3lwcm92aWRlci50cyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgZG9jcHJvdmlkZXJcbiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL21vY2snO1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbnMnO1xuZXhwb3J0ICogZnJvbSAnLi95cHJvdmlkZXInO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJRG9jdW1lbnRQcm92aWRlciB9IGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgUHJvdmlkZXJNb2NrIGltcGxlbWVudHMgSURvY3VtZW50UHJvdmlkZXIge1xuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8qIG5vcCAqL1xuICB9XG4gIHNldFBhdGgocGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgLyogbm9wICovXG4gIH1cbiAgZ2V0IHJlbmFtZUFjaygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEb2N1bWVudENoYW5nZSwgWURvY3VtZW50IH0gZnJvbSAnQGp1cHl0ZXJsYWIvc2hhcmVkLW1vZGVscyc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBkb2N1bWVudCBwcm92aWRlciB0b2tlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IElEb2N1bWVudFByb3ZpZGVyRmFjdG9yeSA9IG5ldyBUb2tlbjxJRG9jdW1lbnRQcm92aWRlckZhY3Rvcnk+KFxuICAnQGp1cHl0ZXJsYWIvZG9jcHJvdmlkZXI6SURvY3VtZW50UHJvdmlkZXJGYWN0b3J5J1xuKTtcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIGEgZG9jdW1lbnQgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSURvY3VtZW50UHJvdmlkZXIge1xuICAvKipcbiAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHJlbmFtaW5nIGlzIGFja293bmxlZGdlZC5cbiAgICovXG4gIHJlYWRvbmx5IHJlbmFtZUFjazogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IHRoZSBkb2NyZWdpc3RyeSB3aGVuIHRoZSBmaWxlIGhhcyBiZWVuIHJlbmFtZWQgdG8gdXBkYXRlIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB1cmxcbiAgICovXG4gIHNldFBhdGgobmV3UGF0aDogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgcHJvdmlkZXIuXG4gICAqL1xuICBkZXN0cm95KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogVGhlIHR5cGUgZm9yIHRoZSBkb2N1bWVudCBwcm92aWRlciBmYWN0b3J5LlxuICovXG5leHBvcnQgdHlwZSBJRG9jdW1lbnRQcm92aWRlckZhY3RvcnkgPSAoXG4gIG9wdGlvbnM6IElEb2N1bWVudFByb3ZpZGVyRmFjdG9yeS5JT3B0aW9uc1xuKSA9PiBJRG9jdW1lbnRQcm92aWRlcjtcblxuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgSURvY3VtZW50UHJvdmlkZXJGYWN0b3J5IHN0YXRpY3MuXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgSURvY3VtZW50UHJvdmlkZXJGYWN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgSURvY3VtZW50UHJvdmlkZXJGYWN0b3J5LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgKGlkKSBvZiB0aGUgcm9vbVxuICAgICAqL1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBjb250ZW50VHlwZTogc3RyaW5nO1xuICAgIGZvcm1hdDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFlOb3RlYm9vay5cbiAgICAgKi9cbiAgICB5bW9kZWw6IFlEb2N1bWVudDxEb2N1bWVudENoYW5nZT47XG4gIH1cbn1cbiIsIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBJQ3VycmVudFVzZXIgfSBmcm9tICdAanVweXRlcmxhYi9jb2xsYWJvcmF0aW9uJztcbmltcG9ydCB7IFByb21pc2VEZWxlZ2F0ZSB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnO1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZyc7XG5pbXBvcnQgeyBXZWJzb2NrZXRQcm92aWRlciBhcyBZV2Vic29ja2V0UHJvdmlkZXIgfSBmcm9tICd5LXdlYnNvY2tldCc7XG5pbXBvcnQgeyBJRG9jdW1lbnRQcm92aWRlciwgSURvY3VtZW50UHJvdmlkZXJGYWN0b3J5IH0gZnJvbSAnLi90b2tlbnMnO1xuXG4vKipcbiAqIEEgY2xhc3MgdG8gcHJvdmlkZSBZanMgc3luY2hyb25pemF0aW9uIG92ZXIgV2ViU29ja2V0LlxuICpcbiAqIFRoZSB1c2VyIGNhbiBzcGVjaWZ5IHRoZWlyIG93biB1c2VyLW5hbWUgYW5kIHVzZXItY29sb3IgYnkgYWRkaW5nIHVybCBwYXJhbWV0ZXJzOlxuICogICA/dXNlcm5hbWU9QWxpY2UmdXNlcmNvbG9yPTAwNzAwN1xuICogd2hlcmUgdXNlcmNvbG9yIG11c3QgYmUgYSBzaXgtZGlnaXQgaGV4YWRlY2ltYWwgZW5jb2RlZCBSR0IgdmFsdWUgd2l0aG91dCB0aGUgaGFzaCB0b2tlbi5cbiAqXG4gKiBXZSBzcGVjaWZ5IGN1c3RvbSBtZXNzYWdlcyB0aGF0IHRoZSBzZXJ2ZXIgY2FuIGludGVycHJldC4gRm9yIHJlZmVyZW5jZSBwbGVhc2UgbG9vayBpbiB5anNfd3Nfc2VydmVyLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlNvY2tldFByb3ZpZGVyXG4gIGV4dGVuZHMgWVdlYnNvY2tldFByb3ZpZGVyXG4gIGltcGxlbWVudHMgSURvY3VtZW50UHJvdmlkZXJcbntcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBXZWJTb2NrZXRQcm92aWRlclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIFdlYlNvY2tldFByb3ZpZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBXZWJTb2NrZXRQcm92aWRlci5JT3B0aW9ucykge1xuICAgIHN1cGVyKFxuICAgICAgb3B0aW9ucy51cmwsXG4gICAgICBvcHRpb25zLmZvcm1hdCArICc6JyArIG9wdGlvbnMuY29udGVudFR5cGUgKyAnOicgKyBvcHRpb25zLnBhdGgsXG4gICAgICBvcHRpb25zLnltb2RlbC55ZG9jLFxuICAgICAge1xuICAgICAgICBhd2FyZW5lc3M6IG9wdGlvbnMueW1vZGVsLmF3YXJlbmVzc1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5fcGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICB0aGlzLl9jb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gICAgdGhpcy5fZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gICAgdGhpcy5fc2VydmVyVXJsID0gb3B0aW9ucy51cmw7XG5cbiAgICAvLyBNZXNzYWdlIGhhbmRsZXIgdGhhdCByZWNlaXZlcyB0aGUgcmVuYW1lIGFja25vd2xlZGdlXG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlcnNbMTI3XSA9IChcbiAgICAgIGVuY29kZXIsXG4gICAgICBkZWNvZGVyLFxuICAgICAgcHJvdmlkZXIsXG4gICAgICBlbWl0U3luY2VkLFxuICAgICAgbWVzc2FnZVR5cGVcbiAgICApID0+IHtcbiAgICAgIHRoaXMuX3JlbmFtZUFjay5yZXNvbHZlKFxuICAgICAgICBkZWNvZGluZy5yZWFkVGFpbEFzVWludDhBcnJheShkZWNvZGVyKVswXSA/IHRydWUgOiBmYWxzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXdhcmVuZXNzID0gb3B0aW9ucy55bW9kZWwuYXdhcmVuZXNzO1xuICAgIGNvbnN0IHVzZXIgPSBvcHRpb25zLnVzZXI7XG4gICAgY29uc3QgdXNlckNoYW5nZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdXNlci5kaXNwbGF5TmFtZSAhPT0gJycgPyB1c2VyLmRpc3BsYXlOYW1lIDogdXNlci5uYW1lO1xuICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgndXNlcicsIHsgLi4udXNlci50b0pTT04oKSwgbmFtZSB9KTtcbiAgICB9O1xuICAgIGlmICh1c2VyLmlzUmVhZHkpIHtcbiAgICAgIHVzZXJDaGFuZ2VkKCk7XG4gICAgfVxuICAgIHVzZXIucmVhZHkuY29ubmVjdCh1c2VyQ2hhbmdlZCk7XG4gICAgdXNlci5jaGFuZ2VkLmNvbm5lY3QodXNlckNoYW5nZWQpO1xuICB9XG5cbiAgZ2V0IHJlbmFtZUFjaygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fcmVuYW1lQWNrLnByb21pc2U7XG4gIH1cblxuICBzZXRQYXRoKG5ld1BhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChuZXdQYXRoICE9PSB0aGlzLl9wYXRoKSB7XG4gICAgICB0aGlzLl9wYXRoID0gbmV3UGF0aDtcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gICAgICB0aGlzLl9yZW5hbWVBY2sgPSBuZXcgUHJvbWlzZURlbGVnYXRlPGJvb2xlYW4+KCk7XG4gICAgICBlbmNvZGluZy53cml0ZShlbmNvZGVyLCAxMjcpO1xuICAgICAgLy8gd3JpdGluZyBhIHV0Zjggc3RyaW5nIHRvIHRoZSBlbmNvZGVyXG4gICAgICBjb25zdCBlc2NhcGVkUGF0aCA9IHVuZXNjYXBlKFxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgdGhpcy5fZm9ybWF0ICsgJzonICsgdGhpcy5fY29udGVudFR5cGUgKyAnOicgKyBuZXdQYXRoXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVzY2FwZWRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVuY29kaW5nLndyaXRlKFxuICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGVzY2FwZWRQYXRoLmNvZGVQb2ludEF0KGkpIVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKTtcbiAgICAgIC8vIHByZXZlbnQgcHVibGlzaGluZyBtZXNzYWdlcyB0byB0aGUgb2xkIGNoYW5uZWwgaWQuXG4gICAgICB0aGlzLmRpc2Nvbm5lY3RCYygpO1xuICAgICAgLy8gVGhlIG5leHQgdGltZSB0aGUgcHJvdmlkZXIgY29ubmVjdHMsIHdlIHNob3VsZCBjb25uZWN0IHRocm91Z2ggYSBkaWZmZXJlbnQgc2VydmVyIHVybFxuICAgICAgdGhpcy5iY0NoYW5uZWwgPVxuICAgICAgICB0aGlzLl9zZXJ2ZXJVcmwgK1xuICAgICAgICAnLycgK1xuICAgICAgICB0aGlzLl9mb3JtYXQgK1xuICAgICAgICAnOicgK1xuICAgICAgICB0aGlzLl9jb250ZW50VHlwZSArXG4gICAgICAgICc6JyArXG4gICAgICAgIHRoaXMuX3BhdGg7XG4gICAgICB0aGlzLnVybCA9IHRoaXMuYmNDaGFubmVsO1xuICAgICAgdGhpcy5jb25uZWN0QmMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG5ldyBtZXNzYWdlIHRvIFdlYlNvY2tldCBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICovXG4gIHByaXZhdGUgX3NlbmRNZXNzYWdlKG1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICAvLyBzZW5kIG9uY2UgY29ubmVjdGVkXG4gICAgY29uc3Qgc2VuZCA9ICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy53c2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMud3MhLnNlbmQobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbmNlKCdzdGF0dXMnLCBzZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBzZW5kKCk7XG4gIH1cblxuICBwcml2YXRlIF9wYXRoOiBzdHJpbmc7XG4gIHByaXZhdGUgX2NvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIHByaXZhdGUgX2Zvcm1hdDogc3RyaW5nO1xuICBwcml2YXRlIF9zZXJ2ZXJVcmw6IHN0cmluZztcbiAgcHJpdmF0ZSBfcmVuYW1lQWNrOiBQcm9taXNlRGVsZWdhdGU8Ym9vbGVhbj47XG59XG5cbi8qKlxuICogQSBuYW1lc3BhY2UgZm9yIFdlYlNvY2tldFByb3ZpZGVyIHN0YXRpY3MuXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgV2ViU29ja2V0UHJvdmlkZXIge1xuICAvKipcbiAgICogVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBXZWJTb2NrZXRQcm92aWRlci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSU9wdGlvbnMgZXh0ZW5kcyBJRG9jdW1lbnRQcm92aWRlckZhY3RvcnkuSU9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgVVJMXG4gICAgICovXG4gICAgdXJsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBkYXRhXG4gICAgICovXG4gICAgdXNlcjogSUN1cnJlbnRVc2VyO1xuICB9XG59XG4iLCIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKClcblxuLyoqXG4gKiBDb3B5IGEgTWFwIG9iamVjdCBpbnRvIGEgZnJlc2ggTWFwIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBYLFlcbiAqIEBwYXJhbSB7TWFwPFgsWT59IG1cbiAqIEByZXR1cm4ge01hcDxYLFk+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IG0gPT4ge1xuICBjb25zdCByID0gY3JlYXRlKClcbiAgbS5mb3JFYWNoKCh2LCBrKSA9PiB7IHIuc2V0KGssIHYpIH0pXG4gIHJldHVybiByXG59XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQsS1xuICogQHBhcmFtIHtNYXA8SywgVD59IG1hcFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBjcmVhdGVUXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3Qgc2V0SWZVbmRlZmluZWQgPSAobWFwLCBrZXksIGNyZWF0ZVQpID0+IHtcbiAgbGV0IHNldCA9IG1hcC5nZXQoa2V5KVxuICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKVxuICB9XG4gIHJldHVybiBzZXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEFycmF5IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCB0aGUgY29udGVudCBvZiBhbGwga2V5LXZhbHVlIHBhaXJzIHVzaW5nIHRoZSBgZih2YWx1ZSwga2V5KWAgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsSyk6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAobSwgZikgPT4ge1xuICBjb25zdCByZXMgPSBbXVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgcmVzLnB1c2goZih2YWx1ZSwga2V5KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhbnkga2V5LXZhbHVlIHBhaXJzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgYGYodmFsdWUsIGtleSlgLlxuICpcbiAqIEB0b2RvIHNob3VsZCByZW5hbWUgdG8gc29tZSAtIHNpbWlsYXJseSB0byBBcnJheS5zb21lXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYW55ID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmIChmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFsbCBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYWxsID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmICghZih2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iLCIvKipcbiAqIENvbW1vbiBNYXRoIGV4cHJlc3Npb25zLlxuICpcbiAqIEBtb2R1bGUgbWF0aFxuICovXG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IE1hdGguZmxvb3JcbmV4cG9ydCBjb25zdCBjZWlsID0gTWF0aC5jZWlsXG5leHBvcnQgY29uc3QgYWJzID0gTWF0aC5hYnNcbmV4cG9ydCBjb25zdCBpbXVsID0gTWF0aC5pbXVsXG5leHBvcnQgY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwXG5leHBvcnQgY29uc3QgbG9nMiA9IE1hdGgubG9nMlxuZXhwb3J0IGNvbnN0IGxvZyA9IE1hdGgubG9nXG5leHBvcnQgY29uc3Qgc3FydCA9IE1hdGguc3FydFxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzdW0gb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgYWRkID0gKGEsIGIpID0+IGEgKyBiXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYlxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYlxuXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cblxuZXhwb3J0IGNvbnN0IHBvdyA9IE1hdGgucG93XG4vKipcbiAqIEJhc2UgMTAgZXhwb25lbnRpYWwgZnVuY3Rpb24uIFJldHVybnMgdGhlIHZhbHVlIG9mIDEwIHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgcG93LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cDEwID0gZXhwID0+IE1hdGgucG93KDEwLCBleHApXG5cbmV4cG9ydCBjb25zdCBzaWduID0gTWF0aC5zaWduXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdldGhlciBuIGlzIG5lZ2F0aXZlLiBUaGlzIGZ1bmN0aW9uIGFsc28gZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiAtMCBhbmQgKzBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVaZXJvID0gbiA9PiBuICE9PSAwID8gbiA8IDAgOiAxIC8gbiA8IDBcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=