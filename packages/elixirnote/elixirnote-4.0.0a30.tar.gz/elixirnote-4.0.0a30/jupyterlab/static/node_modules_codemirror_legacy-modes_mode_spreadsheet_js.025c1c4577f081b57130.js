"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_spreadsheet_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/spreadsheet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/spreadsheet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spreadsheet": () => (/* binding */ spreadsheet)
/* harmony export */ });
const spreadsheet = {
  startState: function () {
    return {
      stringType: null,
      stack: []
    };
  },
  token: function (stream, state) {
    if (!stream) return;

    //check for state changes
    if (state.stack.length === 0) {
      //strings
      if ((stream.peek() == '"') || (stream.peek() == "'")) {
        state.stringType = stream.peek();
        stream.next(); // Skip quote
        state.stack.unshift("string");
      }
    }

    //return state
    //stack has
    switch (state.stack[0]) {
    case "string":
      while (state.stack[0] === "string" && !stream.eol()) {
        if (stream.peek() === state.stringType) {
          stream.next(); // Skip quote
          state.stack.shift(); // Clear flag
        } else if (stream.peek() === "\\") {
          stream.next();
          stream.next();
        } else {
          stream.match(/^.[^\\\"\']*/);
        }
      }
      return "string";

    case "characterClass":
      while (state.stack[0] === "characterClass" && !stream.eol()) {
        if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./)))
          state.stack.shift();
      }
      return "operator";
    }

    var peek = stream.peek();

    //no stack
    switch (peek) {
    case "[":
      stream.next();
      state.stack.unshift("characterClass");
      return "bracket";
    case ":":
      stream.next();
      return "operator";
    case "\\":
      if (stream.match(/\\[a-z]+/)) return "string.special";
      else {
        stream.next();
        return "atom";
      }
    case ".":
    case ",":
    case ";":
    case "*":
    case "-":
    case "+":
    case "^":
    case "<":
    case "/":
    case "=":
      stream.next();
      return "atom";
    case "$":
      stream.next();
      return "builtin";
    }

    if (stream.match(/\d+/)) {
      if (stream.match(/^\w+/)) return "error";
      return "number";
    } else if (stream.match(/^[a-zA-Z_]\w*/)) {
      if (stream.match(/(?=[\(.])/, false)) return "keyword";
      return "variable";
    } else if (["[", "]", "(", ")", "{", "}"].indexOf(peek) != -1) {
      stream.next();
      return "bracket";
    } else if (!stream.eatSpace()) {
      stream.next();
    }
    return null;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc3ByZWFkc2hlZXRfanMuMDI1YzFjNDU3N2YwODFiNTcxMzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwrQkFBK0I7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sZ0NBQWdDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zcHJlYWRzaGVldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgc3ByZWFkc2hlZXQgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaW5nVHlwZTogbnVsbCxcbiAgICAgIHN0YWNrOiBbXVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICghc3RyZWFtKSByZXR1cm47XG5cbiAgICAvL2NoZWNrIGZvciBzdGF0ZSBjaGFuZ2VzXG4gICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy9zdHJpbmdzXG4gICAgICBpZiAoKHN0cmVhbS5wZWVrKCkgPT0gJ1wiJykgfHwgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpKSB7XG4gICAgICAgIHN0YXRlLnN0cmluZ1R5cGUgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBTa2lwIHF1b3RlXG4gICAgICAgIHN0YXRlLnN0YWNrLnVuc2hpZnQoXCJzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9yZXR1cm4gc3RhdGVcbiAgICAvL3N0YWNrIGhhc1xuICAgIHN3aXRjaCAoc3RhdGUuc3RhY2tbMF0pIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICB3aGlsZSAoc3RhdGUuc3RhY2tbMF0gPT09IFwic3RyaW5nXCIgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gc3RhdGUuc3RyaW5nVHlwZSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7IC8vIFNraXAgcXVvdGVcbiAgICAgICAgICBzdGF0ZS5zdGFjay5zaGlmdCgpOyAvLyBDbGVhciBmbGFnXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC9eLlteXFxcXFxcXCJcXCddKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAgIGNhc2UgXCJjaGFyYWN0ZXJDbGFzc1wiOlxuICAgICAgd2hpbGUgKHN0YXRlLnN0YWNrWzBdID09PSBcImNoYXJhY3RlckNsYXNzXCIgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoIShzdHJlYW0ubWF0Y2goL15bXlxcXVxcXFxdKy8pIHx8IHN0cmVhbS5tYXRjaCgvXlxcXFwuLykpKVxuICAgICAgICAgIHN0YXRlLnN0YWNrLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cblxuICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIC8vbm8gc3RhY2tcbiAgICBzd2l0Y2ggKHBlZWspIHtcbiAgICBjYXNlIFwiW1wiOlxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0YXRlLnN0YWNrLnVuc2hpZnQoXCJjaGFyYWN0ZXJDbGFzc1wiKTtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICBjYXNlIFwiOlwiOlxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcXFxbYS16XSsvKSkgcmV0dXJuIFwic3RyaW5nLnNwZWNpYWxcIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9XG4gICAgY2FzZSBcIi5cIjpcbiAgICBjYXNlIFwiLFwiOlxuICAgIGNhc2UgXCI7XCI6XG4gICAgY2FzZSBcIipcIjpcbiAgICBjYXNlIFwiLVwiOlxuICAgIGNhc2UgXCIrXCI6XG4gICAgY2FzZSBcIl5cIjpcbiAgICBjYXNlIFwiPFwiOlxuICAgIGNhc2UgXCIvXCI6XG4gICAgY2FzZSBcIj1cIjpcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxkKy8pKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFx3Ky8pKSByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bYS16QS1aX11cXHcqLykpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goLyg/PVtcXCguXSkvLCBmYWxzZSkpIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfSBlbHNlIGlmIChbXCJbXCIsIFwiXVwiLCBcIihcIiwgXCIpXCIsIFwie1wiLCBcIn1cIl0uaW5kZXhPZihwZWVrKSAhPSAtMSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9IGVsc2UgaWYgKCFzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=