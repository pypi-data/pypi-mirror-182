"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_groovy_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/groovy.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/groovy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "groovy": () => (/* binding */ groovy)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
var keywords = words(
  "abstract as assert boolean break byte case catch char class const continue def default " +
    "do double else enum extends final finally float for goto if implements import in " +
    "instanceof int interface long native new package private protected public return " +
    "short static strictfp super switch synchronized threadsafe throw throws trait transient " +
    "try void volatile while");
var blockKeywords = words("catch class def do else enum finally for if interface switch trait try while");
var standaloneKeywords = words("return break continue");
var atoms = words("null true false this");

var curPunc;
function tokenBase(stream, state) {
  var ch = stream.next();
  if (ch == '"' || ch == "'") {
    return startString(ch, stream, state);
  }
  if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
    curPunc = ch;
    return null;
  }
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\w\.]/);
    if (stream.eat(/eE/)) { stream.eat(/\+\-/); stream.eatWhile(/\d/); }
    return "number";
  }
  if (ch == "/") {
    if (stream.eat("*")) {
      state.tokenize.push(tokenComment);
      return tokenComment(stream, state);
    }
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
    if (expectExpression(state.lastToken, false)) {
      return startString(ch, stream, state);
    }
  }
  if (ch == "-" && stream.eat(">")) {
    curPunc = "->";
    return null;
  }
  if (/[+\-*&%=<>!?|\/~]/.test(ch)) {
    stream.eatWhile(/[+\-*&%=<>|~]/);
    return "operator";
  }
  stream.eatWhile(/[\w\$_]/);
  if (ch == "@") { stream.eatWhile(/[\w\$_\.]/); return "meta"; }
  if (state.lastToken == ".") return "property";
  if (stream.eat(":")) { curPunc = "proplabel"; return "property"; }
  var cur = stream.current();
  if (atoms.propertyIsEnumerable(cur)) { return "atom"; }
  if (keywords.propertyIsEnumerable(cur)) {
    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
    else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = "standalone";
    return "keyword";
  }
  return "variable";
}
tokenBase.isBase = true;

function startString(quote, stream, state) {
  var tripleQuoted = false;
  if (quote != "/" && stream.eat(quote)) {
    if (stream.eat(quote)) tripleQuoted = true;
    else return "string";
  }
  function t(stream, state) {
    var escaped = false, next, end = !tripleQuoted;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {
        if (!tripleQuoted) { break; }
        if (stream.match(quote + quote)) { end = true; break; }
      }
      if (quote == '"' && next == "$" && !escaped) {
        if (stream.eat("{")) {
          state.tokenize.push(tokenBaseUntilBrace());
          return "string";
        } else if (stream.match(/^\w/, false)) {
          state.tokenize.push(tokenVariableDeref);
          return "string";
        }
      }
      escaped = !escaped && next == "\\";
    }
    if (end) state.tokenize.pop();
    return "string";
  }
  state.tokenize.push(t);
  return t(stream, state);
}

function tokenBaseUntilBrace() {
  var depth = 1;
  function t(stream, state) {
    if (stream.peek() == "}") {
      depth--;
      if (depth == 0) {
        state.tokenize.pop();
        return state.tokenize[state.tokenize.length-1](stream, state);
      }
    } else if (stream.peek() == "{") {
      depth++;
    }
    return tokenBase(stream, state);
  }
  t.isBase = true;
  return t;
}

function tokenVariableDeref(stream, state) {
  var next = stream.match(/^(\.|[\w\$_]+)/)
  if (!next) {
    state.tokenize.pop()
    return state.tokenize[state.tokenize.length-1](stream, state)
  }
  return next[0] == "." ? null : "variable"
}

function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == "/" && maybeEnd) {
      state.tokenize.pop();
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function expectExpression(last, newline) {
  return !last || last == "operator" || last == "->" || /[\.\[\{\(,;:]/.test(last) ||
    last == "newstatement" || last == "keyword" || last == "proplabel" ||
    (last == "standalone" && !newline);
}

function Context(indented, column, type, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.align = align;
  this.prev = prev;
}
function pushContext(state, col, type) {
  return state.context = new Context(state.indented, col, type, null, state.context);
}
function popContext(state) {
  var t = state.context.type;
  if (t == ")" || t == "]" || t == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

// Interface

const groovy = {
  startState: function(indentUnit) {
    return {
      tokenize: [tokenBase],
      context: new Context(-indentUnit, 0, "top", false),
      indented: 0,
      startOfLine: true,
      lastToken: null
    };
  },

  token: function(stream, state) {
    var ctx = state.context;
    if (stream.sol()) {
      if (ctx.align == null) ctx.align = false;
      state.indented = stream.indentation();
      state.startOfLine = true;
      // Automatic semicolon insertion
      if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) {
        popContext(state); ctx = state.context;
      }
    }
    if (stream.eatSpace()) return null;
    curPunc = null;
    var style = state.tokenize[state.tokenize.length-1](stream, state);
    if (style == "comment") return style;
    if (ctx.align == null) ctx.align = true;

    if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
    // Handle indentation for {x -> \n ... }
    else if (curPunc == "->" && ctx.type == "statement" && ctx.prev.type == "}") {
      popContext(state);
      state.context.align = false;
    }
    else if (curPunc == "{") pushContext(state, stream.column(), "}");
    else if (curPunc == "[") pushContext(state, stream.column(), "]");
    else if (curPunc == "(") pushContext(state, stream.column(), ")");
    else if (curPunc == "}") {
      while (ctx.type == "statement") ctx = popContext(state);
      if (ctx.type == "}") ctx = popContext(state);
      while (ctx.type == "statement") ctx = popContext(state);
    }
    else if (curPunc == ctx.type) popContext(state);
    else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
      pushContext(state, stream.column(), "statement");
    state.startOfLine = false;
    state.lastToken = curPunc || style;
    return style;
  },

  indent: function(state, textAfter, cx) {
    if (!state.tokenize[state.tokenize.length-1].isBase) return null;
    var firstChar = textAfter && textAfter.charAt(0), ctx = state.context;
    if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;
    var closing = firstChar == ctx.type;
    if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : cx.unit);
    else if (ctx.align) return ctx.column + (closing ? 0 : 1);
    else return ctx.indented + (closing ? 0 : cx.unit);
  },

  languageData: {
    indentOnInput: /^\s*[{}]$/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', "'''", '"""']}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZ3Jvb3Z5X2pzLjdkZDNiOWJiZjU0NmU1NTVmY2JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDO0FBQ25FO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQixvQkFBb0IseUJBQXlCO0FBQ2pFLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZ3Jvb3Z5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG52YXIga2V5d29yZHMgPSB3b3JkcyhcbiAgXCJhYnN0cmFjdCBhcyBhc3NlcnQgYm9vbGVhbiBicmVhayBieXRlIGNhc2UgY2F0Y2ggY2hhciBjbGFzcyBjb25zdCBjb250aW51ZSBkZWYgZGVmYXVsdCBcIiArXG4gICAgXCJkbyBkb3VibGUgZWxzZSBlbnVtIGV4dGVuZHMgZmluYWwgZmluYWxseSBmbG9hdCBmb3IgZ290byBpZiBpbXBsZW1lbnRzIGltcG9ydCBpbiBcIiArXG4gICAgXCJpbnN0YW5jZW9mIGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgbmV3IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHJldHVybiBcIiArXG4gICAgXCJzaG9ydCBzdGF0aWMgc3RyaWN0ZnAgc3VwZXIgc3dpdGNoIHN5bmNocm9uaXplZCB0aHJlYWRzYWZlIHRocm93IHRocm93cyB0cmFpdCB0cmFuc2llbnQgXCIgK1xuICAgIFwidHJ5IHZvaWQgdm9sYXRpbGUgd2hpbGVcIik7XG52YXIgYmxvY2tLZXl3b3JkcyA9IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZGVmIGRvIGVsc2UgZW51bSBmaW5hbGx5IGZvciBpZiBpbnRlcmZhY2Ugc3dpdGNoIHRyYWl0IHRyeSB3aGlsZVwiKTtcbnZhciBzdGFuZGFsb25lS2V5d29yZHMgPSB3b3JkcyhcInJldHVybiBicmVhayBjb250aW51ZVwiKTtcbnZhciBhdG9tcyA9IHdvcmRzKFwibnVsbCB0cnVlIGZhbHNlIHRoaXNcIik7XG5cbnZhciBjdXJQdW5jO1xuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICByZXR1cm4gc3RhcnRTdHJpbmcoY2gsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgIGN1clB1bmMgPSBjaDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgaWYgKHN0cmVhbS5lYXQoL2VFLykpIHsgc3RyZWFtLmVhdCgvXFwrXFwtLyk7IHN0cmVhbS5lYXRXaGlsZSgvXFxkLyk7IH1cbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5Db21tZW50KTtcbiAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0RXhwcmVzc2lvbihzdGF0ZS5sYXN0VG9rZW4sIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0U3RyaW5nKGNoLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNoID09IFwiLVwiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgY3VyUHVuYyA9IFwiLT5cIjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoL1srXFwtKiYlPTw+IT98XFwvfl0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bK1xcLSomJT08Pnx+XS8pO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgaWYgKGNoID09IFwiQFwiKSB7IHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXC5dLyk7IHJldHVybiBcIm1ldGFcIjsgfVxuICBpZiAoc3RhdGUubGFzdFRva2VuID09IFwiLlwiKSByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICBpZiAoc3RyZWFtLmVhdChcIjpcIikpIHsgY3VyUHVuYyA9IFwicHJvcGxhYmVsXCI7IHJldHVybiBcInByb3BlcnR5XCI7IH1cbiAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7IHJldHVybiBcImF0b21cIjsgfVxuICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgIGlmIChibG9ja0tleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgIGVsc2UgaWYgKHN0YW5kYWxvbmVLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJzdGFuZGFsb25lXCI7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG50b2tlbkJhc2UuaXNCYXNlID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3RhcnRTdHJpbmcocXVvdGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIHRyaXBsZVF1b3RlZCA9IGZhbHNlO1xuICBpZiAocXVvdGUgIT0gXCIvXCIgJiYgc3RyZWFtLmVhdChxdW90ZSkpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHRyaXBsZVF1b3RlZCA9IHRydWU7XG4gICAgZWxzZSByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuICBmdW5jdGlvbiB0KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSAhdHJpcGxlUXVvdGVkO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgIGlmICghdHJpcGxlUXVvdGVkKSB7IGJyZWFrOyB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gocXVvdGUgKyBxdW90ZSkpIHsgZW5kID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIGlmIChxdW90ZSA9PSAnXCInICYmIG5leHQgPT0gXCIkXCIgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUucHVzaCh0b2tlbkJhc2VVbnRpbEJyYWNlKCkpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlxcdy8sIGZhbHNlKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5WYXJpYWJsZURlcmVmKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIGlmIChlbmQpIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIHN0YXRlLnRva2VuaXplLnB1c2godCk7XG4gIHJldHVybiB0KHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJhc2VVbnRpbEJyYWNlKCkge1xuICB2YXIgZGVwdGggPSAxO1xuICBmdW5jdGlvbiB0KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIn1cIikge1xuICAgICAgZGVwdGgtLTtcbiAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIntcIikge1xuICAgICAgZGVwdGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICB0LmlzQmFzZSA9IHRydWU7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiB0b2tlblZhcmlhYmxlRGVyZWYoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmV4dCA9IHN0cmVhbS5tYXRjaCgvXihcXC58W1xcd1xcJF9dKykvKVxuICBpZiAoIW5leHQpIHtcbiAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKVxuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0oc3RyZWFtLCBzdGF0ZSlcbiAgfVxuICByZXR1cm4gbmV4dFswXSA9PSBcIi5cIiA/IG51bGwgOiBcInZhcmlhYmxlXCJcbn1cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiBleHBlY3RFeHByZXNzaW9uKGxhc3QsIG5ld2xpbmUpIHtcbiAgcmV0dXJuICFsYXN0IHx8IGxhc3QgPT0gXCJvcGVyYXRvclwiIHx8IGxhc3QgPT0gXCItPlwiIHx8IC9bXFwuXFxbXFx7XFwoLDs6XS8udGVzdChsYXN0KSB8fFxuICAgIGxhc3QgPT0gXCJuZXdzdGF0ZW1lbnRcIiB8fCBsYXN0ID09IFwia2V5d29yZFwiIHx8IGxhc3QgPT0gXCJwcm9wbGFiZWxcIiB8fFxuICAgIChsYXN0ID09IFwic3RhbmRhbG9uZVwiICYmICFuZXdsaW5lKTtcbn1cblxuZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldikge1xuICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmFsaWduID0gYWxpZ247XG4gIHRoaXMucHJldiA9IHByZXY7XG59XG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlKSB7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuaW5kZW50ZWQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG59XG5mdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbn1cblxuLy8gSW50ZXJmYWNlXG5cbmV4cG9ydCBjb25zdCBncm9vdnkgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGluZGVudFVuaXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IFt0b2tlbkJhc2VdLFxuICAgICAgY29udGV4dDogbmV3IENvbnRleHQoLWluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgIGluZGVudGVkOiAwLFxuICAgICAgc3RhcnRPZkxpbmU6IHRydWUsXG4gICAgICBsYXN0VG9rZW46IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgICAvLyBBdXRvbWF0aWMgc2VtaWNvbG9uIGluc2VydGlvblxuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgIWV4cGVjdEV4cHJlc3Npb24oc3RhdGUubGFzdFRva2VuLCB0cnVlKSkge1xuICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTsgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICBjdXJQdW5jID0gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiKSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIpICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIC8vIEhhbmRsZSBpbmRlbnRhdGlvbiBmb3Ige3ggLT4gXFxuIC4uLiB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIi0+XCIgJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdHgucHJldi50eXBlID09IFwifVwiKSB7XG4gICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvbnRleHQuYWxpZ24gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIiB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKVxuICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXJQdW5jIHx8IHN0eWxlO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgaWYgKCFzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0uaXNCYXNlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgIWV4cGVjdEV4cHJlc3Npb24oc3RhdGUubGFzdFRva2VuLCB0cnVlKSkgY3R4ID0gY3R4LnByZXY7XG4gICAgdmFyIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gY3R4LnR5cGU7XG4gICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHJldHVybiBjdHguaW5kZW50ZWQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IGN4LnVuaXQpO1xuICAgIGVsc2UgaWYgKGN0eC5hbGlnbikgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICBlbHNlIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBjeC51bml0KTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypbe31dJC8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLy9cIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fSxcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgXCInJydcIiwgJ1wiXCJcIiddfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9