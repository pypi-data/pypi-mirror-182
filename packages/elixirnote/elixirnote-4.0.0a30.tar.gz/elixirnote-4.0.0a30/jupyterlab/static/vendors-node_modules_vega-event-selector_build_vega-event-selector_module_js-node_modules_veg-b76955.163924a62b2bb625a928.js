"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega-event-selector_build_vega-event-selector_module_js-node_modules_veg-b76955"],{

/***/ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-event-selector/build/vega-event-selector.module.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSelector": () => (/* binding */ eventSelector)
/* harmony export */ });
const VIEW = 'view',
      LBRACK = '[',
      RBRACK = ']',
      LBRACE = '{',
      RBRACE = '}',
      COLON = ':',
      COMMA = ',',
      NAME = '@',
      GT = '>',
      ILLEGAL = /[[\]{}]/,
      DEFAULT_MARKS = {
  '*': 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let DEFAULT_SOURCE, MARKS;
/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */

function eventSelector (selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}

function isMarkType(type) {
  return MARKS[type];
}

function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0,
      c;

  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }

  return i;
}

function parseMerge(s) {
  const output = [],
        n = s.length;
  let start = 0,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }

  return output;
}

function parseSelector(s) {
  return s[0] === '[' ? parseBetween(s) : parseStream(s);
}

function parseBetween(s) {
  const n = s.length;
  let i = 1,
      b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);

  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));

  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();

  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());

  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  const stream = {
    source: DEFAULT_SOURCE
  },
        source = [];
  let throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0,
      j,
      filter; // extract throttle from end

  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);

    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }

      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;

    i = 0;
  }

  if (!n) throw s; // set name flag based on first char

  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector

  j = find(s, i, COLON);

  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  } // extract remaining part of stream selector


  i = find(s, i, LBRACK);

  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  } // extract filters


  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  } // marshall event stream specification


  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];

    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }

  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }

  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];
  return stream;
}

function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(_ => {
    const x = +_;
    if (x !== x) throw s;
    return x;
  });
}




/***/ }),

/***/ "../../node_modules/vega-expression/build/vega-expression.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-expression/build/vega-expression.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTNode": () => (/* binding */ ASTNode),
/* harmony export */   "ArrayExpression": () => (/* binding */ ArrayExpression),
/* harmony export */   "BinaryExpression": () => (/* binding */ BinaryExpression),
/* harmony export */   "CallExpression": () => (/* binding */ CallExpression),
/* harmony export */   "ConditionalExpression": () => (/* binding */ ConditionalExpression),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Literal": () => (/* binding */ Literal),
/* harmony export */   "LogicalExpression": () => (/* binding */ LogicalExpression),
/* harmony export */   "MemberExpression": () => (/* binding */ MemberExpression),
/* harmony export */   "ObjectExpression": () => (/* binding */ ObjectExpression),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "RawCode": () => (/* binding */ RawCode),
/* harmony export */   "UnaryExpression": () => (/* binding */ UnaryExpression),
/* harmony export */   "codegenExpression": () => (/* binding */ codegen),
/* harmony export */   "constants": () => (/* binding */ Constants),
/* harmony export */   "functions": () => (/* binding */ Functions),
/* harmony export */   "parseExpression": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");


const RawCode = 'RawCode';
const Literal = 'Literal';
const Property = 'Property';
const Identifier = 'Identifier';
const ArrayExpression = 'ArrayExpression';
const BinaryExpression = 'BinaryExpression';
const CallExpression = 'CallExpression';
const ConditionalExpression = 'ConditionalExpression';
const LogicalExpression = 'LogicalExpression';
const MemberExpression = 'MemberExpression';
const ObjectExpression = 'ObjectExpression';
const UnaryExpression = 'UnaryExpression';
function ASTNode(type) {
  this.type = type;
}

ASTNode.prototype.visit = function (visitor) {
  let c, i, n;
  if (visitor(this)) return 1;

  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};

function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;

    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];

    case CallExpression:
      return [node.callee].concat(node.arguments);

    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];

    case MemberExpression:
      return [node.object, node.property];

    case ObjectExpression:
      return node.properties;

    case Property:
      return [node.key, node.value];

    case UnaryExpression:
      return [node.argument];

    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}

/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var TokenName, source, index, length, lookahead;
var TokenBooleanLiteral = 1,
    TokenEOF = 2,
    TokenIdentifier = 3,
    TokenKeyword = 4,
    TokenNullLiteral = 5,
    TokenNumericLiteral = 6,
    TokenPunctuator = 7,
    TokenStringLiteral = 8,
    TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = 'Boolean';
TokenName[TokenEOF] = '<end>';
TokenName[TokenIdentifier] = 'Identifier';
TokenName[TokenKeyword] = 'Keyword';
TokenName[TokenNullLiteral] = 'Null';
TokenName[TokenNumericLiteral] = 'Numeric';
TokenName[TokenPunctuator] = 'Punctuator';
TokenName[TokenStringLiteral] = 'String';
TokenName[TokenRegularExpression] = 'RegularExpression';
var SyntaxArrayExpression = 'ArrayExpression',
    SyntaxBinaryExpression = 'BinaryExpression',
    SyntaxCallExpression = 'CallExpression',
    SyntaxConditionalExpression = 'ConditionalExpression',
    SyntaxIdentifier = 'Identifier',
    SyntaxLiteral = 'Literal',
    SyntaxLogicalExpression = 'LogicalExpression',
    SyntaxMemberExpression = 'MemberExpression',
    SyntaxObjectExpression = 'ObjectExpression',
    SyntaxProperty = 'Property',
    SyntaxUnaryExpression = 'UnaryExpression'; // Error messages should be identical to V8.

var MessageUnexpectedToken = 'Unexpected token %0',
    MessageUnexpectedNumber = 'Unexpected number',
    MessageUnexpectedString = 'Unexpected string',
    MessageUnexpectedIdentifier = 'Unexpected identifier',
    MessageUnexpectedReserved = 'Unexpected reserved word',
    MessageUnexpectedEOS = 'Unexpected end of input',
    MessageInvalidRegExp = 'Invalid regular expression',
    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',
    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',
    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';
var ILLEGAL = 'ILLEGAL',
    DISABLED = 'Disabled.'; // See also tools/generate-unicode-regex.py.

var RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),
    // eslint-disable-next-line no-misleading-character-class
RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'); // Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
  /* istanbul ignore next */
  if (!condition) {
    throw new Error('ASSERT: ' + message);
  }
}

function isDecimalDigit(ch) {
  return ch >= 0x30 && ch <= 0x39; // 0..9
}

function isHexDigit(ch) {
  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
}

function isOctalDigit(ch) {
  return '01234567'.indexOf(ch) >= 0;
} // 7.2 White Space


function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
} // 7.3 Line Terminators


function isLineTerminator(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
} // 7.6 Identifier Names and Identifiers


function isIdentifierStart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}

function isIdentifierPart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch >= 0x30 && ch <= 0x39 || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
} // 7.6.1.1 Keywords


const keywords = {
  'if': 1,
  'in': 1,
  'do': 1,
  'var': 1,
  'for': 1,
  'new': 1,
  'try': 1,
  'let': 1,
  'this': 1,
  'else': 1,
  'case': 1,
  'void': 1,
  'with': 1,
  'enum': 1,
  'while': 1,
  'break': 1,
  'catch': 1,
  'throw': 1,
  'const': 1,
  'yield': 1,
  'class': 1,
  'super': 1,
  'return': 1,
  'typeof': 1,
  'delete': 1,
  'switch': 1,
  'export': 1,
  'import': 1,
  'public': 1,
  'static': 1,
  'default': 1,
  'finally': 1,
  'extends': 1,
  'package': 1,
  'private': 1,
  'function': 1,
  'continue': 1,
  'debugger': 1,
  'interface': 1,
  'protected': 1,
  'instanceof': 1,
  'implements': 1
};

function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);

    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}

function scanHexEscape(prefix) {
  var i,
      len,
      ch,
      code = 0;
  len = prefix === 'u' ? 4 : 2;

  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  return String.fromCharCode(code);
}

function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0; // At least, one hex digit is required.

  if (ch === '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  while (index < length) {
    ch = source[index++];

    if (!isHexDigit(ch)) {
      break;
    }

    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
  }

  if (code > 0x10FFFF || ch !== '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // UTF-16 Encoding


  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  cu1 = (code - 0x10000 >> 10) + 0xD800;
  cu2 = (code - 0x10000 & 1023) + 0xDC00;
  return String.fromCharCode(cu1, cu2);
}

function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

  if (ch === 0x5C) {
    if (source.charCodeAt(index) !== 0x75) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    ++index;
    ch = scanHexEscape('u');

    if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    id = ch;
  }

  while (index < length) {
    ch = source.charCodeAt(index);

    if (!isIdentifierPart(ch)) {
      break;
    }

    ++index;
    id += String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

    if (ch === 0x5C) {
      id = id.substr(0, id.length - 1);

      if (source.charCodeAt(index) !== 0x75) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      ++index;
      ch = scanHexEscape('u');

      if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      id += ch;
    }
  }

  return id;
}

function getIdentifier() {
  var start, ch;
  start = index++;

  while (index < length) {
    ch = source.charCodeAt(index);

    if (ch === 0x5C) {
      // Blackslash (U+005C) marks Unicode escape sequence.
      index = start;
      return getEscapedIdentifier();
    }

    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }

  return source.slice(start, index);
}

function scanIdentifier() {
  var start, id, type;
  start = index; // Backslash (U+005C) starts an escaped character.

  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.
  // Thus, it must be an identifier.

  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    // eslint-disable-line no-prototype-builtins
    type = TokenKeyword;
  } else if (id === 'null') {
    type = TokenNullLiteral;
  } else if (id === 'true' || id === 'false') {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }

  return {
    type: type,
    value: id,
    start: start,
    end: index
  };
} // 7.7 Punctuators


function scanPunctuator() {
  var start = index,
      code = source.charCodeAt(index),
      code2,
      ch1 = source[index],
      ch2,
      ch3,
      ch4;

  switch (code) {
    // Check for most common single-character punctuators.
    case 0x2E: // . dot

    case 0x28: // ( open bracket

    case 0x29: // ) close bracket

    case 0x3B: // ; semicolon

    case 0x2C: // , comma

    case 0x7B: // { open curly brace

    case 0x7D: // } close curly brace

    case 0x5B: // [

    case 0x5D: // ]

    case 0x3A: // :

    case 0x3F: // ?

    case 0x7E:
      // ~
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start: start,
        end: index
      };

    default:
      code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.

      if (code2 === 0x3D) {
        switch (code) {
          case 0x2B: // +

          case 0x2D: // -

          case 0x2F: // /

          case 0x3C: // <

          case 0x3E: // >

          case 0x5E: // ^

          case 0x7C: // |

          case 0x25: // %

          case 0x26: // &

          case 0x2A:
            // *
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start: start,
              end: index
            };

          case 0x21: // !

          case 0x3D:
            // =
            index += 2; // !== and ===

            if (source.charCodeAt(index) === 0x3D) {
              ++index;
            }

            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start: start,
              end: index
            };
        }
      }

  } // 4-character punctuator: >>>=


  ch4 = source.substr(index, 4);

  if (ch4 === '>>>=') {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start: start,
      end: index
    };
  } // 3-character punctuators: === !== >>> <<= >>=


  ch3 = ch4.substr(0, 3);

  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start: start,
      end: index
    };
  } // Other 2-character punctuators: ++ -- << >> && ||


  ch2 = ch3.substr(0, 2);

  if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start: start,
      end: index
    };
  }

  if (ch2 === '//') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // 1-character punctuators: < > = ! + - * % & | ^ /


  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start: start,
      end: index
    };
  }

  throwError({}, MessageUnexpectedToken, ILLEGAL);
} // 7.8.3 Numeric Literals


function scanHexLiteral(start) {
  let number = '';

  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt('0x' + number, 16),
    start: start,
    end: index
  };
}

function scanOctalLiteral(start) {
  let number = '0' + source[index++];

  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start: start,
    end: index
  };
}

function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
  start = index;
  number = '';

  if (ch !== '.') {
    number = source[index++];
    ch = source[index]; // Hex number starts with '0x'.
    // Octal number starts with '0'.

    if (number === '0') {
      if (ch === 'x' || ch === 'X') {
        ++index;
        return scanHexLiteral(start);
      }

      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      } // decimal number starts with '0' such as '09' is illegal.


      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === '.') {
    number += source[index++];

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === 'e' || ch === 'E') {
    number += source[index++];
    ch = source[index];

    if (ch === '+' || ch === '-') {
      number += source[index++];
    }

    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start: start,
    end: index
  };
} // 7.8.4 String Literals


function scanStringLiteral() {
  var str = '',
      quote,
      start,
      ch,
      code,
      octal = false;
  quote = source[index];
  assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
  start = index;
  ++index;

  while (index < length) {
    ch = source[index++];

    if (ch === quote) {
      quote = '';
      break;
    } else if (ch === '\\') {
      ch = source[index++];

      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case 'u':
          case 'x':
            if (source[index] === '{') {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }

            break;

          case 'n':
            str += '\n';
            break;

          case 'r':
            str += '\r';
            break;

          case 't':
            str += '\t';
            break;

          case 'b':
            str += '\b';
            break;

          case 'f':
            str += '\f';
            break;

          case 'v':
            str += '\x0B';
            break;

          default:
            if (isOctalDigit(ch)) {
              code = '01234567'.indexOf(ch); // \0 is not octal escape sequence

              if (code !== 0) {
                octal = true;
              }

              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3

                if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + '01234567'.indexOf(source[index++]);
                }
              }

              str += String.fromCharCode(code);
            } else {
              str += ch;
            }

            break;
        }
      } else {
        if (ch === '\r' && source[index] === '\n') {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }

  if (quote !== '') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenStringLiteral,
    value: str,
    octal: octal,
    start: start,
    end: index
  };
}

function testRegExp(pattern, flags) {
  let tmp = pattern;

  if (flags.indexOf('u') >= 0) {
    // Replace each astral symbol and every Unicode code point
    // escape sequence with a single ASCII symbol to avoid throwing on
    // regular expressions that are only valid in combination with the
    // `/u` flag.
    // Note: replacing with the ASCII symbol `x` might cause false
    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
    // perfectly valid pattern that is equivalent to `[a-b]`, but it
    // would be replaced by `[x-b]` which throws an error.
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 0x10FFFF) {
        return 'x';
      }

      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
  } // First, detect invalid regular expressions.


  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  } // Return a regular expression object for this pattern-flag pair, or
  // `null` in case the current environment doesn't support the flags it
  // uses.


  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}

function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === '/', 'Regular expression literal must start with a slash');
  str = source[index++];
  classMarker = false;
  terminated = false;

  while (index < length) {
    ch = source[index++];
    str += ch;

    if (ch === '\\') {
      ch = source[index++]; // ECMA-262 7.8.5

      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }

      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === ']') {
        classMarker = false;
      }
    } else {
      if (ch === '/') {
        terminated = true;
        break;
      } else if (ch === '[') {
        classMarker = true;
      }
    }
  }

  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  } // Exclude leading and trailing slash.


  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}

function scanRegExpFlags() {
  var ch, str, flags;
  str = '';
  flags = '';

  while (index < length) {
    ch = source[index];

    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }

    ++index;

    if (ch === '\\' && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch;
      str += ch;
    }
  }

  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }

  return {
    value: flags,
    literal: str
  };
}

function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start: start,
    end: index
  };
}

function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}

function advance() {
  skipComment();

  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }

  const ch = source.charCodeAt(index);

  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  } // Very common: ( and ) and ;


  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
    return scanPunctuator();
  } // String literal starts with single quote (U+0027) or double quote (U+0022).


  if (ch === 0x27 || ch === 0x22) {
    return scanStringLiteral();
  } // Dot (.) U+002E can also start a floating-point number, hence the need
  // to check the next character.


  if (ch === 0x2E) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }

    return scanPunctuator();
  }

  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }

  return scanPunctuator();
}

function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}

function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}

function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}

function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}

function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}

function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}

function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}

function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);

  if (token.regex) {
    if (node.raw === '//') {
      node.raw = '/(?:)/';
    }

    node.regex = token.regex;
  }

  return node;
}

function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === '[';
  node.object = object;
  node.property = property;
  if (!node.computed) property.member = true;
  return node;
}

function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}

function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}

function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
} // Throw an exception


function throwError(token, messageFormat) {
  var error,
      args = Array.prototype.slice.call(arguments, 2),
      msg = messageFormat.replace(/%(\d)/g, (whole, index) => {
    assert(index < args.length, 'Message reference must be in range');
    return args[index];
  });
  error = new Error(msg);
  error.index = index;
  error.description = msg;
  throw error;
} // Throw an exception because of the token.


function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }

  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }

  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }

  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }

  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  } // BooleanLiteral, NullLiteral, or Punctuator.


  throwError(token, MessageUnexpectedToken, token.value);
} // Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.


function expect(value) {
  const token = lex();

  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
} // Return true if the next token matches the specified punctuator.


function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
} // Return true if the next token matches the specified keyword


function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
} // 11.1.4 Array Initialiser


function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect('[');

  while (!match(']')) {
    if (match(',')) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());

      if (!match(']')) {
        expect(',');
      }
    }
  }

  lex();
  return finishArrayExpression(elements);
} // 11.1.5 Object Initialiser


function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex(); // Note: This function is called only from parseObjectProperty(), where
  // EOF and Punctuator tokens are already filtered out.

  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }

    return finishLiteral(token);
  }

  return finishIdentifier(token.value);
}

function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;

  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', id, value);
  }

  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', key, value);
  }
}

function parseObjectInitialiser() {
  var properties = [],
      property,
      name,
      key,
      map = {},
      toString = String;
  index = lookahead.start;
  expect('{');

  while (!match('}')) {
    property = parseObjectProperty();

    if (property.key.type === SyntaxIdentifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }

    key = '$' + name;

    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }

    properties.push(property);

    if (!match('}')) {
      expect(',');
    }
  }

  expect('}');
  return finishObjectExpression(properties);
} // 11.1.6 The Grouping Operator


function parseGroupExpression() {
  expect('(');
  const expr = parseExpression();
  expect(')');
  return expr;
} // 11.1 Primary Expressions


const legalKeywords = {
  'if': 1
};

function parsePrimaryExpression() {
  var type, token, expr;

  if (match('(')) {
    return parseGroupExpression();
  }

  if (match('[')) {
    return parseArrayInitialiser();
  }

  if (match('{')) {
    return parseObjectInitialiser();
  }

  type = lookahead.type;
  index = lookahead.start;

  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }

    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === 'true';
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match('/') || match('/=')) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }

  return expr;
} // 11.2 Left-Hand-Side Expressions


function parseArguments() {
  const args = [];
  expect('(');

  if (!match(')')) {
    while (index < length) {
      args.push(parseConditionalExpression());

      if (match(')')) {
        break;
      }

      expect(',');
    }
  }

  expect(')');
  return args;
}

function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();

  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }

  return finishIdentifier(token.value);
}

function parseNonComputedMember() {
  expect('.');
  return parseNonComputedProperty();
}

function parseComputedMember() {
  expect('[');
  const expr = parseExpression();
  expect(']');
  return expr;
}

function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();

  for (;;) {
    if (match('.')) {
      property = parseNonComputedMember();
      expr = finishMemberExpression('.', expr, property);
    } else if (match('(')) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match('[')) {
      property = parseComputedMember();
      expr = finishMemberExpression('[', expr, property);
    } else {
      break;
    }
  }

  return expr;
} // 11.3 Postfix Expressions


function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();

  if (lookahead.type === TokenPunctuator) {
    if (match('++') || match('--')) {
      throw new Error(DISABLED);
    }
  }

  return expr;
} // 11.4 Unary Operators


function parseUnaryExpression() {
  var token, expr;

  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match('++') || match('--')) {
    throw new Error(DISABLED);
  } else if (match('+') || match('-') || match('~') || match('!')) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }

  return expr;
}

function binaryPrecedence(token) {
  let prec = 0;

  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }

  switch (token.value) {
    case '||':
      prec = 1;
      break;

    case '&&':
      prec = 2;
      break;

    case '|':
      prec = 3;
      break;

    case '^':
      prec = 4;
      break;

    case '&':
      prec = 5;
      break;

    case '==':
    case '!=':
    case '===':
    case '!==':
      prec = 6;
      break;

    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      prec = 7;
      break;

    case '<<':
    case '>>':
    case '>>>':
      prec = 8;
      break;

    case '+':
    case '-':
      prec = 9;
      break;

    case '*':
    case '/':
    case '%':
      prec = 11;
      break;
  }

  return prec;
} // 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators


function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);

  if (prec === 0) {
    return left;
  }

  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];

  while ((prec = binaryPrecedence(lookahead)) > 0) {
    // Reduce: make a binary expression from the three topmost entries.
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack.push(expr);
    } // Shift.


    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  } // Final reduce to clean-up the stack.


  i = stack.length - 1;
  expr = stack[i];
  markers.pop();

  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
  }

  return expr;
} // 11.12 Conditional Operator


function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();

  if (match('?')) {
    lex();
    consequent = parseConditionalExpression();
    expect(':');
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }

  return expr;
} // 11.14 Comma Operator


function parseExpression() {
  const expr = parseConditionalExpression();

  if (match(',')) {
    throw new Error(DISABLED); // no sequence expressions
  }

  return expr;
}

function parser (code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();

  if (lookahead.type !== TokenEOF) {
    throw new Error('Unexpect token after expression.');
  }

  return expr;
}

var Constants = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE'
};

function Functions (codegen) {
  function fncall(name, args, cast, type) {
    let obj = codegen(args[0]);

    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }

    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return args => fncall(name, args, cast, type);
  }

  const DATE = 'new Date',
        STRING = 'String',
        REGEXP = 'RegExp';
  return {
    // MATH functions
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to clamp function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to clamp function.');
      const a = args.map(codegen);
      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';
    },
    // DATE functions
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: DATE,
    date: fn('getDate', DATE, 0),
    day: fn('getDay', DATE, 0),
    year: fn('getFullYear', DATE, 0),
    month: fn('getMonth', DATE, 0),
    hours: fn('getHours', DATE, 0),
    minutes: fn('getMinutes', DATE, 0),
    seconds: fn('getSeconds', DATE, 0),
    milliseconds: fn('getMilliseconds', DATE, 0),
    time: fn('getTime', DATE, 0),
    timezoneoffset: fn('getTimezoneOffset', DATE, 0),
    utcdate: fn('getUTCDate', DATE, 0),
    utcday: fn('getUTCDay', DATE, 0),
    utcyear: fn('getUTCFullYear', DATE, 0),
    utcmonth: fn('getUTCMonth', DATE, 0),
    utchours: fn('getUTCHours', DATE, 0),
    utcminutes: fn('getUTCMinutes', DATE, 0),
    utcseconds: fn('getUTCSeconds', DATE, 0),
    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),
    // sequence functions
    length: fn('length', null, -1),
    // STRING functions
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: fn('toUpperCase', STRING, 0),
    lower: fn('toLowerCase', STRING, 0),
    substring: fn('substring', STRING),
    split: fn('split', STRING),
    trim: fn('trim', STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn('test', REGEXP),
    // Control Flow functions
    if: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to if function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to if function.');
      const a = args.map(codegen);
      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';
    }
  };
}

function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === '\'' && s[n] === '\'') ? s.slice(1, -1) : s;
}

function codegen (opt) {
  opt = opt || {};
  const allowed = opt.allowed ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.allowed) : {},
        forbidden = opt.forbidden ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.forbidden) : {},
        constants = opt.constants || Constants,
        functions = (opt.functions || Functions)(visit),
        globalvar = opt.globalvar,
        fieldvar = opt.fieldvar,
        outputGlobal = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(globalvar) ? globalvar : id => `${globalvar}["${id}"]`;
  let globals = {},
      fields = {},
      memberDepth = 0;

  function visit(ast) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported type: ' + ast.type);
    return generator(ast);
  }

  const Generators = {
    Literal: n => n.raw,
    Identifier: n => {
      const id = n.name;

      if (memberDepth > 0) {
        return id;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(forbidden, id)) {
        return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal identifier: ' + id);
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(constants, id)) {
        return constants[id];
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(allowed, id)) {
        return id;
      } else {
        globals[id] = 1;
        return outputGlobal(id);
      }
    },
    MemberExpression: n => {
      const d = !n.computed,
            o = visit(n.object);
      if (d) memberDepth += 1;
      const p = visit(n.property);

      if (o === fieldvar) {
        // strip quotes to sanitize field name (#1653)
        fields[stripQuotes(p)] = 1;
      }

      if (d) memberDepth -= 1;
      return o + (d ? '.' + p : '[' + p + ']');
    },
    CallExpression: n => {
      if (n.callee.type !== 'Identifier') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal callee type: ' + n.callee.type);
      }

      const callee = n.callee.name,
            args = n.arguments,
            fn = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(functions, callee) && functions[callee];
      if (!fn) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized function: ' + callee);
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';
    },
    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',
    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',
    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',
    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',
    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',
    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',
    Property: n => {
      memberDepth += 1;
      const k = visit(n.key);
      memberDepth -= 1;
      return k + ':' + visit(n.value);
    }
  };

  function codegen(ast) {
    const result = {
      code: visit(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }

  codegen.functions = functions;
  codegen.constants = constants;
  return codegen;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYS1ldmVudC1zZWxlY3Rvcl9idWlsZF92ZWdhLWV2ZW50LXNlbGVjdG9yX21vZHVsZV9qcy1ub2RlX21vZHVsZXNfdmVnLWI3Njk1NS4xNjM5MjRhNjJiMmJiNjI1YTkyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBLDBDQUEwQyxxREFBcUQ7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hOcUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLCt3TEFBK3dMO0FBQy93TDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0I7O0FBRXBCOztBQUVBLG9CQUFvQjs7QUFFcEIsb0JBQW9COztBQUVwQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEdBQUc7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0wsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSixpQkFBaUI7QUFDakIsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFLO0FBQ2hDLDJCQUEyQixnREFBSztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFLO0FBQ2hDLDJCQUEyQixnREFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQUssa0JBQWtCO0FBQ3ZELG9DQUFvQyxnREFBSyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQVUsbUNBQW1DLFVBQVUsSUFBSSxHQUFHO0FBQ3JGLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsMkJBQTJCLGdEQUFLO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsU0FBUyx5REFBYztBQUMvQixlQUFlLGdEQUFLO0FBQ3BCLFFBQVEsU0FBUyx5REFBYztBQUMvQjtBQUNBLFFBQVEsU0FBUyx5REFBYztBQUMvQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix5REFBYztBQUMvQixlQUFlLGdEQUFLO0FBQ3BCLGFBQWEscURBQVU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVzVCIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1ldmVudC1zZWxlY3Rvci9idWlsZC92ZWdhLWV2ZW50LXNlbGVjdG9yLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9idWlsZC92ZWdhLWV4cHJlc3Npb24ubW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZJRVcgPSAndmlldycsXG4gICAgICBMQlJBQ0sgPSAnWycsXG4gICAgICBSQlJBQ0sgPSAnXScsXG4gICAgICBMQlJBQ0UgPSAneycsXG4gICAgICBSQlJBQ0UgPSAnfScsXG4gICAgICBDT0xPTiA9ICc6JyxcbiAgICAgIENPTU1BID0gJywnLFxuICAgICAgTkFNRSA9ICdAJyxcbiAgICAgIEdUID0gJz4nLFxuICAgICAgSUxMRUdBTCA9IC9bW1xcXXt9XS8sXG4gICAgICBERUZBVUxUX01BUktTID0ge1xuICAnKic6IDEsXG4gIGFyYzogMSxcbiAgYXJlYTogMSxcbiAgZ3JvdXA6IDEsXG4gIGltYWdlOiAxLFxuICBsaW5lOiAxLFxuICBwYXRoOiAxLFxuICByZWN0OiAxLFxuICBydWxlOiAxLFxuICBzaGFwZTogMSxcbiAgc3ltYm9sOiAxLFxuICB0ZXh0OiAxLFxuICB0cmFpbDogMVxufTtcbmxldCBERUZBVUxUX1NPVVJDRSwgTUFSS1M7XG4vKipcbiAqIFBhcnNlIGFuIGV2ZW50IHNlbGVjdG9yIHN0cmluZy5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZXZlbnQgc3RyZWFtIGRlZmluaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGV2ZW50U2VsZWN0b3IgKHNlbGVjdG9yLCBzb3VyY2UsIG1hcmtzKSB7XG4gIERFRkFVTFRfU09VUkNFID0gc291cmNlIHx8IFZJRVc7XG4gIE1BUktTID0gbWFya3MgfHwgREVGQVVMVF9NQVJLUztcbiAgcmV0dXJuIHBhcnNlTWVyZ2Uoc2VsZWN0b3IudHJpbSgpKS5tYXAocGFyc2VTZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGlzTWFya1R5cGUodHlwZSkge1xuICByZXR1cm4gTUFSS1NbdHlwZV07XG59XG5cbmZ1bmN0aW9uIGZpbmQocywgaSwgZW5kQ2hhciwgcHVzaENoYXIsIHBvcENoYXIpIHtcbiAgY29uc3QgbiA9IHMubGVuZ3RoO1xuICBsZXQgY291bnQgPSAwLFxuICAgICAgYztcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGMgPSBzW2ldO1xuICAgIGlmICghY291bnQgJiYgYyA9PT0gZW5kQ2hhcikgcmV0dXJuIGk7ZWxzZSBpZiAocG9wQ2hhciAmJiBwb3BDaGFyLmluZGV4T2YoYykgPj0gMCkgLS1jb3VudDtlbHNlIGlmIChwdXNoQ2hhciAmJiBwdXNoQ2hhci5pbmRleE9mKGMpID49IDApICsrY291bnQ7XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNZXJnZShzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdLFxuICAgICAgICBuID0gcy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDAsXG4gICAgICBpID0gMDtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBDT01NQSwgTEJSQUNLICsgTEJSQUNFLCBSQlJBQ0sgKyBSQlJBQ0UpO1xuICAgIG91dHB1dC5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAnRW1wdHkgZXZlbnQgc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzWzBdID09PSAnWycgPyBwYXJzZUJldHdlZW4ocykgOiBwYXJzZVN0cmVhbShzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHMpIHtcbiAgY29uc3QgbiA9IHMubGVuZ3RoO1xuICBsZXQgaSA9IDEsXG4gICAgICBiO1xuICBpID0gZmluZChzLCBpLCBSQlJBQ0ssIExCUkFDSywgUkJSQUNLKTtcblxuICBpZiAoaSA9PT0gbikge1xuICAgIHRocm93ICdFbXB0eSBiZXR3ZWVuIHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIGIgPSBwYXJzZU1lcmdlKHMuc3Vic3RyaW5nKDEsIGkpKTtcblxuICBpZiAoYi5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyAnQmV0d2VlbiBzZWxlY3RvciBtdXN0IGhhdmUgdHdvIGVsZW1lbnRzOiAnICsgcztcbiAgfVxuXG4gIHMgPSBzLnNsaWNlKGkgKyAxKS50cmltKCk7XG5cbiAgaWYgKHNbMF0gIT09IEdUKSB7XG4gICAgdGhyb3cgJ0V4cGVjdGVkIFxcJz5cXCcgYWZ0ZXIgYmV0d2VlbiBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBiID0gYi5tYXAocGFyc2VTZWxlY3Rvcik7XG4gIGNvbnN0IHN0cmVhbSA9IHBhcnNlU2VsZWN0b3Iocy5zbGljZSgxKS50cmltKCkpO1xuXG4gIGlmIChzdHJlYW0uYmV0d2Vlbikge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBiLFxuICAgICAgc3RyZWFtOiBzdHJlYW1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5iZXR3ZWVuID0gYjtcbiAgfVxuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtKHMpIHtcbiAgY29uc3Qgc3RyZWFtID0ge1xuICAgIHNvdXJjZTogREVGQVVMVF9TT1VSQ0VcbiAgfSxcbiAgICAgICAgc291cmNlID0gW107XG4gIGxldCB0aHJvdHRsZSA9IFswLCAwXSxcbiAgICAgIG1hcmtuYW1lID0gMCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIG4gPSBzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgaixcbiAgICAgIGZpbHRlcjsgLy8gZXh0cmFjdCB0aHJvdHRsZSBmcm9tIGVuZFxuXG4gIGlmIChzW24gLSAxXSA9PT0gUkJSQUNFKSB7XG4gICAgaSA9IHMubGFzdEluZGV4T2YoTEJSQUNFKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm90dGxlID0gcGFyc2VUaHJvdHRsZShzLnN1YnN0cmluZyhpICsgMSwgbiAtIDEpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgdGhyb3R0bGUgc3BlY2lmaWNhdGlvbjogJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHMgPSBzLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIG4gPSBzLmxlbmd0aDtcbiAgICB9IGVsc2UgdGhyb3cgJ1VubWF0Y2hlZCByaWdodCBicmFjZTogJyArIHM7XG5cbiAgICBpID0gMDtcbiAgfVxuXG4gIGlmICghbikgdGhyb3cgczsgLy8gc2V0IG5hbWUgZmxhZyBiYXNlZCBvbiBmaXJzdCBjaGFyXG5cbiAgaWYgKHNbMF0gPT09IE5BTUUpIG1hcmtuYW1lID0gKytpOyAvLyBleHRyYWN0IGZpcnN0IHBhcnQgb2YgbXVsdGktcGFydCBzdHJlYW0gc2VsZWN0b3JcblxuICBqID0gZmluZChzLCBpLCBDT0xPTik7XG5cbiAgaWYgKGogPCBuKSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGopLnRyaW0oKSk7XG4gICAgc3RhcnQgPSBpID0gKytqO1xuICB9IC8vIGV4dHJhY3QgcmVtYWluaW5nIHBhcnQgb2Ygc3RyZWFtIHNlbGVjdG9yXG5cblxuICBpID0gZmluZChzLCBpLCBMQlJBQ0spO1xuXG4gIGlmIChpID09PSBuKSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIG4pLnRyaW0oKSk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGkpLnRyaW0oKSk7XG4gICAgZmlsdGVyID0gW107XG4gICAgc3RhcnQgPSArK2k7XG4gICAgaWYgKHN0YXJ0ID09PSBuKSB0aHJvdyAnVW5tYXRjaGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gIH0gLy8gZXh0cmFjdCBmaWx0ZXJzXG5cblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBSQlJBQ0spO1xuICAgIGlmIChpID09PSBuKSB0aHJvdyAnVW5tYXRjaGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgZmlsdGVyLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGkpLnRyaW0oKSk7XG4gICAgaWYgKGkgPCBuIC0gMSAmJiBzWysraV0gIT09IExCUkFDSykgdGhyb3cgJ0V4cGVjdGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgc3RhcnQgPSArK2k7XG4gIH0gLy8gbWFyc2hhbGwgZXZlbnQgc3RyZWFtIHNwZWNpZmljYXRpb25cblxuXG4gIGlmICghKG4gPSBzb3VyY2UubGVuZ3RoKSB8fCBJTExFR0FMLnRlc3Qoc291cmNlW24gLSAxXSkpIHtcbiAgICB0aHJvdyAnSW52YWxpZCBldmVudCBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBpZiAobiA+IDEpIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVsxXTtcblxuICAgIGlmIChtYXJrbmFtZSkge1xuICAgICAgc3RyZWFtLm1hcmtuYW1lID0gc291cmNlWzBdLnNsaWNlKDEpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXJrVHlwZShzb3VyY2VbMF0pKSB7XG4gICAgICBzdHJlYW0ubWFya3R5cGUgPSBzb3VyY2VbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5zb3VyY2UgPSBzb3VyY2VbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS50eXBlID0gc291cmNlWzBdO1xuICB9XG5cbiAgaWYgKHN0cmVhbS50eXBlLnNsaWNlKC0xKSA9PT0gJyEnKSB7XG4gICAgc3RyZWFtLmNvbnN1bWUgPSB0cnVlO1xuICAgIHN0cmVhbS50eXBlID0gc3RyZWFtLnR5cGUuc2xpY2UoMCwgLTEpO1xuICB9XG5cbiAgaWYgKGZpbHRlciAhPSBudWxsKSBzdHJlYW0uZmlsdGVyID0gZmlsdGVyO1xuICBpZiAodGhyb3R0bGVbMF0pIHN0cmVhbS50aHJvdHRsZSA9IHRocm90dGxlWzBdO1xuICBpZiAodGhyb3R0bGVbMV0pIHN0cmVhbS5kZWJvdW5jZSA9IHRocm90dGxlWzFdO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRocm90dGxlKHMpIHtcbiAgY29uc3QgYSA9IHMuc3BsaXQoQ09NTUEpO1xuICBpZiAoIXMubGVuZ3RoIHx8IGEubGVuZ3RoID4gMikgdGhyb3cgcztcbiAgcmV0dXJuIGEubWFwKF8gPT4ge1xuICAgIGNvbnN0IHggPSArXztcbiAgICBpZiAoeCAhPT0geCkgdGhyb3cgcztcbiAgICByZXR1cm4geDtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGV2ZW50U2VsZWN0b3IgYXMgcGFyc2VTZWxlY3RvciB9O1xuIiwiaW1wb3J0IHsgZXJyb3IsIHRvU2V0LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaGFzT3duUHJvcGVydHkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBSYXdDb2RlID0gJ1Jhd0NvZGUnO1xuY29uc3QgTGl0ZXJhbCA9ICdMaXRlcmFsJztcbmNvbnN0IFByb3BlcnR5ID0gJ1Byb3BlcnR5JztcbmNvbnN0IElkZW50aWZpZXIgPSAnSWRlbnRpZmllcic7XG5jb25zdCBBcnJheUV4cHJlc3Npb24gPSAnQXJyYXlFeHByZXNzaW9uJztcbmNvbnN0IEJpbmFyeUV4cHJlc3Npb24gPSAnQmluYXJ5RXhwcmVzc2lvbic7XG5jb25zdCBDYWxsRXhwcmVzc2lvbiA9ICdDYWxsRXhwcmVzc2lvbic7XG5jb25zdCBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJztcbmNvbnN0IExvZ2ljYWxFeHByZXNzaW9uID0gJ0xvZ2ljYWxFeHByZXNzaW9uJztcbmNvbnN0IE1lbWJlckV4cHJlc3Npb24gPSAnTWVtYmVyRXhwcmVzc2lvbic7XG5jb25zdCBPYmplY3RFeHByZXNzaW9uID0gJ09iamVjdEV4cHJlc3Npb24nO1xuY29uc3QgVW5hcnlFeHByZXNzaW9uID0gJ1VuYXJ5RXhwcmVzc2lvbic7XG5mdW5jdGlvbiBBU1ROb2RlKHR5cGUpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuQVNUTm9kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICBsZXQgYywgaSwgbjtcbiAgaWYgKHZpc2l0b3IodGhpcykpIHJldHVybiAxO1xuXG4gIGZvciAoYyA9IGNoaWxkcmVuKHRoaXMpLCBpID0gMCwgbiA9IGMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGNbaV0udmlzaXQodmlzaXRvcikpIHJldHVybiAxO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGlsZHJlbihub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBBcnJheUV4cHJlc3Npb246XG4gICAgICByZXR1cm4gbm9kZS5lbGVtZW50cztcblxuICAgIGNhc2UgQmluYXJ5RXhwcmVzc2lvbjpcbiAgICBjYXNlIExvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmxlZnQsIG5vZGUucmlnaHRdO1xuXG4gICAgY2FzZSBDYWxsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5jYWxsZWVdLmNvbmNhdChub2RlLmFyZ3VtZW50cyk7XG5cbiAgICBjYXNlIENvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS50ZXN0LCBub2RlLmNvbnNlcXVlbnQsIG5vZGUuYWx0ZXJuYXRlXTtcblxuICAgIGNhc2UgTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5vYmplY3QsIG5vZGUucHJvcGVydHldO1xuXG4gICAgY2FzZSBPYmplY3RFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcztcblxuICAgIGNhc2UgUHJvcGVydHk6XG4gICAgICByZXR1cm4gW25vZGUua2V5LCBub2RlLnZhbHVlXTtcblxuICAgIGNhc2UgVW5hcnlFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmFyZ3VtZW50XTtcblxuICAgIGNhc2UgSWRlbnRpZmllcjpcbiAgICBjYXNlIExpdGVyYWw6XG4gICAgY2FzZSBSYXdDb2RlOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG52YXIgVG9rZW5OYW1lLCBzb3VyY2UsIGluZGV4LCBsZW5ndGgsIGxvb2thaGVhZDtcbnZhciBUb2tlbkJvb2xlYW5MaXRlcmFsID0gMSxcbiAgICBUb2tlbkVPRiA9IDIsXG4gICAgVG9rZW5JZGVudGlmaWVyID0gMyxcbiAgICBUb2tlbktleXdvcmQgPSA0LFxuICAgIFRva2VuTnVsbExpdGVyYWwgPSA1LFxuICAgIFRva2VuTnVtZXJpY0xpdGVyYWwgPSA2LFxuICAgIFRva2VuUHVuY3R1YXRvciA9IDcsXG4gICAgVG9rZW5TdHJpbmdMaXRlcmFsID0gOCxcbiAgICBUb2tlblJlZ3VsYXJFeHByZXNzaW9uID0gOTtcblRva2VuTmFtZSA9IHt9O1xuVG9rZW5OYW1lW1Rva2VuQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuVG9rZW5OYW1lW1Rva2VuRU9GXSA9ICc8ZW5kPic7XG5Ub2tlbk5hbWVbVG9rZW5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcblRva2VuTmFtZVtUb2tlbktleXdvcmRdID0gJ0tleXdvcmQnO1xuVG9rZW5OYW1lW1Rva2VuTnVsbExpdGVyYWxdID0gJ051bGwnO1xuVG9rZW5OYW1lW1Rva2VuTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuVG9rZW5OYW1lW1Rva2VuUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG5Ub2tlbk5hbWVbVG9rZW5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuVG9rZW5OYW1lW1Rva2VuUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcbnZhciBTeW50YXhBcnJheUV4cHJlc3Npb24gPSAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICBTeW50YXhCaW5hcnlFeHByZXNzaW9uID0gJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgIFN5bnRheENhbGxFeHByZXNzaW9uID0gJ0NhbGxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhDb25kaXRpb25hbEV4cHJlc3Npb24gPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhJZGVudGlmaWVyID0gJ0lkZW50aWZpZXInLFxuICAgIFN5bnRheExpdGVyYWwgPSAnTGl0ZXJhbCcsXG4gICAgU3ludGF4TG9naWNhbEV4cHJlc3Npb24gPSAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgIFN5bnRheE1lbWJlckV4cHJlc3Npb24gPSAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgU3ludGF4T2JqZWN0RXhwcmVzc2lvbiA9ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICBTeW50YXhQcm9wZXJ0eSA9ICdQcm9wZXJ0eScsXG4gICAgU3ludGF4VW5hcnlFeHByZXNzaW9uID0gJ1VuYXJ5RXhwcmVzc2lvbic7IC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG5cbnZhciBNZXNzYWdlVW5leHBlY3RlZFRva2VuID0gJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkTnVtYmVyID0gJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZFN0cmluZyA9ICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRJZGVudGlmaWVyID0gJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRSZXNlcnZlZCA9ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkRU9TID0gJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICBNZXNzYWdlSW52YWxpZFJlZ0V4cCA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgTWVzc2FnZVVudGVybWluYXRlZFJlZ0V4cCA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgICBNZXNzYWdlU3RyaWN0T2N0YWxMaXRlcmFsID0gJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgIE1lc3NhZ2VTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSA9ICdEdXBsaWNhdGUgZGF0YSBwcm9wZXJ0eSBpbiBvYmplY3QgbGl0ZXJhbCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSc7XG52YXIgSUxMRUdBTCA9ICdJTExFR0FMJyxcbiAgICBESVNBQkxFRCA9ICdEaXNhYmxlZC4nOyAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuXG52YXIgUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoJ1tcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFBXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhBMC1cXFxcdTA4QjJcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5ODBcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNEXFxcXHUwRDRFXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDLVxcXFx1MEVERlxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4Q1xcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBDN1xcXFx1MTBDRFxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkMtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUFBN1xcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGMVxcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRUVcXFxcdTJDRjJcXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjlEXFxcXHVBNkEwLVxcXFx1QTZFRlxcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCLVxcXFx1QTc4RVxcXFx1QTc5MC1cXFxcdUE3QURcXFxcdUE3QjBcXFxcdUE3QjFcXFxcdUE3RjctXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE4RjItXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTg0LVxcXFx1QTlCMlxcXFx1QTlDRlxcXFx1QTlFMC1cXFxcdUE5RTRcXFxcdUE5RTYtXFxcXHVBOUVGXFxcXHVBOUZBLVxcXFx1QTlGRVxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUE2MC1cXFxcdUFBNzZcXFxcdUFBN0FcXFxcdUFBN0UtXFxcXHVBQUFGXFxcXHVBQUIxXFxcXHVBQUI1XFxcXHVBQUI2XFxcXHVBQUI5LVxcXFx1QUFCRFxcXFx1QUFDMFxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVBXFxcXHVBQUYyLVxcXFx1QUFGNFxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjRcXFxcdUFCNjVcXFxcdUFCQzAtXFxcXHVBQkUyXFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXScpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJQYXJ0ID0gbmV3IFJlZ0V4cCgnW1xcXFx4QUFcXFxceEI1XFxcXHhCQVxcXFx4QzAtXFxcXHhENlxcXFx4RDgtXFxcXHhGNlxcXFx4RjgtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzMDAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdBLVxcXFx1MDM3RFxcXFx1MDM3RlxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEUtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDYyMC1cXFxcdTA2NjlcXFxcdTA2NkUtXFxcXHUwNkQzXFxcXHUwNkQ1LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwLVxcXFx1MDc0QVxcXFx1MDc0RC1cXFxcdTA3QjFcXFxcdTA3QzAtXFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgyRFxcXFx1MDg0MC1cXFxcdTA4NUJcXFxcdTA4QTAtXFxcXHUwOEIyXFxcXHUwOEU0LVxcXFx1MDk2M1xcXFx1MDk2Ni1cXFxcdTA5NkZcXFxcdTA5NzEtXFxcXHUwOTgzXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCQy1cXFxcdTA5QzRcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0ItXFxcXHUwOUNFXFxcXHUwOUQ3XFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFM1xcXFx1MDlFNi1cXFxcdTA5RjFcXFxcdTBBMDEtXFxcXHUwQTAzXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTNDXFxcXHUwQTNFLVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTY2LVxcXFx1MEE3NVxcXFx1MEE4MS1cXFxcdTBBODNcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCQy1cXFxcdTBBQzVcXFxcdTBBQzctXFxcXHUwQUM5XFxcXHUwQUNCLVxcXFx1MEFDRFxcXFx1MEFEMFxcXFx1MEFFMC1cXFxcdTBBRTNcXFxcdTBBRTYtXFxcXHUwQUVGXFxcXHUwQjAxLVxcXFx1MEIwM1xcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0MtXFxcXHUwQjQ0XFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCLVxcXFx1MEI0RFxcXFx1MEI1NlxcXFx1MEI1N1xcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjNcXFxcdTBCNjYtXFxcXHUwQjZGXFxcXHUwQjcxXFxcXHUwQjgyXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCQkUtXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0RcXFxcdTBCRDBcXFxcdTBCRDdcXFxcdTBCRTYtXFxcXHUwQkVGXFxcXHUwQzAwLVxcXFx1MEMwM1xcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzlcXFxcdTBDM0QtXFxcXHUwQzQ0XFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjAtXFxcXHUwQzYzXFxcXHUwQzY2LVxcXFx1MEM2RlxcXFx1MEM4MS1cXFxcdTBDODNcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCQy1cXFxcdTBDQzRcXFxcdTBDQzYtXFxcXHUwQ0M4XFxcXHUwQ0NBLVxcXFx1MENDRFxcXFx1MENENVxcXFx1MENENlxcXFx1MENERVxcXFx1MENFMC1cXFxcdTBDRTNcXFxcdTBDRTYtXFxcXHUwQ0VGXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDAxLVxcXFx1MEQwM1xcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRC1cXFxcdTBENDRcXFxcdTBENDYtXFxcXHUwRDQ4XFxcXHUwRDRBLVxcXFx1MEQ0RVxcXFx1MEQ1N1xcXFx1MEQ2MC1cXFxcdTBENjNcXFxcdTBENjYtXFxcXHUwRDZGXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4MlxcXFx1MEQ4M1xcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBEQ0FcXFxcdTBEQ0YtXFxcXHUwREQ0XFxcXHUwREQ2XFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERFNi1cXFxcdTBERUZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBFMDEtXFxcXHUwRTNBXFxcXHUwRTQwLVxcXFx1MEU0RVxcXFx1MEU1MC1cXFxcdTBFNTlcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUI5XFxcXHUwRUJCLVxcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFQzZcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRUQwLVxcXFx1MEVEOVxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMjAtXFxcXHUwRjI5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjNFLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGNzEtXFxcXHUwRjg0XFxcXHUwRjg2LVxcXFx1MEY5N1xcXFx1MEY5OS1cXFxcdTBGQkNcXFxcdTBGQzZcXFxcdTEwMDAtXFxcXHUxMDQ5XFxcXHUxMDUwLVxcXFx1MTA5RFxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzNUQtXFxcXHUxMzVGXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjRcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3RlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNkVFLVxcXFx1MTZGOFxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzE0XFxcXHUxNzIwLVxcXFx1MTczNFxcXFx1MTc0MC1cXFxcdTE3NTNcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTc4MC1cXFxcdTE3RDNcXFxcdTE3RDdcXFxcdTE3RENcXFxcdTE3RERcXFxcdTE3RTAtXFxcXHUxN0U5XFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThBQVxcXFx1MThCMC1cXFxcdTE4RjVcXFxcdTE5MDAtXFxcXHUxOTFFXFxcXHUxOTIwLVxcXFx1MTkyQlxcXFx1MTkzMC1cXFxcdTE5M0JcXFxcdTE5NDYtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QjAtXFxcXHUxOUM5XFxcXHUxOUQwLVxcXFx1MTlEOVxcXFx1MUEwMC1cXFxcdTFBMUJcXFxcdTFBMjAtXFxcXHUxQTVFXFxcXHUxQTYwLVxcXFx1MUE3Q1xcXFx1MUE3Ri1cXFxcdTFBODlcXFxcdTFBOTAtXFxcXHUxQTk5XFxcXHUxQUE3XFxcXHUxQUIwLVxcXFx1MUFCRFxcXFx1MUIwMC1cXFxcdTFCNEJcXFxcdTFCNTAtXFxcXHUxQjU5XFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MC1cXFxcdTFCRjNcXFxcdTFDMDAtXFxcXHUxQzM3XFxcXHUxQzQwLVxcXFx1MUM0OVxcXFx1MUM0RC1cXFxcdTFDN0RcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNGNlxcXFx1MUNGOFxcXFx1MUNGOVxcXFx1MUQwMC1cXFxcdTFERjVcXFxcdTFERkMtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwMENcXFxcdTIwMERcXFxcdTIwM0ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkNGM1xcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMjdcXFxcdTJEMkRcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDZGXFxcXHUyRDdGLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDJGXFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDk5XFxcXHUzMDlBXFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkZcXFxcdUE2NzQtXFxcXHVBNjdEXFxcXHVBNjdGLVxcXFx1QTY5RFxcXFx1QTY5Ri1cXFxcdUE2RjFcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBN0FEXFxcXHVBN0IwXFxcXHVBN0IxXFxcXHVBN0Y3LVxcXFx1QTgyN1xcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODAtXFxcXHVBOEM0XFxcXHVBOEQwLVxcXFx1QThEOVxcXFx1QThFMC1cXFxcdUE4RjdcXFxcdUE4RkJcXFxcdUE5MDAtXFxcXHVBOTJEXFxcXHVBOTMwLVxcXFx1QTk1M1xcXFx1QTk2MC1cXFxcdUE5N0NcXFxcdUE5ODAtXFxcXHVBOUMwXFxcXHVBOUNGLVxcXFx1QTlEOVxcXFx1QTlFMC1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTM2XFxcXHVBQTQwLVxcXFx1QUE0RFxcXFx1QUE1MC1cXFxcdUFBNTlcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBLVxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVGXFxcXHVBQUYyLVxcXFx1QUFGNlxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjRcXFxcdUFCNjVcXFxcdUFCQzAtXFxcXHVBQkVBXFxcXHVBQkVDXFxcXHVBQkVEXFxcXHVBQkYwLVxcXFx1QUJGOVxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMUQtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTJEXFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjEwLVxcXFx1RkYxOVxcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGM0ZcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdJyk7IC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbi8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4vLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5OyAvLyAwLi45XG59XG5cbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbn0gLy8gNy4yIFdoaXRlIFNwYWNlXG5cblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyMCB8fCBjaCA9PT0gMHgwOSB8fCBjaCA9PT0gMHgwQiB8fCBjaCA9PT0gMHgwQyB8fCBjaCA9PT0gMHhBMCB8fCBjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwO1xufSAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG5cbmZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAweDBBIHx8IGNoID09PSAweDBEIHx8IGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOTtcbn0gLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAweDI0IHx8IGNoID09PSAweDVGIHx8IGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSB8fCBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgY2ggPT09IDB4NUMgfHwgY2ggPj0gMHg4MCAmJiBSZWdleE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fCBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSB8fCBjaCA9PT0gMHg1QyB8fCBjaCA+PSAweDgwICYmIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbn0gLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG5cbmNvbnN0IGtleXdvcmRzID0ge1xuICAnaWYnOiAxLFxuICAnaW4nOiAxLFxuICAnZG8nOiAxLFxuICAndmFyJzogMSxcbiAgJ2Zvcic6IDEsXG4gICduZXcnOiAxLFxuICAndHJ5JzogMSxcbiAgJ2xldCc6IDEsXG4gICd0aGlzJzogMSxcbiAgJ2Vsc2UnOiAxLFxuICAnY2FzZSc6IDEsXG4gICd2b2lkJzogMSxcbiAgJ3dpdGgnOiAxLFxuICAnZW51bSc6IDEsXG4gICd3aGlsZSc6IDEsXG4gICdicmVhayc6IDEsXG4gICdjYXRjaCc6IDEsXG4gICd0aHJvdyc6IDEsXG4gICdjb25zdCc6IDEsXG4gICd5aWVsZCc6IDEsXG4gICdjbGFzcyc6IDEsXG4gICdzdXBlcic6IDEsXG4gICdyZXR1cm4nOiAxLFxuICAndHlwZW9mJzogMSxcbiAgJ2RlbGV0ZSc6IDEsXG4gICdzd2l0Y2gnOiAxLFxuICAnZXhwb3J0JzogMSxcbiAgJ2ltcG9ydCc6IDEsXG4gICdwdWJsaWMnOiAxLFxuICAnc3RhdGljJzogMSxcbiAgJ2RlZmF1bHQnOiAxLFxuICAnZmluYWxseSc6IDEsXG4gICdleHRlbmRzJzogMSxcbiAgJ3BhY2thZ2UnOiAxLFxuICAncHJpdmF0ZSc6IDEsXG4gICdmdW5jdGlvbic6IDEsXG4gICdjb250aW51ZSc6IDEsXG4gICdkZWJ1Z2dlcic6IDEsXG4gICdpbnRlcmZhY2UnOiAxLFxuICAncHJvdGVjdGVkJzogMSxcbiAgJ2luc3RhbmNlb2YnOiAxLFxuICAnaW1wbGVtZW50cyc6IDFcbn07XG5cbmZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb25zdCBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChpc1doaXRlU3BhY2UoY2gpIHx8IGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICArK2luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgdmFyIGksXG4gICAgICBsZW4sXG4gICAgICBjaCxcbiAgICAgIGNvZGUgPSAwO1xuICBsZW4gPSBwcmVmaXggPT09ICd1JyA/IDQgOiAyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5cbmZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGNvZGUgPSAwOyAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cblxuICBpZiAoY2ggPT09ICd9Jykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfSAvLyBVVEYtMTYgRW5jb2RpbmdcblxuXG4gIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgY3UxID0gKGNvZGUgLSAweDEwMDAwID4+IDEwKSArIDB4RDgwMDtcbiAgY3UyID0gKGNvZGUgLSAweDEwMDAwICYgMTAyMykgKyAweERDMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gIHZhciBjaCwgaWQ7XG4gIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgICB9XG5cbiAgICArK2luZGV4O1xuICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuXG4gICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuXG4gICAgaWQgPSBjaDtcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgKytpbmRleDtcbiAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTsgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuXG4gICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcblxuICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgICAgIH1cblxuICAgICAgKytpbmRleDtcbiAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuXG4gICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG5cbiAgICAgIGlkICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgdmFyIHN0YXJ0LCBjaDtcbiAgc3RhcnQgPSBpbmRleCsrO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xuICAgIH1cblxuICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgKytpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcbiAgc3RhcnQgPSBpbmRleDsgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICBpZCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QyA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7IC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuXG4gIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICB0eXBlID0gVG9rZW5JZGVudGlmaWVyO1xuICB9IGVsc2UgaWYgKGtleXdvcmRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgdHlwZSA9IFRva2VuS2V5d29yZDtcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgdHlwZSA9IFRva2VuTnVsbExpdGVyYWw7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgIHR5cGUgPSBUb2tlbkJvb2xlYW5MaXRlcmFsO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBUb2tlbklkZW50aWZpZXI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdmFsdWU6IGlkLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59IC8vIDcuNyBQdW5jdHVhdG9yc1xuXG5cbmZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICBjb2RlMixcbiAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICBjaDIsXG4gICAgICBjaDMsXG4gICAgICBjaDQ7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgY2FzZSAweDJFOiAvLyAuIGRvdFxuXG4gICAgY2FzZSAweDI4OiAvLyAoIG9wZW4gYnJhY2tldFxuXG4gICAgY2FzZSAweDI5OiAvLyApIGNsb3NlIGJyYWNrZXRcblxuICAgIGNhc2UgMHgzQjogLy8gOyBzZW1pY29sb25cblxuICAgIGNhc2UgMHgyQzogLy8gLCBjb21tYVxuXG4gICAgY2FzZSAweDdCOiAvLyB7IG9wZW4gY3VybHkgYnJhY2VcblxuICAgIGNhc2UgMHg3RDogLy8gfSBjbG9zZSBjdXJseSBicmFjZVxuXG4gICAgY2FzZSAweDVCOiAvLyBbXG5cbiAgICBjYXNlIDB4NUQ6IC8vIF1cblxuICAgIGNhc2UgMHgzQTogLy8gOlxuXG4gICAgY2FzZSAweDNGOiAvLyA/XG5cbiAgICBjYXNlIDB4N0U6XG4gICAgICAvLyB+XG4gICAgICArK2luZGV4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTsgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cblxuICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgMHgyQjogLy8gK1xuXG4gICAgICAgICAgY2FzZSAweDJEOiAvLyAtXG5cbiAgICAgICAgICBjYXNlIDB4MkY6IC8vIC9cblxuICAgICAgICAgIGNhc2UgMHgzQzogLy8gPFxuXG4gICAgICAgICAgY2FzZSAweDNFOiAvLyA+XG5cbiAgICAgICAgICBjYXNlIDB4NUU6IC8vIF5cblxuICAgICAgICAgIGNhc2UgMHg3QzogLy8gfFxuXG4gICAgICAgICAgY2FzZSAweDI1OiAvLyAlXG5cbiAgICAgICAgICBjYXNlIDB4MjY6IC8vICZcblxuICAgICAgICAgIGNhc2UgMHgyQTpcbiAgICAgICAgICAgIC8vICpcbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgMHgyMTogLy8gIVxuXG4gICAgICAgICAgY2FzZSAweDNEOlxuICAgICAgICAgICAgLy8gPVxuICAgICAgICAgICAgaW5kZXggKz0gMjsgLy8gIT09IGFuZCA9PT1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfSAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cblxuICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcblxuICBpZiAoY2g0ID09PSAnPj4+PScpIHtcbiAgICBpbmRleCArPSA0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICB2YWx1ZTogY2g0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBpbmRleFxuICAgIH07XG4gIH0gLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuXG4gIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XG4gICAgaW5kZXggKz0gMztcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMyxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9IC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuXG5cbiAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICBpZiAoY2gxID09PSBjaDJbMV0gJiYgJystPD4mfCcuaW5kZXhPZihjaDEpID49IDAgfHwgY2gyID09PSAnPT4nKSB7XG4gICAgaW5kZXggKz0gMjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMixcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgaWYgKGNoMiA9PT0gJy8vJykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9IC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG5cbiAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgKytpbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMSxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG59IC8vIDcuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuXG5mdW5jdGlvbiBzY2FuSGV4TGl0ZXJhbChzdGFydCkge1xuICBsZXQgbnVtYmVyID0gJyc7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICB9XG5cbiAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW1iZXIsIDE2KSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KSB7XG4gIGxldCBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gIH1cblxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgb2N0YWw6IHRydWUsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG4gIGNoID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IGNoID09PSAnLicsICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcbiAgc3RhcnQgPSBpbmRleDtcbiAgbnVtYmVyID0gJyc7XG5cbiAgaWYgKGNoICE9PSAnLicpIHtcbiAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdOyAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cblxuICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICArK2luZGV4O1xuICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICB9IC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cblxuXG4gICAgICBpZiAoY2ggJiYgaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnLicpIHtcbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVG9rZW5OdW1lcmljTGl0ZXJhbCxcbiAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59IC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG5cbmZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICB2YXIgc3RyID0gJycsXG4gICAgICBxdW90ZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgY2gsXG4gICAgICBjb2RlLFxuICAgICAgb2N0YWwgPSBmYWxzZTtcbiAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICBhc3NlcnQocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG4gIHN0YXJ0ID0gaW5kZXg7XG4gICsraW5kZXg7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICBxdW90ZSA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpOyAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTsgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcblxuICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJiBpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gY2g7XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlblN0cmluZ0xpdGVyYWwsXG4gICAgdmFsdWU6IHN0cixcbiAgICBvY3RhbDogb2N0YWwsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICBsZXQgdG1wID0gcGF0dGVybjtcblxuICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgLy8gYC91YCBmbGFnLlxuICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCAoJDAsICQxKSA9PiB7XG4gICAgICBpZiAocGFyc2VJbnQoJDEsIDE2KSA8PSAweDEwRkZGRikge1xuICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCk7XG4gICAgfSkucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICB9IC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXG5cbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHRtcCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCk7XG4gIH0gLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAvLyB1c2VzLlxuXG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG4gIGNoID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG4gIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gIHRlcm1pbmF0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICBzdHIgKz0gY2g7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107IC8vIEVDTUEtMjYyIDcuOC41XG5cbiAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gY2g7XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghdGVybWluYXRlZCkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICB9IC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG5cblxuICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGJvZHksXG4gICAgbGl0ZXJhbDogc3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgdmFyIGNoLCBzdHIsIGZsYWdzO1xuICBzdHIgPSAnJztcbiAgZmxhZ3MgPSAnJztcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgICsraW5kZXg7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgc3RyICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmbGFncy5zZWFyY2goL1teZ2ltdXldL2cpID49IDApIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCwgZmxhZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZmxhZ3MsXG4gICAgbGl0ZXJhbDogc3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuICBsb29rYWhlYWQgPSBudWxsO1xuICBza2lwQ29tbWVudCgpO1xuICBzdGFydCA9IGluZGV4O1xuICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICByZWdleDoge1xuICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgIH0sXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW5JZGVudGlmaWVyIHx8IHRva2VuLnR5cGUgPT09IFRva2VuS2V5d29yZCB8fCB0b2tlbi50eXBlID09PSBUb2tlbkJvb2xlYW5MaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuTnVsbExpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gIHNraXBDb21tZW50KCk7XG5cbiAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlbkVPRixcbiAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICB9IC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG5cblxuICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfSAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuXG5cbiAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gIH0gLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cblxuXG4gIGlmIChjaCA9PT0gMHgyRSkge1xuICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xuICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgfVxuXG4gIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xufVxuXG5mdW5jdGlvbiBsZXgoKSB7XG4gIGNvbnN0IHRva2VuID0gbG9va2FoZWFkO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgcmV0dXJuIHRva2VuO1xufVxuXG5mdW5jdGlvbiBwZWVrKCkge1xuICBjb25zdCBwb3MgPSBpbmRleDtcbiAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICBpbmRleCA9IHBvcztcbn1cblxuZnVuY3Rpb24gZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhBcnJheUV4cHJlc3Npb24pO1xuICBub2RlLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicgPyBTeW50YXhMb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheEJpbmFyeUV4cHJlc3Npb24pO1xuICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4Q2FsbEV4cHJlc3Npb24pO1xuICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgbm9kZS5hcmd1bWVudHMgPSBhcmdzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4Q29uZGl0aW9uYWxFeHByZXNzaW9uKTtcbiAgbm9kZS50ZXN0ID0gdGVzdDtcbiAgbm9kZS5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgbm9kZS5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hJZGVudGlmaWVyKG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheElkZW50aWZpZXIpO1xuICBub2RlLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTGl0ZXJhbCh0b2tlbikge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4TGl0ZXJhbCk7XG4gIG5vZGUudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgbm9kZS5yYXcgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG5cbiAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgaWYgKG5vZGUucmF3ID09PSAnLy8nKSB7XG4gICAgICBub2RlLnJhdyA9ICcvKD86KS8nO1xuICAgIH1cblxuICAgIG5vZGUucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhNZW1iZXJFeHByZXNzaW9uKTtcbiAgbm9kZS5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gIG5vZGUub2JqZWN0ID0gb2JqZWN0O1xuICBub2RlLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIGlmICghbm9kZS5jb21wdXRlZCkgcHJvcGVydHkubWVtYmVyID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4T2JqZWN0RXhwcmVzc2lvbik7XG4gIG5vZGUucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hQcm9wZXJ0eShraW5kLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhQcm9wZXJ0eSk7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhVbmFyeUV4cHJlc3Npb24pO1xuICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gIG5vZGUuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICByZXR1cm4gbm9kZTtcbn0gLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cblxuZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICB2YXIgZXJyb3IsXG4gICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csICh3aG9sZSwgaW5kZXgpID0+IHtcbiAgICBhc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gIH0pO1xuICBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnJvci5pbmRleCA9IGluZGV4O1xuICBlcnJvci5kZXNjcmlwdGlvbiA9IG1zZztcbiAgdGhyb3cgZXJyb3I7XG59IC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuXG5mdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRFT1MpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuTnVtZXJpY0xpdGVyYWwpIHtcbiAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZE51bWJlcik7XG4gIH1cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5TdHJpbmdMaXRlcmFsKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRTdHJpbmcpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllcikge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gIH1cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRSZXNlcnZlZCk7XG4gIH0gLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuXG5cbiAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xufSAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cblxuZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7XG5cbiAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9XG59IC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG5cbmZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG59IC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cblxuZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xufSAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuXG5mdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBleHBlY3QoJ1snKTtcblxuICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgbGV4KCk7XG4gICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpO1xuXG4gICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV4KCk7XG4gIHJldHVybiBmaW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xufSAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7IC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlblN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5OdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmICh0b2tlbi5vY3RhbCkge1xuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaExpdGVyYWwodG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICB2YXIgdG9rZW4sIGtleSwgaWQsIHZhbHVlO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllcikge1xuICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICByZXR1cm4gZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvcikge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICByZXR1cm4gZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCkge1xuICB2YXIgcHJvcGVydGllcyA9IFtdLFxuICAgICAgcHJvcGVydHksXG4gICAgICBuYW1lLFxuICAgICAga2V5LFxuICAgICAgbWFwID0ge30sXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGV4cGVjdCgneycpO1xuXG4gIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgaWYgKHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXhJZGVudGlmaWVyKSB7XG4gICAgICBuYW1lID0gcHJvcGVydHkua2V5Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgIH1cblxuICAgIGtleSA9ICckJyArIG5hbWU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwW2tleV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgIGV4cGVjdCgnLCcpO1xuICAgIH1cbiAgfVxuXG4gIGV4cGVjdCgnfScpO1xuICByZXR1cm4gZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbn0gLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICBleHBlY3QoJygnKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICBleHBlY3QoJyknKTtcbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG5cbmNvbnN0IGxlZ2FsS2V5d29yZHMgPSB7XG4gICdpZic6IDFcbn07XG5cbmZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gIHZhciB0eXBlLCB0b2tlbiwgZXhwcjtcblxuICBpZiAobWF0Y2goJygnKSkge1xuICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gIH1cblxuICBpZiAobWF0Y2goJ3snKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gIH1cblxuICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuXG4gIGlmICh0eXBlID09PSBUb2tlbklkZW50aWZpZXIgfHwgbGVnYWxLZXl3b3Jkc1tsb29rYWhlYWQudmFsdWVdKSB7XG4gICAgZXhwciA9IGZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQsIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cblxuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbktleXdvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuQm9vbGVhbkxpdGVyYWwpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUgPT09ICd0cnVlJztcbiAgICBleHByID0gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW5OdWxsTGl0ZXJhbCkge1xuICAgIHRva2VuID0gbGV4KCk7XG4gICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgfSBlbHNlIGlmIChtYXRjaCgnLycpIHx8IG1hdGNoKCcvPScpKSB7XG4gICAgZXhwciA9IGZpbmlzaExpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICBwZWVrKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cblxuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXTtcbiAgZXhwZWN0KCcoJyk7XG5cbiAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcmdzLnB1c2gocGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSk7XG5cbiAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoJywnKTtcbiAgICB9XG4gIH1cblxuICBleHBlY3QoJyknKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7XG5cbiAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH1cblxuICByZXR1cm4gZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gIGV4cGVjdCgnLicpO1xuICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gIGV4cGVjdCgnWycpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gIGV4cGVjdCgnXScpO1xuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICB2YXIgZXhwciwgYXJncywgcHJvcGVydHk7XG4gIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICBleHByID0gZmluaXNoQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXG5cblxuZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgY29uc3QgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5QdW5jdHVhdG9yKSB7XG4gICAgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG5cbmZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgdG9rZW4sIGV4cHI7XG5cbiAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuS2V5d29yZCkge1xuICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgIGV4cHIgPSBmaW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuKSB7XG4gIGxldCBwcmVjID0gMDtcblxuICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuS2V5d29yZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgIGNhc2UgJ3x8JzpcbiAgICAgIHByZWMgPSAxO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcmJic6XG4gICAgICBwcmVjID0gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnfCc6XG4gICAgICBwcmVjID0gMztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnXic6XG4gICAgICBwcmVjID0gNDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJic6XG4gICAgICBwcmVjID0gNTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc9PT0nOlxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBwcmVjID0gNjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICBjYXNlICdpbic6XG4gICAgICBwcmVjID0gNztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPDwnOlxuICAgIGNhc2UgJz4+JzpcbiAgICBjYXNlICc+Pj4nOlxuICAgICAgcHJlYyA9IDg7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJysnOlxuICAgIGNhc2UgJy0nOlxuICAgICAgcHJlYyA9IDk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyonOlxuICAgIGNhc2UgJy8nOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcHJlYyA9IDExO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlYztcbn0gLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbi8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG4vLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4vLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4vLyAxMS45IEVxdWFsaXR5IE9wZXJhdG9yc1xuLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4vLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuXG5mdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gIGxlZnQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4pO1xuXG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cblxuICB0b2tlbi5wcmVjID0gcHJlYztcbiAgbGV4KCk7XG4gIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQpKSA+IDApIHtcbiAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIgJiYgcHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSB7XG4gICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICBleHByID0gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICB9IC8vIFNoaWZ0LlxuXG5cbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgIHN0YWNrLnB1c2goZXhwcik7XG4gIH0gLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cblxuXG4gIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICBleHByID0gc3RhY2tbaV07XG4gIG1hcmtlcnMucG9wKCk7XG5cbiAgd2hpbGUgKGkgPiAxKSB7XG4gICAgbWFya2Vycy5wb3AoKTtcbiAgICBleHByID0gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgaSAtPSAyO1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cblxuZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gIHZhciBleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG4gIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcblxuICBpZiAobWF0Y2goJz8nKSkge1xuICAgIGxleCgpO1xuICAgIGNvbnNlcXVlbnQgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIGFsdGVybmF0ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgZXhwciA9IGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjE0IENvbW1hIE9wZXJhdG9yXG5cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICBjb25zdCBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICBpZiAobWF0Y2goJywnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VyIChjb2RlKSB7XG4gIHNvdXJjZSA9IGNvZGU7XG4gIGluZGV4ID0gMDtcbiAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgbG9va2FoZWFkID0gbnVsbDtcbiAgcGVlaygpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbkVPRikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3QgdG9rZW4gYWZ0ZXIgZXhwcmVzc2lvbi4nKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufVxuXG52YXIgQ29uc3RhbnRzID0ge1xuICBOYU46ICdOYU4nLFxuICBFOiAnTWF0aC5FJyxcbiAgTE4yOiAnTWF0aC5MTjInLFxuICBMTjEwOiAnTWF0aC5MTjEwJyxcbiAgTE9HMkU6ICdNYXRoLkxPRzJFJyxcbiAgTE9HMTBFOiAnTWF0aC5MT0cxMEUnLFxuICBQSTogJ01hdGguUEknLFxuICBTUVJUMV8yOiAnTWF0aC5TUVJUMV8yJyxcbiAgU1FSVDI6ICdNYXRoLlNRUlQyJyxcbiAgTUlOX1ZBTFVFOiAnTnVtYmVyLk1JTl9WQUxVRScsXG4gIE1BWF9WQUxVRTogJ051bWJlci5NQVhfVkFMVUUnXG59O1xuXG5mdW5jdGlvbiBGdW5jdGlvbnMgKGNvZGVnZW4pIHtcbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICBsZXQgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcblxuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgJygnICsgb2JqICsgJyknO1xuICAgICAgaWYgKGNhc3QubGFzdEluZGV4T2YoJ25ldyAnLCAwKSA9PT0gMCkgb2JqID0gJygnICsgb2JqICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiBvYmogKyAnLicgKyBuYW1lICsgKHR5cGUgPCAwID8gJycgOiB0eXBlID09PSAwID8gJygpJyA6ICcoJyArIGFyZ3Muc2xpY2UoMSkubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICcpJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbihuYW1lLCBjYXN0LCB0eXBlKSB7XG4gICAgcmV0dXJuIGFyZ3MgPT4gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpO1xuICB9XG5cbiAgY29uc3QgREFURSA9ICduZXcgRGF0ZScsXG4gICAgICAgIFNUUklORyA9ICdTdHJpbmcnLFxuICAgICAgICBSRUdFWFAgPSAnUmVnRXhwJztcbiAgcmV0dXJuIHtcbiAgICAvLyBNQVRIIGZ1bmN0aW9uc1xuICAgIGlzTmFOOiAnTnVtYmVyLmlzTmFOJyxcbiAgICBpc0Zpbml0ZTogJ051bWJlci5pc0Zpbml0ZScsXG4gICAgYWJzOiAnTWF0aC5hYnMnLFxuICAgIGFjb3M6ICdNYXRoLmFjb3MnLFxuICAgIGFzaW46ICdNYXRoLmFzaW4nLFxuICAgIGF0YW46ICdNYXRoLmF0YW4nLFxuICAgIGF0YW4yOiAnTWF0aC5hdGFuMicsXG4gICAgY2VpbDogJ01hdGguY2VpbCcsXG4gICAgY29zOiAnTWF0aC5jb3MnLFxuICAgIGV4cDogJ01hdGguZXhwJyxcbiAgICBmbG9vcjogJ01hdGguZmxvb3InLFxuICAgIGxvZzogJ01hdGgubG9nJyxcbiAgICBtYXg6ICdNYXRoLm1heCcsXG4gICAgbWluOiAnTWF0aC5taW4nLFxuICAgIHBvdzogJ01hdGgucG93JyxcbiAgICByYW5kb206ICdNYXRoLnJhbmRvbScsXG4gICAgcm91bmQ6ICdNYXRoLnJvdW5kJyxcbiAgICBzaW46ICdNYXRoLnNpbicsXG4gICAgc3FydDogJ01hdGguc3FydCcsXG4gICAgdGFuOiAnTWF0aC50YW4nLFxuICAgIGNsYW1wOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykgZXJyb3IoJ01pc3NpbmcgYXJndW1lbnRzIHRvIGNsYW1wIGZ1bmN0aW9uLicpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykgZXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGNvbnN0IGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgIHJldHVybiAnTWF0aC5tYXgoJyArIGFbMV0gKyAnLCBNYXRoLm1pbignICsgYVsyXSArICcsJyArIGFbMF0gKyAnKSknO1xuICAgIH0sXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICBub3c6ICdEYXRlLm5vdycsXG4gICAgdXRjOiAnRGF0ZS5VVEMnLFxuICAgIGRhdGV0aW1lOiBEQVRFLFxuICAgIGRhdGU6IGZuKCdnZXREYXRlJywgREFURSwgMCksXG4gICAgZGF5OiBmbignZ2V0RGF5JywgREFURSwgMCksXG4gICAgeWVhcjogZm4oJ2dldEZ1bGxZZWFyJywgREFURSwgMCksXG4gICAgbW9udGg6IGZuKCdnZXRNb250aCcsIERBVEUsIDApLFxuICAgIGhvdXJzOiBmbignZ2V0SG91cnMnLCBEQVRFLCAwKSxcbiAgICBtaW51dGVzOiBmbignZ2V0TWludXRlcycsIERBVEUsIDApLFxuICAgIHNlY29uZHM6IGZuKCdnZXRTZWNvbmRzJywgREFURSwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBmbignZ2V0TWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgdGltZTogZm4oJ2dldFRpbWUnLCBEQVRFLCAwKSxcbiAgICB0aW1lem9uZW9mZnNldDogZm4oJ2dldFRpbWV6b25lT2Zmc2V0JywgREFURSwgMCksXG4gICAgdXRjZGF0ZTogZm4oJ2dldFVUQ0RhdGUnLCBEQVRFLCAwKSxcbiAgICB1dGNkYXk6IGZuKCdnZXRVVENEYXknLCBEQVRFLCAwKSxcbiAgICB1dGN5ZWFyOiBmbignZ2V0VVRDRnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICB1dGNtb250aDogZm4oJ2dldFVUQ01vbnRoJywgREFURSwgMCksXG4gICAgdXRjaG91cnM6IGZuKCdnZXRVVENIb3VycycsIERBVEUsIDApLFxuICAgIHV0Y21pbnV0ZXM6IGZuKCdnZXRVVENNaW51dGVzJywgREFURSwgMCksXG4gICAgdXRjc2Vjb25kczogZm4oJ2dldFVUQ1NlY29uZHMnLCBEQVRFLCAwKSxcbiAgICB1dGNtaWxsaXNlY29uZHM6IGZuKCdnZXRVVENNaWxsaXNlY29uZHMnLCBEQVRFLCAwKSxcbiAgICAvLyBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICBsZW5ndGg6IGZuKCdsZW5ndGgnLCBudWxsLCAtMSksXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgIHBhcnNlRmxvYXQ6ICdwYXJzZUZsb2F0JyxcbiAgICBwYXJzZUludDogJ3BhcnNlSW50JyxcbiAgICB1cHBlcjogZm4oJ3RvVXBwZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBsb3dlcjogZm4oJ3RvTG93ZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBzdWJzdHJpbmc6IGZuKCdzdWJzdHJpbmcnLCBTVFJJTkcpLFxuICAgIHNwbGl0OiBmbignc3BsaXQnLCBTVFJJTkcpLFxuICAgIHRyaW06IGZuKCd0cmltJywgU1RSSU5HLCAwKSxcbiAgICAvLyBSRUdFWFAgZnVuY3Rpb25zXG4gICAgcmVnZXhwOiBSRUdFWFAsXG4gICAgdGVzdDogZm4oJ3Rlc3QnLCBSRUdFWFApLFxuICAgIC8vIENvbnRyb2wgRmxvdyBmdW5jdGlvbnNcbiAgICBpZjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIGVycm9yKCdNaXNzaW5nIGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi4nKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIGVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICBjb25zdCBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICByZXR1cm4gJygnICsgYVswXSArICc/JyArIGFbMV0gKyAnOicgKyBhWzJdICsgJyknO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBRdW90ZXMocykge1xuICBjb25zdCBuID0gcyAmJiBzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBuICYmIChzWzBdID09PSAnXCInICYmIHNbbl0gPT09ICdcIicgfHwgc1swXSA9PT0gJ1xcJycgJiYgc1tuXSA9PT0gJ1xcJycpID8gcy5zbGljZSgxLCAtMSkgOiBzO1xufVxuXG5mdW5jdGlvbiBjb2RlZ2VuIChvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICBjb25zdCBhbGxvd2VkID0gb3B0LmFsbG93ZWQgPyB0b1NldChvcHQuYWxsb3dlZCkgOiB7fSxcbiAgICAgICAgZm9yYmlkZGVuID0gb3B0LmZvcmJpZGRlbiA/IHRvU2V0KG9wdC5mb3JiaWRkZW4pIDoge30sXG4gICAgICAgIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgQ29uc3RhbnRzLFxuICAgICAgICBmdW5jdGlvbnMgPSAob3B0LmZ1bmN0aW9ucyB8fCBGdW5jdGlvbnMpKHZpc2l0KSxcbiAgICAgICAgZ2xvYmFsdmFyID0gb3B0Lmdsb2JhbHZhcixcbiAgICAgICAgZmllbGR2YXIgPSBvcHQuZmllbGR2YXIsXG4gICAgICAgIG91dHB1dEdsb2JhbCA9IGlzRnVuY3Rpb24oZ2xvYmFsdmFyKSA/IGdsb2JhbHZhciA6IGlkID0+IGAke2dsb2JhbHZhcn1bXCIke2lkfVwiXWA7XG4gIGxldCBnbG9iYWxzID0ge30sXG4gICAgICBmaWVsZHMgPSB7fSxcbiAgICAgIG1lbWJlckRlcHRoID0gMDtcblxuICBmdW5jdGlvbiB2aXNpdChhc3QpIHtcbiAgICBpZiAoaXNTdHJpbmcoYXN0KSkgcmV0dXJuIGFzdDtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBHZW5lcmF0b3JzW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIGVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgYXN0LnR5cGUpO1xuICAgIHJldHVybiBnZW5lcmF0b3IoYXN0KTtcbiAgfVxuXG4gIGNvbnN0IEdlbmVyYXRvcnMgPSB7XG4gICAgTGl0ZXJhbDogbiA9PiBuLnJhdyxcbiAgICBJZGVudGlmaWVyOiBuID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbi5uYW1lO1xuXG4gICAgICBpZiAobWVtYmVyRGVwdGggPiAwKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoZm9yYmlkZGVuLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCdJbGxlZ2FsIGlkZW50aWZpZXI6ICcgKyBpZCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGNvbnN0YW50cywgaWQpKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShhbGxvd2VkLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsc1tpZF0gPSAxO1xuICAgICAgICByZXR1cm4gb3V0cHV0R2xvYmFsKGlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIE1lbWJlckV4cHJlc3Npb246IG4gPT4ge1xuICAgICAgY29uc3QgZCA9ICFuLmNvbXB1dGVkLFxuICAgICAgICAgICAgbyA9IHZpc2l0KG4ub2JqZWN0KTtcbiAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgY29uc3QgcCA9IHZpc2l0KG4ucHJvcGVydHkpO1xuXG4gICAgICBpZiAobyA9PT0gZmllbGR2YXIpIHtcbiAgICAgICAgLy8gc3RyaXAgcXVvdGVzIHRvIHNhbml0aXplIGZpZWxkIG5hbWUgKCMxNjUzKVxuICAgICAgICBmaWVsZHNbc3RyaXBRdW90ZXMocCldID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGQpIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICByZXR1cm4gbyArIChkID8gJy4nICsgcCA6ICdbJyArIHAgKyAnXScpO1xuICAgIH0sXG4gICAgQ2FsbEV4cHJlc3Npb246IG4gPT4ge1xuICAgICAgaWYgKG4uY2FsbGVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICBlcnJvcignSWxsZWdhbCBjYWxsZWUgdHlwZTogJyArIG4uY2FsbGVlLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lLFxuICAgICAgICAgICAgYXJncyA9IG4uYXJndW1lbnRzLFxuICAgICAgICAgICAgZm4gPSBoYXNPd25Qcm9wZXJ0eShmdW5jdGlvbnMsIGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICBpZiAoIWZuKSBlcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiAnICsgY2FsbGVlKTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZuKSA/IGZuKGFyZ3MpIDogZm4gKyAnKCcgKyBhcmdzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJyknO1xuICAgIH0sXG4gICAgQXJyYXlFeHByZXNzaW9uOiBuID0+ICdbJyArIG4uZWxlbWVudHMubWFwKHZpc2l0KS5qb2luKCcsJykgKyAnXScsXG4gICAgQmluYXJ5RXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLmxlZnQpICsgJyAnICsgbi5vcGVyYXRvciArICcgJyArIHZpc2l0KG4ucmlnaHQpICsgJyknLFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogbiA9PiAnKCcgKyBuLm9wZXJhdG9yICsgdmlzaXQobi5hcmd1bWVudCkgKyAnKScsXG4gICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBuID0+ICcoJyArIHZpc2l0KG4udGVzdCkgKyAnPycgKyB2aXNpdChuLmNvbnNlcXVlbnQpICsgJzonICsgdmlzaXQobi5hbHRlcm5hdGUpICsgJyknLFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiBuID0+ICcoJyArIHZpc2l0KG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgdmlzaXQobi5yaWdodCkgKyAnKScsXG4gICAgT2JqZWN0RXhwcmVzc2lvbjogbiA9PiAneycgKyBuLnByb3BlcnRpZXMubWFwKHZpc2l0KS5qb2luKCcsJykgKyAnfScsXG4gICAgUHJvcGVydHk6IG4gPT4ge1xuICAgICAgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgIGNvbnN0IGsgPSB2aXNpdChuLmtleSk7XG4gICAgICBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgcmV0dXJuIGsgKyAnOicgKyB2aXNpdChuLnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29kZWdlbihhc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBjb2RlOiB2aXNpdChhc3QpLFxuICAgICAgZ2xvYmFsczogT2JqZWN0LmtleXMoZ2xvYmFscyksXG4gICAgICBmaWVsZHM6IE9iamVjdC5rZXlzKGZpZWxkcylcbiAgICB9O1xuICAgIGdsb2JhbHMgPSB7fTtcbiAgICBmaWVsZHMgPSB7fTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29kZWdlbi5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gIGNvZGVnZW4uY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICByZXR1cm4gY29kZWdlbjtcbn1cblxuZXhwb3J0IHsgQVNUTm9kZSwgQXJyYXlFeHByZXNzaW9uLCBCaW5hcnlFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiwgQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBJZGVudGlmaWVyLCBMaXRlcmFsLCBMb2dpY2FsRXhwcmVzc2lvbiwgTWVtYmVyRXhwcmVzc2lvbiwgT2JqZWN0RXhwcmVzc2lvbiwgUHJvcGVydHksIFJhd0NvZGUsIFVuYXJ5RXhwcmVzc2lvbiwgY29kZWdlbiBhcyBjb2RlZ2VuRXhwcmVzc2lvbiwgQ29uc3RhbnRzIGFzIGNvbnN0YW50cywgRnVuY3Rpb25zIGFzIGZ1bmN0aW9ucywgcGFyc2VyIGFzIHBhcnNlRXhwcmVzc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9