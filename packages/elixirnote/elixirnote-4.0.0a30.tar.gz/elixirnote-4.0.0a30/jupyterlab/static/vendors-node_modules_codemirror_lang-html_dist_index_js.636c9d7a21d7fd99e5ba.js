"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_lang-html_dist_index_js"],{

/***/ "../../node_modules/@codemirror/lang-html/dist/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@codemirror/lang-html/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "autoCloseTags": () => (/* binding */ autoCloseTags),
/* harmony export */   "html": () => (/* binding */ html),
/* harmony export */   "htmlCompletionSource": () => (/* binding */ htmlCompletionSource),
/* harmony export */   "htmlCompletionSourceWith": () => (/* binding */ htmlCompletionSourceWith),
/* harmony export */   "htmlLanguage": () => (/* binding */ htmlLanguage)
/* harmony export */ });
/* harmony import */ var _lezer_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/html */ "../../node_modules/@lezer/html/dist/index.es.js");
/* harmony import */ var _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/lang-css */ "../../node_modules/@codemirror/lang-css/dist/index.js");
/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/lang-javascript */ "../../node_modules/@codemirror/lang-javascript/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ "../../node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ "../../node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ "../../node_modules/@codemirror/language/dist/index.js");







const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    acronym: S,
    address: S,
    applet: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    basefont: S,
    bdi: S,
    bdo: S,
    big: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    dir: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    font: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    frame: S,
    frameset: S,
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noframes: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"] },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    s: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strike: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    tt: S,
    u: S,
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    onclick: null,
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: /*@__PURE__*/"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = /*@__PURE__*/new Schema;
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (let cur = tree.parent; cur; cur = cur.parent)
        if (cur.name == "Element") {
            if (skip)
                skip = false;
            else
                return cur;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[elementName(doc, findParentElement(tree, true))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = tree; parent = findParentElement(parent);) {
        let tagName = elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: allowedChildren(state.doc, tree, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: identifier };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
    let names = (info && info.attrs ? Object.keys(info.attrs).concat(schema.globalAttrNames) : schema.globalAttrNames);
    return { from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: identifier };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(pos), tree = around.resolve(pos, -1);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/**
HTML tag completion. Opens and closes tags and attributes in a
context-aware way.
*/
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/**
Create a completion source for HTML extended with additional tags
or attributes.
*/
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LRLanguage.define({
    parser: /*@__PURE__*/_lezer_html__WEBPACK_IMPORTED_MODULE_0__.parser.configure({
        props: [
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null, close;
                    for (let cur = context.node;;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
                }
            })
        ],
        wrap: /*@__PURE__*/(0,_lezer_html__WEBPACK_IMPORTED_MODULE_0__.configureNesting)([
            { tag: "script",
                attrs(attrs) {
                    return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
                },
                parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser },
            { tag: "style",
                attrs(attrs) {
                    return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
                },
                parser: _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.cssLanguage.parser }
        ])
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
/**
Language support for HTML, including
[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and
CSS support extensions.
*/
function html(config = {}) {
    let lang = htmlLanguage;
    if (config.matchClosingTags === false)
        lang = lang.configure({ dialect: "noMatch" });
    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(lang, [
        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
        config.autoCloseTags !== false ? autoCloseTags : [],
        (0,_codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascript)().support,
        (0,_codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.css)().support
    ]);
}
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text) => {
    if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
        !htmlLanguage.isActiveAt(view.state, from, -1))
        return false;
    let { state } = view;
    let changes = state.changeByRange(range => {
        var _a, _b, _c;
        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(head, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, around.parent, head)))
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name}>` } };
        }
        else if (text == "/" && around.name == "OpenTag") {
            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;
            if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
                let insert = `/${name}>`;
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length), changes: { from: head, insert } };
            }
        }
        return { range };
    });
    if (changes.changes.empty)
        return false;
    view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
});




/***/ }),

/***/ "../../node_modules/@lezer/html/dist/index.es.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@lezer/html/dist/index.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "configureNesting": () => (/* binding */ configureNesting),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ "../../node_modules/@lezer/lr/dist/index.js");
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ "../../node_modules/@lezer/highlight/dist/index.js");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lezer/common */ "../../node_modules/@lezer/common/dist/index.js");




// This file was generated by lezer-generator. You probably shouldn't edit it.
const scriptText = 53,
  StartCloseScriptTag = 1,
  styleText = 54,
  StartCloseStyleTag = 2,
  textareaText = 55,
  StartCloseTextareaTag = 3,
  StartTag = 4,
  StartScriptTag = 5,
  StartStyleTag = 6,
  StartTextareaTag = 7,
  StartSelfClosingTag = 8,
  StartCloseTag = 9,
  NoMatchStartCloseTag = 10,
  MismatchedStartCloseTag = 11,
  missingCloseTag = 56,
  IncompleteCloseTag = 12,
  commentContent$1 = 57,
  Element = 18,
  ScriptText = 27,
  StyleText = 30,
  TextareaText = 33,
  OpenTag = 35,
  Dialect_noMatch = 0;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset);
  while (isSpace(next)) next = input.peek(++offset);
  let name = "";
  for (;;) {
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  // Undefined to signal there's a <? or <!, null for just missing
  cachedInput = input; cachedPos = pos;
  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}

const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];

const elementContext = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  hash(context) { return context ? context.hash : 0 },
  strict: false
});

const tagStart = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    // End of file, close any open tags
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name = tagNameAfter(input, 0);
  if (name === undefined) return
  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)

  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name == parent) return input.acceptToken(StartCloseTag)
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name == "script") return input.acceptToken(StartScriptTag)
    if (name == "style") return input.acceptToken(StartStyleTag)
    if (name == "textarea") return input.acceptToken(StartTextareaTag)
    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, {contextual: true});

const commentContent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {
  for (let dashes = 0, i = 0;; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break
    }
    if (input.next == dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i > 3) input.acceptToken(commentContent$1, -2);
      break
    } else {
      dashes = 0;
    }
    input.advance();
  }
});

function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {
    // state means:
    // - 0 nothing matched
    // - 1 '<' matched
    // - 2 '</' + possibly whitespace matched
    // - 3-(1+tag.length) part of the tag matched
    // - lastState whole tag + possibly whitespace matched
    for (let state = 0, matchedLen = 0, i = 0;; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break
      }
      if (state == 0 && input.next == lessThan ||
          state == 1 && input.next == slash ||
          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break
      } else if ((input.next == 10 /* '\n' */ || input.next == 13 /* '\r' */) && i) {
        input.acceptToken(textToken, 1);
        break
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  })
}

const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);

const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);

const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);

const htmlHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({
  "Text RawText": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,
  "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,
  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,
  "MismatchedCloseTag/TagName": [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,  _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid],
  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,
  "AttributeValue UnquotedAttributeValue": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,
  Is: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,
  "EntityReference CharacterReference": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,
  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,
  ProcessingInst: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,
  DoctypeDecl: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.documentMeta
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 14,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*ZO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*lO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*}O7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
  stateData: "+h~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!_!wO!`!uO~O_!xO`!xOa!xO!a!wO!b!xO~O_!uO`!uOa!uO!_!{O!`!uO~O_!xO`!xOa!xO!a!{O!b!xO~O`_a!cwz!c~",
  goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 66,
  context: elementContext,
  nodeProps: [
    ["closedBy", -11,1,2,3,4,5,6,7,8,9,10,11,"EndTag",-4,19,29,32,35,"CloseTag"],
    ["group", -9,12,15,16,17,18,38,39,40,41,"Entity",14,"Entity TextContent",-3,27,30,33,"TextContent Entity"],
    ["openedBy", 26,"StartTag StartCloseTag",-4,28,31,34,36,"OpenTag"]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWa!ROX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: {"Document":[0,13]},
  dialects: {noMatch: 0},
  tokenPrec: 476
});

function getAttrs(element, input) {
  let attrs = Object.create(null);
  for (let att of element.firstChild.getChildren("Attribute")) {
    let name = att.getChild("AttributeName"), value = att.getChild("AttributeValue") || att.getChild("UnquotedAttributeValue");
    if (name) attrs[input.read(name.from, name.to)] =
      !value ? "" : value.name == "AttributeValue" ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs
}

function maybeNest(node, input, tags) {
  let attrs;
  for (let tag of tags) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input))))
      return {parser: tag.parser}
  }
  return null
}

// tags: {
//   tag: "script" | "style" | "textarea",
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser: Parser
// }[]
 
function configureNesting(tags) {
  let script = [], style = [], textarea = [];
  for (let tag of tags) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
    if (!array) throw new RangeError("Only script, style, and textarea tags can host nested parsers")
    array.push(tag);
  }
  return (0,_lezer_common__WEBPACK_IMPORTED_MODULE_2__.parseMixed)((node, input) => {
    let id = node.type.id;
    if (id == ScriptText) return maybeNest(node, input, script)
    if (id == StyleText) return maybeNest(node, input, style)
    if (id == TextareaText) return maybeNest(node, input, textarea)
    return null
  })
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sYW5nLWh0bWxfZGlzdF9pbmRleF9qcy42MzZjOWQ3YTIxZDdmZDk5ZTViYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNDO0FBQ3FCO0FBQy9CO0FBQ007QUFDeUQ7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxTQUFTLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxTQUFTLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxjQUFjO0FBQ2xDLGdCQUFnQixTQUFTLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxTQUFTLGVBQWU7QUFDcEMsZ0JBQWdCLFNBQVMsa0RBQWtEO0FBQzNFLGdCQUFnQixTQUFTLGNBQWM7QUFDdkM7QUFDQSxXQUFXLFNBQVMsOEJBQThCO0FBQ2xELGVBQWUsU0FBUyxrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLG9EQUFvRDtBQUMxRSxtQkFBbUIsU0FBUyxhQUFhO0FBQ3pDLGdCQUFnQixTQUFTLGtEQUFrRDtBQUMzRTtBQUNBO0FBQ0E7QUFD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LDhDQUE4Qyw4QkFBOEIsVUFBVSxxQ0FBcUMsdUVBQXVFLEdBQUcsa0JBQWtCO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRywrREFBK0QsSUFBSSwySkFBMkosS0FBSyxHQUFHLEtBQUssMG5DQUEwbkMsR0FBRyw0WEFBNFgsR0FBRyx3REFBd0QsSUFBSSxzQ0FBc0MsSUFBSSw2SUFBNkksS0FBSyxHQUFHLEtBQUssNElBQTRJLEtBQUsseUZBQXlGLEdBQUcsSUFBSSwwREFBMEQsR0FBRywwTUFBME0sSUFBSSxxcEJBQXFwQiw0UUFBNFE7QUFDLzhHO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1odG1sL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaHRtbC9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciwgY29uZmlndXJlTmVzdGluZyB9IGZyb20gJ0BsZXplci9odG1sJztcbmltcG9ydCB7IGNzc0xhbmd1YWdlLCBjc3MgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWNzcyc7XG5pbXBvcnQgeyBqYXZhc2NyaXB0TGFuZ3VhZ2UsIGphdmFzY3JpcHQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGZvbGROb2RlUHJvcCwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG5jb25zdCBUYXJnZXRzID0gW1wiX2JsYW5rXCIsIFwiX3NlbGZcIiwgXCJfdG9wXCIsIFwiX3BhcmVudFwiXTtcbmNvbnN0IENoYXJzZXRzID0gW1wiYXNjaWlcIiwgXCJ1dGYtOFwiLCBcInV0Zi0xNlwiLCBcImxhdGluMVwiLCBcImxhdGluMVwiXTtcbmNvbnN0IE1ldGhvZHMgPSBbXCJnZXRcIiwgXCJwb3N0XCIsIFwicHV0XCIsIFwiZGVsZXRlXCJdO1xuY29uc3QgRW5jcyA9IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdO1xuY29uc3QgQm9vbCA9IFtcInRydWVcIiwgXCJmYWxzZVwiXTtcbmNvbnN0IFMgPSB7fTsgLy8gRW1wdHkgdGFnIHNwZWNcbmNvbnN0IFRhZ3MgPSB7XG4gICAgYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaHJlZjogbnVsbCwgcGluZzogbnVsbCwgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgdGFyZ2V0OiBUYXJnZXRzLFxuICAgICAgICAgICAgaHJlZmxhbmc6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWJicjogUyxcbiAgICBhY3JvbnltOiBTLFxuICAgIGFkZHJlc3M6IFMsXG4gICAgYXBwbGV0OiBTLFxuICAgIGFyZWE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgY29vcmRzOiBudWxsLCBocmVmOiBudWxsLCB0YXJnZXQ6IG51bGwsIHBpbmc6IG51bGwsXG4gICAgICAgICAgICBtZWRpYTogbnVsbCwgaHJlZmxhbmc6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBzaGFwZTogW1wiZGVmYXVsdFwiLCBcInJlY3RcIiwgXCJjaXJjbGVcIiwgXCJwb2x5XCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFydGljbGU6IFMsXG4gICAgYXNpZGU6IFMsXG4gICAgYXVkaW86IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHNyYzogbnVsbCwgbWVkaWFncm91cDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl0sXG4gICAgICAgICAgICBwcmVsb2FkOiBbXCJub25lXCIsIFwibWV0YWRhdGFcIiwgXCJhdXRvXCJdLFxuICAgICAgICAgICAgYXV0b3BsYXk6IFtcImF1dG9wbGF5XCJdLFxuICAgICAgICAgICAgbG9vcDogW1wibG9vcFwiXSxcbiAgICAgICAgICAgIGNvbnRyb2xzOiBbXCJjb250cm9sc1wiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBiOiBTLFxuICAgIGJhc2U6IHsgYXR0cnM6IHsgaHJlZjogbnVsbCwgdGFyZ2V0OiBUYXJnZXRzIH0gfSxcbiAgICBiYXNlZm9udDogUyxcbiAgICBiZGk6IFMsXG4gICAgYmRvOiBTLFxuICAgIGJpZzogUyxcbiAgICBibG9ja3F1b3RlOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwgfSB9LFxuICAgIGJvZHk6IFMsXG4gICAgYnI6IFMsXG4gICAgYnV0dG9uOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBmb3JtOiBudWxsLCBmb3JtYWN0aW9uOiBudWxsLCBuYW1lOiBudWxsLCB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGZvcm1lbmN0eXBlOiBFbmNzLFxuICAgICAgICAgICAgZm9ybW1ldGhvZDogTWV0aG9kcyxcbiAgICAgICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgZm9ybXRhcmdldDogVGFyZ2V0cyxcbiAgICAgICAgICAgIHR5cGU6IFtcInN1Ym1pdFwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbnZhczogeyBhdHRyczogeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsIH0gfSxcbiAgICBjYXB0aW9uOiBTLFxuICAgIGNlbnRlcjogUyxcbiAgICBjaXRlOiBTLFxuICAgIGNvZGU6IFMsXG4gICAgY29sOiB7IGF0dHJzOiB7IHNwYW46IG51bGwgfSB9LFxuICAgIGNvbGdyb3VwOiB7IGF0dHJzOiB7IHNwYW46IG51bGwgfSB9LFxuICAgIGNvbW1hbmQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHR5cGU6IFtcImNvbW1hbmRcIiwgXCJjaGVja2JveFwiLCBcInJhZGlvXCJdLFxuICAgICAgICAgICAgbGFiZWw6IG51bGwsIGljb246IG51bGwsIHJhZGlvZ3JvdXA6IG51bGwsIGNvbW1hbmQ6IG51bGwsIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgICAgICAgY2hlY2tlZDogW1wiY2hlY2tlZFwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsIH0gfSxcbiAgICBkYXRhZ3JpZDogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIG11bHRpcGxlOiBbXCJtdWx0aXBsZVwiXSB9IH0sXG4gICAgZGF0YWxpc3Q6IHsgYXR0cnM6IHsgZGF0YTogbnVsbCB9IH0sXG4gICAgZGQ6IFMsXG4gICAgZGVsOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwsIGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICBkZXRhaWxzOiB7IGF0dHJzOiB7IG9wZW46IFtcIm9wZW5cIl0gfSB9LFxuICAgIGRmbjogUyxcbiAgICBkaXI6IFMsXG4gICAgZGl2OiBTLFxuICAgIGRsOiBTLFxuICAgIGR0OiBTLFxuICAgIGVtOiBTLFxuICAgIGVtYmVkOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgZXZlbnRzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsIH0gfSxcbiAgICBmaWVsZHNldDogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGZvcm06IG51bGwsIG5hbWU6IG51bGwgfSB9LFxuICAgIGZpZ2NhcHRpb246IFMsXG4gICAgZmlndXJlOiBTLFxuICAgIGZvbnQ6IFMsXG4gICAgZm9vdGVyOiBTLFxuICAgIGZvcm06IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFjdGlvbjogbnVsbCwgbmFtZTogbnVsbCxcbiAgICAgICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogQ2hhcnNldHMsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IFtcIm9uXCIsIFwib2ZmXCJdLFxuICAgICAgICAgICAgZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kcyxcbiAgICAgICAgICAgIG5vdmFsaWRhdGU6IFtcIm5vdmFsaWRhdGVcIl0sXG4gICAgICAgICAgICB0YXJnZXQ6IFRhcmdldHNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZnJhbWU6IFMsXG4gICAgZnJhbWVzZXQ6IFMsXG4gICAgaDE6IFMsIGgyOiBTLCBoMzogUywgaDQ6IFMsIGg1OiBTLCBoNjogUyxcbiAgICBoZWFkOiB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJ0aXRsZVwiLCBcImJhc2VcIiwgXCJsaW5rXCIsIFwic3R5bGVcIiwgXCJtZXRhXCIsIFwic2NyaXB0XCIsIFwibm9zY3JpcHRcIiwgXCJjb21tYW5kXCJdXG4gICAgfSxcbiAgICBoZWFkZXI6IFMsXG4gICAgaGdyb3VwOiBTLFxuICAgIGhyOiBTLFxuICAgIGh0bWw6IHtcbiAgICAgICAgYXR0cnM6IHsgbWFuaWZlc3Q6IG51bGwgfVxuICAgIH0sXG4gICAgaTogUyxcbiAgICBpZnJhbWU6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHNyYzogbnVsbCwgc3JjZG9jOiBudWxsLCBuYW1lOiBudWxsLCB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgc2FuZGJveDogW1wiYWxsb3ctdG9wLW5hdmlnYXRpb25cIiwgXCJhbGxvdy1zYW1lLW9yaWdpblwiLCBcImFsbG93LWZvcm1zXCIsIFwiYWxsb3ctc2NyaXB0c1wiXSxcbiAgICAgICAgICAgIHNlYW1sZXNzOiBbXCJzZWFtbGVzc1wiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpbWc6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgc3JjOiBudWxsLCBpc21hcDogbnVsbCwgdXNlbWFwOiBudWxsLCB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFtcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpbnB1dDoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgYWx0OiBudWxsLCBkaXJuYW1lOiBudWxsLCBmb3JtOiBudWxsLCBmb3JtYWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgaGVpZ2h0OiBudWxsLCBsaXN0OiBudWxsLCBtYXg6IG51bGwsIG1heGxlbmd0aDogbnVsbCwgbWluOiBudWxsLFxuICAgICAgICAgICAgbmFtZTogbnVsbCwgcGF0dGVybjogbnVsbCwgcGxhY2Vob2xkZXI6IG51bGwsIHNpemU6IG51bGwsIHNyYzogbnVsbCxcbiAgICAgICAgICAgIHN0ZXA6IG51bGwsIHZhbHVlOiBudWxsLCB3aWR0aDogbnVsbCxcbiAgICAgICAgICAgIGFjY2VwdDogW1wiYXVkaW8vKlwiLCBcInZpZGVvLypcIiwgXCJpbWFnZS8qXCJdLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgY2hlY2tlZDogW1wiY2hlY2tlZFwiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGZvcm1lbmN0eXBlOiBFbmNzLFxuICAgICAgICAgICAgZm9ybW1ldGhvZDogTWV0aG9kcyxcbiAgICAgICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgZm9ybXRhcmdldDogVGFyZ2V0cyxcbiAgICAgICAgICAgIG11bHRpcGxlOiBbXCJtdWx0aXBsZVwiXSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgICAgICAgIHR5cGU6IFtcImhpZGRlblwiLCBcInRleHRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwiZGF0ZXRpbWVcIiwgXCJkYXRlXCIsIFwibW9udGhcIixcbiAgICAgICAgICAgICAgICBcIndlZWtcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJudW1iZXJcIiwgXCJyYW5nZVwiLCBcImNvbG9yXCIsIFwiY2hlY2tib3hcIiwgXCJyYWRpb1wiLFxuICAgICAgICAgICAgICAgIFwiZmlsZVwiLCBcInN1Ym1pdFwiLCBcImltYWdlXCIsIFwicmVzZXRcIiwgXCJidXR0b25cIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5zOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwsIGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICBrYmQ6IFMsXG4gICAga2V5Z2VuOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBjaGFsbGVuZ2U6IG51bGwsIGZvcm06IG51bGwsIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGtleXR5cGU6IFtcIlJTQVwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBsYWJlbDogeyBhdHRyczogeyBmb3I6IG51bGwsIGZvcm06IG51bGwgfSB9LFxuICAgIGxlZ2VuZDogUyxcbiAgICBsaTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gICAgbGluazoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaHJlZjogbnVsbCwgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIGhyZWZsYW5nOiBudWxsLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsXG4gICAgICAgICAgICBzaXplczogW1wiYWxsXCIsIFwiMTZ4MTZcIiwgXCIxNngxNiAzMngzMlwiLCBcIjE2eDE2IDMyeDMyIDY0eDY0XCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1hcDogeyBhdHRyczogeyBuYW1lOiBudWxsIH0gfSxcbiAgICBtYXJrOiBTLFxuICAgIG1lbnU6IHsgYXR0cnM6IHsgbGFiZWw6IG51bGwsIHR5cGU6IFtcImxpc3RcIiwgXCJjb250ZXh0XCIsIFwidG9vbGJhclwiXSB9IH0sXG4gICAgbWV0YToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgICAgIGNoYXJzZXQ6IENoYXJzZXRzLFxuICAgICAgICAgICAgbmFtZTogW1widmlld3BvcnRcIiwgXCJhcHBsaWNhdGlvbi1uYW1lXCIsIFwiYXV0aG9yXCIsIFwiZGVzY3JpcHRpb25cIiwgXCJnZW5lcmF0b3JcIiwgXCJrZXl3b3Jkc1wiXSxcbiAgICAgICAgICAgIFwiaHR0cC1lcXVpdlwiOiBbXCJjb250ZW50LWxhbmd1YWdlXCIsIFwiY29udGVudC10eXBlXCIsIFwiZGVmYXVsdC1zdHlsZVwiLCBcInJlZnJlc2hcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0ZXI6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwsIG1pbjogbnVsbCwgbG93OiBudWxsLCBoaWdoOiBudWxsLCBtYXg6IG51bGwsIG9wdGltdW06IG51bGwgfSB9LFxuICAgIG5hdjogUyxcbiAgICBub2ZyYW1lczogUyxcbiAgICBub3NjcmlwdDogUyxcbiAgICBvYmplY3Q6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsIHR5cGU6IG51bGwsIG5hbWU6IG51bGwsIHVzZW1hcDogbnVsbCwgZm9ybTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHR5cGVtdXN0bWF0Y2g6IFtcInR5cGVtdXN0bWF0Y2hcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgb2w6IHsgYXR0cnM6IHsgcmV2ZXJzZWQ6IFtcInJldmVyc2VkXCJdLCBzdGFydDogbnVsbCwgdHlwZTogW1wiMVwiLCBcImFcIiwgXCJBXCIsIFwiaVwiLCBcIklcIl0gfSxcbiAgICAgICAgY2hpbGRyZW46IFtcImxpXCIsIFwic2NyaXB0XCIsIFwidGVtcGxhdGVcIiwgXCJ1bFwiLCBcIm9sXCJdIH0sXG4gICAgb3B0Z3JvdXA6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBsYWJlbDogbnVsbCB9IH0sXG4gICAgb3B0aW9uOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbGFiZWw6IG51bGwsIHNlbGVjdGVkOiBbXCJzZWxlY3RlZFwiXSwgdmFsdWU6IG51bGwgfSB9LFxuICAgIG91dHB1dDogeyBhdHRyczogeyBmb3I6IG51bGwsIGZvcm06IG51bGwsIG5hbWU6IG51bGwgfSB9LFxuICAgIHA6IFMsXG4gICAgcGFyYW06IHsgYXR0cnM6IHsgbmFtZTogbnVsbCwgdmFsdWU6IG51bGwgfSB9LFxuICAgIHByZTogUyxcbiAgICBwcm9ncmVzczogeyBhdHRyczogeyB2YWx1ZTogbnVsbCwgbWF4OiBudWxsIH0gfSxcbiAgICBxOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwgfSB9LFxuICAgIHJwOiBTLFxuICAgIHJ0OiBTLFxuICAgIHJ1Ynk6IFMsXG4gICAgczogUyxcbiAgICBzYW1wOiBTLFxuICAgIHNjcmlwdDoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgdHlwZTogW1widGV4dC9qYXZhc2NyaXB0XCJdLFxuICAgICAgICAgICAgc3JjOiBudWxsLFxuICAgICAgICAgICAgYXN5bmM6IFtcImFzeW5jXCJdLFxuICAgICAgICAgICAgZGVmZXI6IFtcImRlZmVyXCJdLFxuICAgICAgICAgICAgY2hhcnNldDogQ2hhcnNldHNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VjdGlvbjogUyxcbiAgICBzZWxlY3Q6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGZvcm06IG51bGwsIG5hbWU6IG51bGwsIHNpemU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIG11bHRpcGxlOiBbXCJtdWx0aXBsZVwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzbG90OiB7IGF0dHJzOiB7IG5hbWU6IG51bGwgfSB9LFxuICAgIHNtYWxsOiBTLFxuICAgIHNvdXJjZTogeyBhdHRyczogeyBzcmM6IG51bGwsIHR5cGU6IG51bGwsIG1lZGlhOiBudWxsIH0gfSxcbiAgICBzcGFuOiBTLFxuICAgIHN0cmlrZTogUyxcbiAgICBzdHJvbmc6IFMsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHR5cGU6IFtcInRleHQvY3NzXCJdLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsXG4gICAgICAgICAgICBzY29wZWQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3ViOiBTLFxuICAgIHN1bW1hcnk6IFMsXG4gICAgc3VwOiBTLFxuICAgIHRhYmxlOiBTLFxuICAgIHRib2R5OiBTLFxuICAgIHRkOiB7IGF0dHJzOiB7IGNvbHNwYW46IG51bGwsIHJvd3NwYW46IG51bGwsIGhlYWRlcnM6IG51bGwgfSB9LFxuICAgIHRlbXBsYXRlOiBTLFxuICAgIHRleHRhcmVhOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkaXJuYW1lOiBudWxsLCBmb3JtOiBudWxsLCBtYXhsZW5ndGg6IG51bGwsIG5hbWU6IG51bGwsIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICAgICAgcm93czogbnVsbCwgY29sczogbnVsbCxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgICAgICAgcmVhZG9ubHk6IFtcInJlYWRvbmx5XCJdLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInJlcXVpcmVkXCJdLFxuICAgICAgICAgICAgd3JhcDogW1wic29mdFwiLCBcImhhcmRcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGZvb3Q6IFMsXG4gICAgdGg6IHsgYXR0cnM6IHsgY29sc3BhbjogbnVsbCwgcm93c3BhbjogbnVsbCwgaGVhZGVyczogbnVsbCwgc2NvcGU6IFtcInJvd1wiLCBcImNvbFwiLCBcInJvd2dyb3VwXCIsIFwiY29sZ3JvdXBcIl0gfSB9LFxuICAgIHRoZWFkOiBTLFxuICAgIHRpbWU6IHsgYXR0cnM6IHsgZGF0ZXRpbWU6IG51bGwgfSB9LFxuICAgIHRpdGxlOiBTLFxuICAgIHRyOiBTLFxuICAgIHRyYWNrOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIGxhYmVsOiBudWxsLCBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAga2luZDogW1wic3VidGl0bGVzXCIsIFwiY2FwdGlvbnNcIiwgXCJkZXNjcmlwdGlvbnNcIiwgXCJjaGFwdGVyc1wiLCBcIm1ldGFkYXRhXCJdLFxuICAgICAgICAgICAgc3JjbGFuZzogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICB0dDogUyxcbiAgICB1OiBTLFxuICAgIHVsOiB7IGNoaWxkcmVuOiBbXCJsaVwiLCBcInNjcmlwdFwiLCBcInRlbXBsYXRlXCIsIFwidWxcIiwgXCJvbFwiXSB9LFxuICAgIHZhcjogUyxcbiAgICB2aWRlbzoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBwb3N0ZXI6IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBjcm9zc29yaWdpbjogW1wiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCJdLFxuICAgICAgICAgICAgcHJlbG9hZDogW1wiYXV0b1wiLCBcIm1ldGFkYXRhXCIsIFwibm9uZVwiXSxcbiAgICAgICAgICAgIGF1dG9wbGF5OiBbXCJhdXRvcGxheVwiXSxcbiAgICAgICAgICAgIG1lZGlhZ3JvdXA6IFtcIm1vdmllXCJdLFxuICAgICAgICAgICAgbXV0ZWQ6IFtcIm11dGVkXCJdLFxuICAgICAgICAgICAgY29udHJvbHM6IFtcImNvbnRyb2xzXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdicjogU1xufTtcbmNvbnN0IEdsb2JhbEF0dHJzID0ge1xuICAgIGFjY2Vzc2tleTogbnVsbCxcbiAgICBjbGFzczogbnVsbCxcbiAgICBjb250ZW50ZWRpdGFibGU6IEJvb2wsXG4gICAgY29udGV4dG1lbnU6IG51bGwsXG4gICAgZGlyOiBbXCJsdHJcIiwgXCJydGxcIiwgXCJhdXRvXCJdLFxuICAgIGRyYWdnYWJsZTogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwiYXV0b1wiXSxcbiAgICBkcm9wem9uZTogW1wiY29weVwiLCBcIm1vdmVcIiwgXCJsaW5rXCIsIFwic3RyaW5nOlwiLCBcImZpbGU6XCJdLFxuICAgIGhpZGRlbjogW1wiaGlkZGVuXCJdLFxuICAgIGlkOiBudWxsLFxuICAgIGluZXJ0OiBbXCJpbmVydFwiXSxcbiAgICBpdGVtaWQ6IG51bGwsXG4gICAgaXRlbXByb3A6IG51bGwsXG4gICAgaXRlbXJlZjogbnVsbCxcbiAgICBpdGVtc2NvcGU6IFtcIml0ZW1zY29wZVwiXSxcbiAgICBpdGVtdHlwZTogbnVsbCxcbiAgICBsYW5nOiBbXCJhclwiLCBcImJuXCIsIFwiZGVcIiwgXCJlbi1HQlwiLCBcImVuLVVTXCIsIFwiZXNcIiwgXCJmclwiLCBcImhpXCIsIFwiaWRcIiwgXCJqYVwiLCBcInBhXCIsIFwicHRcIiwgXCJydVwiLCBcInRyXCIsIFwiemhcIl0sXG4gICAgc3BlbGxjaGVjazogQm9vbCxcbiAgICBhdXRvY29ycmVjdDogQm9vbCxcbiAgICBhdXRvY2FwaXRhbGl6ZTogQm9vbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB0YWJpbmRleDogbnVsbCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB0cmFuc2xhdGU6IFtcInllc1wiLCBcIm5vXCJdLFxuICAgIG9uY2xpY2s6IG51bGwsXG4gICAgcmVsOiBbXCJzdHlsZXNoZWV0XCIsIFwiYWx0ZXJuYXRlXCIsIFwiYXV0aG9yXCIsIFwiYm9va21hcmtcIiwgXCJoZWxwXCIsIFwibGljZW5zZVwiLCBcIm5leHRcIiwgXCJub2ZvbGxvd1wiLCBcIm5vcmVmZXJyZXJcIiwgXCJwcmVmZXRjaFwiLCBcInByZXZcIiwgXCJzZWFyY2hcIiwgXCJ0YWdcIl0sXG4gICAgcm9sZTogLypAX19QVVJFX18qL1wiYWxlcnQgYXBwbGljYXRpb24gYXJ0aWNsZSBiYW5uZXIgYnV0dG9uIGNlbGwgY2hlY2tib3ggY29tcGxlbWVudGFyeSBjb250ZW50aW5mbyBkaWFsb2cgZG9jdW1lbnQgZmVlZCBmaWd1cmUgZm9ybSBncmlkIGdyaWRjZWxsIGhlYWRpbmcgaW1nIGxpc3QgbGlzdGJveCBsaXN0aXRlbSBtYWluIG5hdmlnYXRpb24gcmVnaW9uIHJvdyByb3dncm91cCBzZWFyY2ggc3dpdGNoIHRhYiB0YWJsZSB0YWJwYW5lbCB0ZXh0Ym94IHRpbWVyXCIuc3BsaXQoXCIgXCIpLFxuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IG51bGwsXG4gICAgXCJhcmlhLWF0b21pY1wiOiBCb29sLFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogW1wiaW5saW5lXCIsIFwibGlzdFwiLCBcImJvdGhcIiwgXCJub25lXCJdLFxuICAgIFwiYXJpYS1idXN5XCI6IEJvb2wsXG4gICAgXCJhcmlhLWNoZWNrZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IG51bGwsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IG51bGwsXG4gICAgXCJhcmlhLWRpc2FibGVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLWRyb3BlZmZlY3RcIjogbnVsbCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1mbG93dG9cIjogbnVsbCxcbiAgICBcImFyaWEtZ3JhYmJlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IEJvb2wsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBCb29sLFxuICAgIFwiYXJpYS1pbnZhbGlkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcImdyYW1tYXJcIiwgXCJzcGVsbGluZ1wiXSxcbiAgICBcImFyaWEtbGFiZWxcIjogbnVsbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBudWxsLFxuICAgIFwiYXJpYS1sZXZlbFwiOiBudWxsLFxuICAgIFwiYXJpYS1saXZlXCI6IFtcIm9mZlwiLCBcInBvbGl0ZVwiLCBcImFzc2VydGl2ZVwiXSxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IEJvb2wsXG4gICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiBCb29sLFxuICAgIFwiYXJpYS1vd25zXCI6IG51bGwsXG4gICAgXCJhcmlhLXBvc2luc2V0XCI6IG51bGwsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6IEJvb2wsXG4gICAgXCJhcmlhLXJlbGV2YW50XCI6IG51bGwsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtc2V0c2l6ZVwiOiBudWxsLFxuICAgIFwiYXJpYS1zb3J0XCI6IFtcImFzY2VuZGluZ1wiLCBcImRlc2NlbmRpbmdcIiwgXCJub25lXCIsIFwib3RoZXJcIl0sXG4gICAgXCJhcmlhLXZhbHVlbWF4XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbWluXCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbm93XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVldGV4dFwiOiBudWxsXG59O1xuY2xhc3MgU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYVRhZ3MsIGV4dHJhQXR0cnMpIHtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBUYWdzKSwgZXh0cmFUYWdzKTtcbiAgICAgICAgdGhpcy5nbG9iYWxBdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR2xvYmFsQXR0cnMpLCBleHRyYUF0dHJzKTtcbiAgICAgICAgdGhpcy5hbGxUYWdzID0gT2JqZWN0LmtleXModGhpcy50YWdzKTtcbiAgICAgICAgdGhpcy5nbG9iYWxBdHRyTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmdsb2JhbEF0dHJzKTtcbiAgICB9XG59XG5TY2hlbWEuZGVmYXVsdCA9IC8qQF9fUFVSRV9fKi9uZXcgU2NoZW1hO1xuZnVuY3Rpb24gZWxlbWVudE5hbWUoZG9jLCB0cmVlLCBtYXggPSBkb2MubGVuZ3RoKSB7XG4gICAgaWYgKCF0cmVlKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBsZXQgdGFnID0gdHJlZS5maXJzdENoaWxkO1xuICAgIGxldCBuYW1lID0gdGFnICYmIHRhZy5nZXRDaGlsZChcIlRhZ05hbWVcIik7XG4gICAgcmV0dXJuIG5hbWUgPyBkb2Muc2xpY2VTdHJpbmcobmFtZS5mcm9tLCBNYXRoLm1pbihuYW1lLnRvLCBtYXgpKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBmaW5kUGFyZW50RWxlbWVudCh0cmVlLCBza2lwID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBjdXIgPSB0cmVlLnBhcmVudDsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAoY3VyLm5hbWUgPT0gXCJFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhbGxvd2VkQ2hpbGRyZW4oZG9jLCB0cmVlLCBzY2hlbWEpIHtcbiAgICBsZXQgcGFyZW50SW5mbyA9IHNjaGVtYS50YWdzW2VsZW1lbnROYW1lKGRvYywgZmluZFBhcmVudEVsZW1lbnQodHJlZSwgdHJ1ZSkpXTtcbiAgICByZXR1cm4gKHBhcmVudEluZm8gPT09IG51bGwgfHwgcGFyZW50SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50SW5mby5jaGlsZHJlbikgfHwgc2NoZW1hLmFsbFRhZ3M7XG59XG5mdW5jdGlvbiBvcGVuVGFncyhkb2MsIHRyZWUpIHtcbiAgICBsZXQgb3BlbiA9IFtdO1xuICAgIGZvciAobGV0IHBhcmVudCA9IHRyZWU7IHBhcmVudCA9IGZpbmRQYXJlbnRFbGVtZW50KHBhcmVudCk7KSB7XG4gICAgICAgIGxldCB0YWdOYW1lID0gZWxlbWVudE5hbWUoZG9jLCBwYXJlbnQpO1xuICAgICAgICBpZiAodGFnTmFtZSAmJiBwYXJlbnQubGFzdENoaWxkLm5hbWUgPT0gXCJDbG9zZVRhZ1wiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICh0YWdOYW1lICYmIG9wZW4uaW5kZXhPZih0YWdOYW1lKSA8IDAgJiYgKHRyZWUubmFtZSA9PSBcIkVuZFRhZ1wiIHx8IHRyZWUuZnJvbSA+PSBwYXJlbnQuZmlyc3RDaGlsZC50bykpXG4gICAgICAgICAgICBvcGVuLnB1c2godGFnTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBvcGVuO1xufVxuY29uc3QgaWRlbnRpZmllciA9IC9eWzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvO1xuZnVuY3Rpb24gY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZW5kID0gL1xccyo+Ly50ZXN0KHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDUpKSA/IFwiXCIgOiBcIj5cIjtcbiAgICByZXR1cm4geyBmcm9tLCB0byxcbiAgICAgICAgb3B0aW9uczogYWxsb3dlZENoaWxkcmVuKHN0YXRlLmRvYywgdHJlZSwgc2NoZW1hKS5tYXAodGFnTmFtZSA9PiAoeyBsYWJlbDogdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSkpLmNvbmNhdChvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpLm1hcCgodGFnLCBpKSA9PiAoeyBsYWJlbDogXCIvXCIgKyB0YWcsIGFwcGx5OiBcIi9cIiArIHRhZyArIGVuZCxcbiAgICAgICAgICAgIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSksXG4gICAgICAgIHZhbGlkRm9yOiAvXlxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8gfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVuZCA9IC9cXHMqPi8udGVzdChzdGF0ZS5zbGljZURvYyh0bywgdG8gKyA1KSkgPyBcIlwiIDogXCI+XCI7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IG9wZW5UYWdzKHN0YXRlLmRvYywgdHJlZSkubWFwKCh0YWcsIGkpID0+ICh7IGxhYmVsOiB0YWcsIGFwcGx5OiB0YWcgKyBlbmQsIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSxcbiAgICAgICAgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlU3RhcnRUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgbGV2ZWwgPSAwO1xuICAgIGZvciAobGV0IHRhZ05hbWUgb2YgYWxsb3dlZENoaWxkcmVuKHN0YXRlLmRvYywgdHJlZSwgc2NoZW1hKSlcbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IFwiPFwiICsgdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSk7XG4gICAgZm9yIChsZXQgb3BlbiBvZiBvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpKVxuICAgICAgICBvcHRpb25zLnB1c2goeyBsYWJlbDogXCI8L1wiICsgb3BlbiArIFwiPlwiLCB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gbGV2ZWwrKyB9KTtcbiAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG9wdGlvbnMsIHZhbGlkRm9yOiAvXjxcXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVsdCA9IGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpLCBpbmZvID0gZWx0ID8gc2NoZW1hLnRhZ3NbZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBlbHQpXSA6IG51bGw7XG4gICAgbGV0IG5hbWVzID0gKGluZm8gJiYgaW5mby5hdHRycyA/IE9iamVjdC5rZXlzKGluZm8uYXR0cnMpLmNvbmNhdChzY2hlbWEuZ2xvYmFsQXR0ck5hbWVzKSA6IHNjaGVtYS5nbG9iYWxBdHRyTmFtZXMpO1xuICAgIHJldHVybiB7IGZyb20sIHRvLFxuICAgICAgICBvcHRpb25zOiBuYW1lcy5tYXAoYXR0ck5hbWUgPT4gKHsgbGFiZWw6IGF0dHJOYW1lLCB0eXBlOiBcInByb3BlcnR5XCIgfSkpLFxuICAgICAgICB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xufVxuZnVuY3Rpb24gY29tcGxldGVBdHRyVmFsdWUoc3RhdGUsIHNjaGVtYSwgdHJlZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5hbWVOb2RlID0gKF9hID0gdHJlZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDaGlsZChcIkF0dHJpYnV0ZU5hbWVcIik7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgaWYgKG5hbWVOb2RlKSB7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IHN0YXRlLnNsaWNlRG9jKG5hbWVOb2RlLmZyb20sIG5hbWVOb2RlLnRvKTtcbiAgICAgICAgbGV0IGF0dHJzID0gc2NoZW1hLmdsb2JhbEF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRycykge1xuICAgICAgICAgICAgbGV0IGVsdCA9IGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpLCBpbmZvID0gZWx0ID8gc2NoZW1hLnRhZ3NbZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBlbHQpXSA6IG51bGw7XG4gICAgICAgICAgICBhdHRycyA9IChpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8uYXR0cnMpICYmIGluZm8uYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykudG9Mb3dlckNhc2UoKSwgcXVvdGVTdGFydCA9ICdcIicsIHF1b3RlRW5kID0gJ1wiJztcbiAgICAgICAgICAgIGlmICgvXlsnXCJdLy50ZXN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBiYXNlWzBdID09ICdcIicgPyAvXlteXCJdKiQvIDogL15bXiddKiQvO1xuICAgICAgICAgICAgICAgIHF1b3RlU3RhcnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHF1b3RlRW5kID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgMSkgPT0gYmFzZVswXSA/IFwiXCIgOiBiYXNlWzBdO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGZyb20rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gL15bXlxcczw+PSdcIl0qJC87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBhdHRycylcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goeyBsYWJlbDogdmFsdWUsIGFwcGx5OiBxdW90ZVN0YXJ0ICsgdmFsdWUgKyBxdW90ZUVuZCwgdHlwZTogXCJjb25zdGFudFwiIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvLCBvcHRpb25zLCB2YWxpZEZvcjogdG9rZW4gfTtcbn1cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uRm9yKHNjaGVtYSwgY29udGV4dCkge1xuICAgIGxldCB7IHN0YXRlLCBwb3MgfSA9IGNvbnRleHQsIGFyb3VuZCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpLCB0cmVlID0gYXJvdW5kLnJlc29sdmUocG9zLCAtMSk7XG4gICAgZm9yIChsZXQgc2NhbiA9IHBvcywgYmVmb3JlOyBhcm91bmQgPT0gdHJlZSAmJiAoYmVmb3JlID0gdHJlZS5jaGlsZEJlZm9yZShzY2FuKSk7KSB7XG4gICAgICAgIGxldCBsYXN0ID0gYmVmb3JlLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICFsYXN0LnR5cGUuaXNFcnJvciB8fCBsYXN0LmZyb20gPCBsYXN0LnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGFyb3VuZCA9IHRyZWUgPSBiZWZvcmU7XG4gICAgICAgIHNjYW4gPSBsYXN0LmZyb207XG4gICAgfVxuICAgIGlmICh0cmVlLm5hbWUgPT0gXCJUYWdOYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIC9DbG9zZVRhZyQvLnRlc3QodHJlZS5wYXJlbnQubmFtZSkgPyBjb21wbGV0ZUNsb3NlVGFnKHN0YXRlLCB0cmVlLCB0cmVlLmZyb20sIHBvcylcbiAgICAgICAgICAgIDogY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5mcm9tLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydFRhZ1wiKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZVRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBwb3MsIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyZWUubmFtZSA9PSBcIlN0YXJ0Q2xvc2VUYWdcIiB8fCB0cmVlLm5hbWUgPT0gXCJJbmNvbXBsZXRlQ2xvc2VUYWdcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVDbG9zZVRhZyhzdGF0ZSwgdHJlZSwgcG9zLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0LmV4cGxpY2l0ICYmICh0cmVlLm5hbWUgPT0gXCJPcGVuVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiU2VsZkNsb3NpbmdUYWdcIikgfHwgdHJlZS5uYW1lID09IFwiQXR0cmlidXRlTmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIiA/IHRyZWUuZnJvbSA6IHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiSXNcIiB8fCB0cmVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiIHx8IHRyZWUubmFtZSA9PSBcIlVucXVvdGVkQXR0cmlidXRlVmFsdWVcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVBdHRyVmFsdWUoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5uYW1lID09IFwiSXNcIiA/IHBvcyA6IHRyZWUuZnJvbSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dC5leHBsaWNpdCAmJiAoYXJvdW5kLm5hbWUgPT0gXCJFbGVtZW50XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJUZXh0XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJEb2N1bWVudFwiKSkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVTdGFydFRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG5IVE1MIHRhZyBjb21wbGV0aW9uLiBPcGVucyBhbmQgY2xvc2VzIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgaW4gYVxuY29udGV4dC1hd2FyZSB3YXkuXG4qL1xuZnVuY3Rpb24gaHRtbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIHJldHVybiBodG1sQ29tcGxldGlvbkZvcihTY2hlbWEuZGVmYXVsdCwgY29udGV4dCk7XG59XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gc291cmNlIGZvciBIVE1MIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbCB0YWdzXG5vciBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uU291cmNlV2l0aChjb25maWcpIHtcbiAgICBsZXQgeyBleHRyYVRhZ3MsIGV4dHJhR2xvYmFsQXR0cmlidXRlczogZXh0cmFBdHRycyB9ID0gY29uZmlnO1xuICAgIGxldCBzY2hlbWEgPSBleHRyYUF0dHJzIHx8IGV4dHJhVGFncyA/IG5ldyBTY2hlbWEoZXh0cmFUYWdzLCBleHRyYUF0dHJzKSA6IFNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gaHRtbENvbXBsZXRpb25Gb3Ioc2NoZW1hLCBjb250ZXh0KTtcbn1cblxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgSFRNTFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2h0bWwpLCBleHRlbmRlZCB3aXRoIHRoZVxuSmF2YVNjcmlwdCBhbmQgQ1NTIHBhcnNlcnMgdG8gcGFyc2UgdGhlIGNvbnRlbnQgb2YgYDxzY3JpcHQ+YCBhbmRcbmA8c3R5bGU+YCB0YWdzLlxuKi9cbmNvbnN0IGh0bWxMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBFbGVtZW50KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gL14oXFxzKikoPFxcLyk/Ly5leGVjKGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubm9kZS50byA8PSBjb250ZXh0LnBvcyArIGFmdGVyWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGFmdGVyWzJdID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBEb2N1bWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBvcyArIC9cXHMqLy5leGVjKGNvbnRleHQudGV4dEFmdGVyKVswXS5sZW5ndGggPCBjb250ZXh0Lm5vZGUudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kRWx0ID0gbnVsbCwgY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IGNvbnRleHQubm9kZTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC5uYW1lICE9IFwiRWxlbWVudFwiIHx8IGxhc3QudG8gIT0gY3VyLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRWx0ID0gY3VyID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRWx0ICYmICEoKGNsb3NlID0gZW5kRWx0Lmxhc3RDaGlsZCkgJiYgKGNsb3NlLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGNsb3NlLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGVuZEVsdC5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGZpcnN0Lm5hbWUgIT0gXCJPcGVuVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0Lm5hbWUgPT0gXCJDbG9zZVRhZ1wiID8gbGFzdC5mcm9tIDogbm9kZS50byB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIHdyYXA6IC8qQF9fUFVSRV9fKi9jb25maWd1cmVOZXN0aW5nKFtcbiAgICAgICAgICAgIHsgdGFnOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYXR0cnMudHlwZSB8fCAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmF8ZWNtYSlzY3JpcHQkfF5tb2R1bGUkfF4kL2kudGVzdChhdHRycy50eXBlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnNlcjogamF2YXNjcmlwdExhbmd1YWdlLnBhcnNlciB9LFxuICAgICAgICAgICAgeyB0YWc6IFwic3R5bGVcIixcbiAgICAgICAgICAgICAgICBhdHRycyhhdHRycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFhdHRycy5sYW5nIHx8IGF0dHJzLmxhbmcgPT0gXCJjc3NcIikgJiYgKCFhdHRycy50eXBlIHx8IC9eKHRleHRcXC8pPyh4LSk/KHN0eWxlc2hlZXR8Y3NzKSQvaS50ZXN0KGF0dHJzLnR5cGUpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnNlcjogY3NzTGFuZ3VhZ2UucGFyc2VyIH1cbiAgICAgICAgXSlcbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcIjwhLS1cIiwgY2xvc2U6IFwiLS0+XCIgfSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccyo8XFwvXFx3K1xcVyQvLFxuICAgICAgICB3b3JkQ2hhcnM6IFwiLS5fXCJcbiAgICB9XG59KTtcbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3IgSFRNTCwgaW5jbHVkaW5nXG5bYGh0bWxDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWh0bWwuaHRtbENvbXBsZXRpb24pIGFuZCBKYXZhU2NyaXB0IGFuZFxuQ1NTIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiovXG5mdW5jdGlvbiBodG1sKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGxhbmcgPSBodG1sTGFuZ3VhZ2U7XG4gICAgaWYgKGNvbmZpZy5tYXRjaENsb3NpbmdUYWdzID09PSBmYWxzZSlcbiAgICAgICAgbGFuZyA9IGxhbmcuY29uZmlndXJlKHsgZGlhbGVjdDogXCJub01hdGNoXCIgfSk7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQobGFuZywgW1xuICAgICAgICBodG1sTGFuZ3VhZ2UuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogaHRtbENvbXBsZXRpb25Tb3VyY2VXaXRoKGNvbmZpZykgfSksXG4gICAgICAgIGNvbmZpZy5hdXRvQ2xvc2VUYWdzICE9PSBmYWxzZSA/IGF1dG9DbG9zZVRhZ3MgOiBbXSxcbiAgICAgICAgamF2YXNjcmlwdCgpLnN1cHBvcnQsXG4gICAgICAgIGNzcygpLnN1cHBvcnRcbiAgICBdKTtcbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBjbG9zZSB0YWdzIHdoZW4gYSBgPmAgb3JcbmAvYCBpcyB0eXBlZC5cbiovXG5jb25zdCBhdXRvQ2xvc2VUYWdzID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgdGV4dCkgPT4ge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZyB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5IHx8IGZyb20gIT0gdG8gfHwgKHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIikgfHxcbiAgICAgICAgIWh0bWxMYW5ndWFnZS5pc0FjdGl2ZUF0KHZpZXcuc3RhdGUsIGZyb20sIC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGFyb3VuZC5uYW1lID09IFwiVGFnTmFtZVwiIHx8IGFyb3VuZC5uYW1lID09IFwiU3RhcnRUYWdcIilcbiAgICAgICAgICAgIGFyb3VuZCA9IGFyb3VuZC5wYXJlbnQ7XG4gICAgICAgIGlmICh0ZXh0ID09IFwiPlwiICYmIGFyb3VuZC5uYW1lID09IFwiT3BlblRhZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IGFyb3VuZC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiYgKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZS5kb2MsIGFyb3VuZC5wYXJlbnQsIGhlYWQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgMSksIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0OiBgPjwvJHtuYW1lfT5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiL1wiICYmIGFyb3VuZC5uYW1lID09IFwiT3BlblRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHkgPSBhcm91bmQucGFyZW50LCBiYXNlID0gZW1wdHkgPT09IG51bGwgfHwgZW1wdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtcHR5LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChlbXB0eS5mcm9tID09IGhlYWQgLSAxICYmICgoX2MgPSBiYXNlLmxhc3RDaGlsZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm5hbWUpICE9IFwiQ2xvc2VUYWdcIiAmJiAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZSwgaGVhZCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGAvJHtuYW1lfT5gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQgKyBpbnNlcnQubGVuZ3RoKSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgeyBhdXRvQ2xvc2VUYWdzLCBodG1sLCBodG1sQ29tcGxldGlvblNvdXJjZSwgaHRtbENvbXBsZXRpb25Tb3VyY2VXaXRoLCBodG1sTGFuZ3VhZ2UgfTtcbiIsImltcG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBwYXJzZU1peGVkIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc2NyaXB0VGV4dCA9IDUzLFxuICBTdGFydENsb3NlU2NyaXB0VGFnID0gMSxcbiAgc3R5bGVUZXh0ID0gNTQsXG4gIFN0YXJ0Q2xvc2VTdHlsZVRhZyA9IDIsXG4gIHRleHRhcmVhVGV4dCA9IDU1LFxuICBTdGFydENsb3NlVGV4dGFyZWFUYWcgPSAzLFxuICBTdGFydFRhZyA9IDQsXG4gIFN0YXJ0U2NyaXB0VGFnID0gNSxcbiAgU3RhcnRTdHlsZVRhZyA9IDYsXG4gIFN0YXJ0VGV4dGFyZWFUYWcgPSA3LFxuICBTdGFydFNlbGZDbG9zaW5nVGFnID0gOCxcbiAgU3RhcnRDbG9zZVRhZyA9IDksXG4gIE5vTWF0Y2hTdGFydENsb3NlVGFnID0gMTAsXG4gIE1pc21hdGNoZWRTdGFydENsb3NlVGFnID0gMTEsXG4gIG1pc3NpbmdDbG9zZVRhZyA9IDU2LFxuICBJbmNvbXBsZXRlQ2xvc2VUYWcgPSAxMixcbiAgY29tbWVudENvbnRlbnQkMSA9IDU3LFxuICBFbGVtZW50ID0gMTgsXG4gIFNjcmlwdFRleHQgPSAyNyxcbiAgU3R5bGVUZXh0ID0gMzAsXG4gIFRleHRhcmVhVGV4dCA9IDMzLFxuICBPcGVuVGFnID0gMzUsXG4gIERpYWxlY3Rfbm9NYXRjaCA9IDA7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBIVE1MLiAqL1xuXG5jb25zdCBzZWxmQ2xvc2VycyA9IHtcbiAgYXJlYTogdHJ1ZSwgYmFzZTogdHJ1ZSwgYnI6IHRydWUsIGNvbDogdHJ1ZSwgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsIGZyYW1lOiB0cnVlLCBocjogdHJ1ZSwgaW1nOiB0cnVlLCBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLCBsaW5rOiB0cnVlLCBtZXRhOiB0cnVlLCBwYXJhbTogdHJ1ZSwgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSwgd2JyOiB0cnVlLCBtZW51aXRlbTogdHJ1ZVxufTtcblxuY29uc3QgaW1wbGljaXRseUNsb3NlZCA9IHtcbiAgZGQ6IHRydWUsIGxpOiB0cnVlLCBvcHRncm91cDogdHJ1ZSwgb3B0aW9uOiB0cnVlLCBwOiB0cnVlLFxuICBycDogdHJ1ZSwgcnQ6IHRydWUsIHRib2R5OiB0cnVlLCB0ZDogdHJ1ZSwgdGZvb3Q6IHRydWUsXG4gIHRoOiB0cnVlLCB0cjogdHJ1ZVxufTtcblxuY29uc3QgY2xvc2VPbk9wZW4gPSB7XG4gIGRkOiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgZHQ6IHtkZDogdHJ1ZSwgZHQ6IHRydWV9LFxuICBsaToge2xpOiB0cnVlfSxcbiAgb3B0aW9uOiB7b3B0aW9uOiB0cnVlLCBvcHRncm91cDogdHJ1ZX0sXG4gIG9wdGdyb3VwOiB7b3B0Z3JvdXA6IHRydWV9LFxuICBwOiB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGRpcjogdHJ1ZSxcbiAgICBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLFxuICAgIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSwgaDY6IHRydWUsXG4gICAgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBtZW51OiB0cnVlLCBuYXY6IHRydWUsIG9sOiB0cnVlLFxuICAgIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHVsOiB0cnVlXG4gIH0sXG4gIHJwOiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgcnQ6IHtycDogdHJ1ZSwgcnQ6IHRydWV9LFxuICB0Ym9keToge3Rib2R5OiB0cnVlLCB0Zm9vdDogdHJ1ZX0sXG4gIHRkOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGZvb3Q6IHt0Ym9keTogdHJ1ZX0sXG4gIHRoOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGhlYWQ6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0cjoge3RyOiB0cnVlfVxufTtcblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjFcbn1cblxuZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT0gOSB8fCBjaCA9PSAxMCB8fCBjaCA9PSAxMyB8fCBjaCA9PSAzMlxufVxuXG5sZXQgY2FjaGVkTmFtZSA9IG51bGwsIGNhY2hlZElucHV0ID0gbnVsbCwgY2FjaGVkUG9zID0gMDtcbmZ1bmN0aW9uIHRhZ05hbWVBZnRlcihpbnB1dCwgb2Zmc2V0KSB7XG4gIGxldCBwb3MgPSBpbnB1dC5wb3MgKyBvZmZzZXQ7XG4gIGlmIChjYWNoZWRQb3MgPT0gcG9zICYmIGNhY2hlZElucHV0ID09IGlucHV0KSByZXR1cm4gY2FjaGVkTmFtZVxuICBsZXQgbmV4dCA9IGlucHV0LnBlZWsob2Zmc2V0KTtcbiAgd2hpbGUgKGlzU3BhY2UobmV4dCkpIG5leHQgPSBpbnB1dC5wZWVrKCsrb2Zmc2V0KTtcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgbmV4dCA9IGlucHV0LnBlZWsoKytvZmZzZXQpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCB0byBzaWduYWwgdGhlcmUncyBhIDw/IG9yIDwhLCBudWxsIGZvciBqdXN0IG1pc3NpbmdcbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDsgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBuZXh0ID09IHF1ZXN0aW9uIHx8IG5leHQgPT0gYmFuZyA/IHVuZGVmaW5lZCA6IG51bGxcbn1cblxuY29uc3QgbGVzc1RoYW4gPSA2MCwgZ3JlYXRlclRoYW4gPSA2Miwgc2xhc2ggPSA0NywgcXVlc3Rpb24gPSA2MywgYmFuZyA9IDMzLCBkYXNoID0gNDU7XG5cbmZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KG5hbWUsIHBhcmVudCkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5oYXNoID0gcGFyZW50ID8gcGFyZW50Lmhhc2ggOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHRoaXMuaGFzaCArPSAodGhpcy5oYXNoIDw8IDQpICsgbmFtZS5jaGFyQ29kZUF0KGkpICsgKG5hbWUuY2hhckNvZGVBdChpKSA8PCA4KTtcbn1cblxuY29uc3Qgc3RhcnRUYWdUZXJtcyA9IFtTdGFydFRhZywgU3RhcnRTZWxmQ2xvc2luZ1RhZywgU3RhcnRTY3JpcHRUYWcsIFN0YXJ0U3R5bGVUYWcsIFN0YXJ0VGV4dGFyZWFUYWddO1xuXG5jb25zdCBlbGVtZW50Q29udGV4dCA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBudWxsLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICByZXR1cm4gc3RhcnRUYWdUZXJtcy5pbmRleE9mKHRlcm0pID4gLTEgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBFbGVtZW50ICYmIGNvbnRleHQgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHRcbiAgfSxcbiAgcmV1c2UoY29udGV4dCwgbm9kZSwgc3RhY2ssIGlucHV0KSB7XG4gICAgbGV0IHR5cGUgPSBub2RlLnR5cGUuaWQ7XG4gICAgcmV0dXJuIHR5cGUgPT0gU3RhcnRUYWcgfHwgdHlwZSA9PSBPcGVuVGFnXG4gICAgICA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dFxuICB9LFxuICBoYXNoKGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0Lmhhc2ggOiAwIH0sXG4gIHN0cmljdDogZmFsc2Vcbn0pO1xuXG5jb25zdCB0YWdTdGFydCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ICE9IGxlc3NUaGFuKSB7XG4gICAgLy8gRW5kIG9mIGZpbGUsIGNsb3NlIGFueSBvcGVuIHRhZ3NcbiAgICBpZiAoaW5wdXQubmV4dCA8IDAgJiYgc3RhY2suY29udGV4dCkgaW5wdXQuYWNjZXB0VG9rZW4obWlzc2luZ0Nsb3NlVGFnKTtcbiAgICByZXR1cm5cbiAgfVxuICBpbnB1dC5hZHZhbmNlKCk7XG4gIGxldCBjbG9zZSA9IGlucHV0Lm5leHQgPT0gc2xhc2g7XG4gIGlmIChjbG9zZSkgaW5wdXQuYWR2YW5jZSgpO1xuICBsZXQgbmFtZSA9IHRhZ05hbWVBZnRlcihpbnB1dCwgMCk7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHJldHVyblxuICBpZiAoIW5hbWUpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihjbG9zZSA/IEluY29tcGxldGVDbG9zZVRhZyA6IFN0YXJ0VGFnKVxuXG4gIGxldCBwYXJlbnQgPSBzdGFjay5jb250ZXh0ID8gc3RhY2suY29udGV4dC5uYW1lIDogbnVsbDtcbiAgaWYgKGNsb3NlKSB7XG4gICAgaWYgKG5hbWUgPT0gcGFyZW50KSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRDbG9zZVRhZylcbiAgICBpZiAocGFyZW50ICYmIGltcGxpY2l0bHlDbG9zZWRbcGFyZW50XSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTIpXG4gICAgaWYgKHN0YWNrLmRpYWxlY3RFbmFibGVkKERpYWxlY3Rfbm9NYXRjaCkpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihOb01hdGNoU3RhcnRDbG9zZVRhZylcbiAgICBmb3IgKGxldCBjeCA9IHN0YWNrLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnBhcmVudCkgaWYgKGN4Lm5hbWUgPT0gbmFtZSkgcmV0dXJuXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oTWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcpO1xuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lID09IFwic2NyaXB0XCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFNjcmlwdFRhZylcbiAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFN0eWxlVGFnKVxuICAgIGlmIChuYW1lID09IFwidGV4dGFyZWFcIikgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0VGV4dGFyZWFUYWcpXG4gICAgaWYgKHNlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTZWxmQ2xvc2luZ1RhZylcbiAgICBpZiAocGFyZW50ICYmIGNsb3NlT25PcGVuW3BhcmVudF0gJiYgY2xvc2VPbk9wZW5bcGFyZW50XVtuYW1lXSkgaW5wdXQuYWNjZXB0VG9rZW4obWlzc2luZ0Nsb3NlVGFnLCAtMSk7XG4gICAgZWxzZSBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRhZyk7XG4gIH1cbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IGNvbW1lbnRDb250ZW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgZm9yIChsZXQgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbihjb21tZW50Q29udGVudCQxKTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGRhc2gpIHtcbiAgICAgIGRhc2hlcysrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA9PSBncmVhdGVyVGhhbiAmJiBkYXNoZXMgPj0gMikge1xuICAgICAgaWYgKGkgPiAzKSBpbnB1dC5hY2NlcHRUb2tlbihjb21tZW50Q29udGVudCQxLCAtMik7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXNoZXMgPSAwO1xuICAgIH1cbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb250ZW50VG9rZW5pemVyKHRhZywgdGV4dFRva2VuLCBlbmRUb2tlbikge1xuICBsZXQgbGFzdFN0YXRlID0gMiArIHRhZy5sZW5ndGg7XG4gIHJldHVybiBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICAgIC8vIHN0YXRlIG1lYW5zOlxuICAgIC8vIC0gMCBub3RoaW5nIG1hdGNoZWRcbiAgICAvLyAtIDEgJzwnIG1hdGNoZWRcbiAgICAvLyAtIDIgJzwvJyArIHBvc3NpYmx5IHdoaXRlc3BhY2UgbWF0Y2hlZFxuICAgIC8vIC0gMy0oMSt0YWcubGVuZ3RoKSBwYXJ0IG9mIHRoZSB0YWcgbWF0Y2hlZFxuICAgIC8vIC0gbGFzdFN0YXRlIHdob2xlIHRhZyArIHBvc3NpYmx5IHdoaXRlc3BhY2UgbWF0Y2hlZFxuICAgIGZvciAobGV0IHN0YXRlID0gMCwgbWF0Y2hlZExlbiA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICAgICAgaWYgKGkpIGlucHV0LmFjY2VwdFRva2VuKHRleHRUb2tlbik7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT0gMCAmJiBpbnB1dC5uZXh0ID09IGxlc3NUaGFuIHx8XG4gICAgICAgICAgc3RhdGUgPT0gMSAmJiBpbnB1dC5uZXh0ID09IHNsYXNoIHx8XG4gICAgICAgICAgc3RhdGUgPj0gMiAmJiBzdGF0ZSA8IGxhc3RTdGF0ZSAmJiBpbnB1dC5uZXh0ID09IHRhZy5jaGFyQ29kZUF0KHN0YXRlIC0gMikpIHtcbiAgICAgICAgc3RhdGUrKztcbiAgICAgICAgbWF0Y2hlZExlbisrO1xuICAgICAgfSBlbHNlIGlmICgoc3RhdGUgPT0gMiB8fCBzdGF0ZSA9PSBsYXN0U3RhdGUpICYmIGlzU3BhY2UoaW5wdXQubmV4dCkpIHtcbiAgICAgICAgbWF0Y2hlZExlbisrO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBsYXN0U3RhdGUgJiYgaW5wdXQubmV4dCA9PSBncmVhdGVyVGhhbikge1xuICAgICAgICBpZiAoaSA+IG1hdGNoZWRMZW4pXG4gICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGV4dFRva2VuLCAtbWF0Y2hlZExlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbihlbmRUb2tlbiwgLShtYXRjaGVkTGVuIC0gMikpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICgoaW5wdXQubmV4dCA9PSAxMCAvKiAnXFxuJyAqLyB8fCBpbnB1dC5uZXh0ID09IDEzIC8qICdcXHInICovKSAmJiBpKSB7XG4gICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRleHRUb2tlbiwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG1hdGNoZWRMZW4gPSAwO1xuICAgICAgfVxuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIH1cbiAgfSlcbn1cblxuY29uc3Qgc2NyaXB0VG9rZW5zID0gY29udGVudFRva2VuaXplcihcInNjcmlwdFwiLCBzY3JpcHRUZXh0LCBTdGFydENsb3NlU2NyaXB0VGFnKTtcblxuY29uc3Qgc3R5bGVUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwic3R5bGVcIiwgc3R5bGVUZXh0LCBTdGFydENsb3NlU3R5bGVUYWcpO1xuXG5jb25zdCB0ZXh0YXJlYVRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJ0ZXh0YXJlYVwiLCB0ZXh0YXJlYVRleHQsIFN0YXJ0Q2xvc2VUZXh0YXJlYVRhZyk7XG5cbmNvbnN0IGh0bWxIaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBcIlRleHQgUmF3VGV4dFwiOiB0YWdzLmNvbnRlbnQsXG4gIFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBTZWxmQ2xvc2VyRW5kVGFnIEVuZFRhZyBTZWxmQ2xvc2VFbmRUYWdcIjogdGFncy5hbmdsZUJyYWNrZXQsXG4gIFRhZ05hbWU6IHRhZ3MudGFnTmFtZSxcbiAgXCJNaXNtYXRjaGVkQ2xvc2VUYWcvVGFnTmFtZVwiOiBbdGFncy50YWdOYW1lLCAgdGFncy5pbnZhbGlkXSxcbiAgQXR0cmlidXRlTmFtZTogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWVcIjogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSXM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBcIkVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2VcIjogdGFncy5jaGFyYWN0ZXIsXG4gIENvbW1lbnQ6IHRhZ3MuYmxvY2tDb21tZW50LFxuICBQcm9jZXNzaW5nSW5zdDogdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gIERvY3R5cGVEZWNsOiB0YWdzLmRvY3VtZW50TWV0YVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIix4T1ZPeE9PTyFXUSFiTycjQ29PIV1RIWJPJyNDeU8hYlEhYk8nI0N8TyFnUSFiTycjRFBPIWxRIWJPJyNEUk8hcU9YTycjQ25PIXxPWU8nI0NuTyNYT1tPJyNDbk8kZU94TycjQ25PT09XJyNDbicjQ25PJGxPIXJPJyNEU08kdFEhYk8nI0RVTyR5USFiTycjRFZPT09XJyNEaicjRGpPT09XJyNEWCcjRFhRVk94T09PJU9RI3RPLDU5Wk8lV1EjdE8sNTllTyVgUSN0Tyw1OWhPJWhRI3RPLDU5a08lcFEjdE8sNTltT09PWCcjRF0nI0RdTyV4T1hPJyNDd08mVE9YTyw1OVlPT09ZJyNEXicjRF5PJl1PWU8nI0N6TyZoT1lPLDU5WU9PT1snI0RfJyNEX08mcE9bTycjQ31PJntPW08sNTlZT09PVycjRGAnI0RgTydUT3hPLDU5WU8nW1EhYk8nI0RRT09PVyw1OVksNTlZT09PYCcjRGEnI0RhTydhTyFyTyw1OW5PT09XLDU5biw1OW5PJ2lRIWJPLDU5cE8nblEhYk8sNTlxT09PVy1FN1YtRTdWTydzUSN0TycjQ3FPT1FPJyNEWScjRFlPKE9RI3RPMUcudU9PT1gxRy51MUcudU8oV1EjdE8xRy9QT09PWTFHL1AxRy9QTyhgUSN0TzFHL1NPT09bMUcvUzFHL1NPKGhRI3RPMUcvVk9PT1cxRy9WMUcvVk8ocFEjdE8xRy9YT09PVzFHL1gxRy9YT09PWC1FN1otRTdaTyh4USFiTycjQ3hPT09XMUcudDFHLnRPT09ZLUU3Wy1FN1tPKH1RIWJPJyNDe09PT1stRTddLUU3XU8pU1EhYk8nI0RPT09PVy1FN14tRTdeTylYUSFiTyw1OWxPT09gLUU3Xy1FN19PT09XMUcvWTFHL1lPT09XMUcvWzFHL1tPT09XMUcvXTFHL11PKV5RJmpPLDU5XU9PUU8tRTdXLUU3V09PT1g3KyRhNyskYU9PT1k3KyRrNyska09PT1s3KyRuNyskbk9PT1c3KyRxNyskcU9PT1c3KyRzNyskc08paVEhYk8sNTlkTyluUSFiTyw1OWdPKXNRIWJPLDU5ak9PT1cxRy9XMUcvV08peE8sVU8nI0N0TypaTzdbTycjQ3RPT1FPMUcudzFHLndPT09XMUcvTzFHL09PT09XMUcvUjFHL1JPT09XMUcvVTFHL1VPT09PJyNEWicjRFpPKmxPLFVPLDU5YE9PUU8sNTlgLDU5YE9PT08nI0RbJyNEW08qfU83W08sNTlgT09PTy1FN1gtRTdYT09RTzFHLnoxRy56T09PTy1FN1ktRTdZXCIsXG4gIHN0YXRlRGF0YTogXCIraH5PIV1PU35PU1NPVFBPVVFPVlJPV1RPWV1PWltPW15PXl5PX15PYF5PYV5Pd15Pel9PIWNaT35PZGFPfk9kYk9+T2RjT35PZGRPfk9kZU9+TyFWZk9Qa1AhWWtQfk8hV2lPUW5QIVluUH5PIVhsT1JxUCFZcVB+T1NTT1RQT1VRT1ZST1dUT1hxT1ldT1pbT1teT15eT19eT2BeT2FeT3deTyFjWk9+TyFZck9+UCNkTyFac08hZHVPfk9kdk9+T2R3T35PZnlPanxPfk9meU9qIU9Pfk9meU9qIVFPfk9meU9qIVNPfk9meU9qIVVPfk8hVmZPUGtYIVlrWH5PUCFXTyFZIVhPfk8hV2lPUW5YIVluWH5PUSFaTyFZIVhPfk8hWGxPUnFYIVlxWH5PUiFdTyFZIVhPfk8hWSFYT35QI2RPZCFfT35PIVpzTyFkIWFPfk9qIWJPfk9qIWNPfk9nIWRPZmVYamVYfk9meU9qIWZPfk9meU9qIWdPfk9meU9qIWhPfk9meU9qIWlPfk9meU9qIWpPfk9kIWtPfk9kIWxPfk9kIW1Pfk9qIW5Pfk9pIXFPIV8hb08hYSFwT35PaiFyT35PaiFzT35PaiF0T35PXyF1T2AhdU9hIXVPIV8hd08hYCF1T35PXyF4T2AheE9hIXhPIWEhd08hYiF4T35PXyF1T2AhdU9hIXVPIV8he08hYCF1T35PXyF4T2AheE9hIXhPIWEhe08hYiF4T35PYF9hIWN3eiFjflwiLFxuICBnb3RvOiBcIiVvIV9QUFBQUFBQUFBQUFBQUFBQUFAhYCFmUCFsUFAheFBQIXsjTyNSI1gjWyNfI2UjaCNrI3EjdyFgUCFgIWBQI30kVCRrJHEkdyR9JVQlWiVhUFBQUFBQUFAlZ1heT1hgcFhVT1hgcGV6YWJjZGV7fSFQIVIhVFIhcSFkUmhVUiFYaFhWT1hgcFJrVlIhWGtYV09YYHBSbldSIVhuWFhPWGBwUXJYUiFYcFhZT1hgcFFgT1J4YFF7YVF9YlEhUGNRIVJkUSFUZVohZXt9IVAhUiFUUSF2IW9SIXohdlEheSFwUiF8IXlRZ1VSIVZnUWpWUiFZalFtV1IhW21RcFhSIV5wUXRaUiFgdFNfT2BUb1hwXCIsXG4gIG5vZGVOYW1lczogXCLimqAgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgSW5jb21wbGV0ZUNsb3NlVGFnIERvY3VtZW50IFRleHQgRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZSBJbnZhbGlkRW50aXR5IEVsZW1lbnQgT3BlblRhZyBUYWdOYW1lIEF0dHJpYnV0ZSBBdHRyaWJ1dGVOYW1lIElzIEF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgRW5kVGFnIFNjcmlwdFRleHQgQ2xvc2VUYWcgT3BlblRhZyBTdHlsZVRleHQgQ2xvc2VUYWcgT3BlblRhZyBUZXh0YXJlYVRleHQgQ2xvc2VUYWcgT3BlblRhZyBDbG9zZVRhZyBTZWxmQ2xvc2luZ1RhZyBDb21tZW50IFByb2Nlc3NpbmdJbnN0IE1pc21hdGNoZWRDbG9zZVRhZyBDbG9zZVRhZyBEb2N0eXBlRGVjbFwiLFxuICBtYXhUZXJtOiA2NixcbiAgY29udGV4dDogZWxlbWVudENvbnRleHQsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImNsb3NlZEJ5XCIsIC0xMSwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSxcIkVuZFRhZ1wiLC00LDE5LDI5LDMyLDM1LFwiQ2xvc2VUYWdcIl0sXG4gICAgW1wiZ3JvdXBcIiwgLTksMTIsMTUsMTYsMTcsMTgsMzgsMzksNDAsNDEsXCJFbnRpdHlcIiwxNCxcIkVudGl0eSBUZXh0Q29udGVudFwiLC0zLDI3LDMwLDMzLFwiVGV4dENvbnRlbnQgRW50aXR5XCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDI2LFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZ1wiLC00LDI4LDMxLDM0LDM2LFwiT3BlblRhZ1wiXVxuICBdLFxuICBwcm9wU291cmNlczogW2h0bWxIaWdobGlnaHRpbmddLFxuICBza2lwcGVkTm9kZXM6IFswXSxcbiAgcmVwZWF0Tm9kZUNvdW50OiA5LFxuICB0b2tlbkRhdGE6IFwiISNiIWFSIVdPWCRrWFkpc1laKXNaXSRrXV4pc15wJGtwcSlzcXIka3JzKnpzdiRrdncrZHd4Mnl4fSRrfSFPM2YhTyFQJGshUCFRN18hUSFbJGshWyFdOHUhXSFeJGshXiFfPmIhXyFgISFwIWAhYThUIWEhYyRrIWMhfTh1IX0jUiRrI1IjUzh1I1MjVCRrI1Qjbzh1I28kZiRrJGYkZyZSJGclVyRrJVclbzh1JW8lcCRrJXAmYTh1JmEmYiRrJmIxcDh1MXA0VSRrNFU0ZDh1NGQ0ZSRrNGUkSVM4dSRJUyRJYCRrJElgJEliOHUkSWIkS2gkayRLaCUjdDh1JSN0Ji94JGsmL3gmRXQ4dSZFdCZGViRrJkZWOydTOHU7J1M7Omo8dDs6aj8mciRrPyZyP0FoOHU/QWg/Qlkkaz9CWT9Nbjh1P01ufiRrIVokdmNeUGlXIWBgIWJwT1gka1haJlJaXSRrXV4mUl5wJGtwcSZScXIka3JzJnFzdiRrdncpUnd4J3J4IVAkayFQIVEmUiFRIV4kayFeIV8oayFfIWEmUiFhJGYkayRmJGcmUiRnfiRrIVImW1ZeUCFgYCFicE9yJlJycyZxc3YmUnd4J3J4IV4mUiFeIV8oayFffiZScSZ4VF5QIWJwT3YmcXd4J1h4IV4mcSFeIV8nZyFffiZxUCdeUl5QT3YnWHchXidYIV9+J1hwJ2xRIWJwT3YnZ3h+J2dhJ3lVXlAhYGBPcidycnMnWHN2J3J3IV4nciFeIV8oXSFffidyYChiUiFgYE9yKF1zdihdd34oXSFRKHJUIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXh+KGtXKVdYaVdPWClSWl0pUl5wKVJxcilSc3cpUnghUClSIVEhXilSIWEkZilSJGd+KVIhYSpPXl5QIWBgIWJwIV1eT1gmUlhZKXNZWilzWl0mUl1eKXNecCZScHEpc3FyJlJycyZxc3YmUnd4J3J4IV4mUiFeIV8oayFffiZSIVorVFQhX2heUCFicE92JnF3eCdYeCFeJnEhXiFfJ2chX34mcSFaK2tiaVdhIVJPWCxzWFouUVpdLHNdXi5RXnAsc3FyLHNycy5Rc3QvXXR3LHN3eC5ReCFQLHMhUCFRLlEhUSFdLHMhXSFeKVIhXiFhLlEhYSRmLHMkZiRnLlEkZ34scyFaLHhiaVdPWCxzWFouUVpdLHNdXi5RXnAsc3FyLHNycy5Rc3QpUnR3LHN3eC5ReCFQLHMhUCFRLlEhUSFdLHMhXSFeLmkhXiFhLlEhYSRmLHMkZiRnLlEkZ34scyFSLlRUT3AuUXFzLlF0IV0uUSFdIV4uZCFefi5RIVIuaU9fIVIhWi5wWGlXXyFST1gpUlpdKVJecClScXIpUnN3KVJ4IVApUiFRIV4pUiFhJGYpUiRnfilSIVovYmFpV09YMGdYWjFxWl0wZ11eMXFecDBncXIwZ3JzMXFzdzBnd3gxcXghUDBnIVAhUTFxIVEhXTBnIV0hXilSIV4hYTFxIWEkZjBnJGYkZzFxJGd+MGchWjBsYWlXT1gwZ1haMXFaXTBnXV4xcV5wMGdxcjBncnMxcXN3MGd3eDFxeCFQMGchUCFRMXEhUSFdMGchXSFeMlYhXiFhMXEhYSRmMGckZiRnMXEkZ34wZyFSMXRTT3AxcXEhXTFxIV0hXjJRIV5+MXEhUjJWT2AhUiFaMl5YaVdgIVJPWClSWl0pUl5wKVJxcilSc3cpUnghUClSIVEhXilSIWEkZilSJGd+KVIhWjNTVSFheF5QIWBgT3IncnJzJ1hzdidydyFeJ3IhXiFfKF0hX34nciFdM3FlXlBpVyFgYCFicE9YJGtYWiZSWl0ka11eJlJecCRrcHEmUnFyJGtycyZxc3Yka3Z3KVJ3eCdyeH0ka30hTzVTIU8hUCRrIVAhUSZSIVEhXiRrIV4hXyhrIV8hYSZSIWEkZiRrJGYkZyZSJGd+JGshXTVfZF5QaVchYGAhYnBPWCRrWFomUlpdJGtdXiZSXnAka3BxJlJxciRrcnMmcXN2JGt2dylSd3gncnghUCRrIVAhUSZSIVEhXiRrIV4hXyhrIV8hYCZSIWAhYTZtIWEkZiRrJGYkZyZSJGd+JGshVDZ4Vl5QIWBgIWJwIWRRT3ImUnJzJnFzdiZSd3gncnghXiZSIV4hXyhrIV9+JlIhWDdoWF5QIWBgIWJwT3ImUnJzJnFzdiZSd3gncnghXiZSIV4hXyhrIV8hYCZSIWAhYThUIWF+JlIhWDhgVmpVXlAhYGAhYnBPciZScnMmcXN2JlJ3eCdyeCFeJlIhXiFfKGshX34mUiFhOVUhWWZTZFFeUGlXIWBgIWJwT1gka1haJlJaXSRrXV4mUl5wJGtwcSZScXIka3JzJnFzdiRrdncpUnd4J3J4fSRrfSFPOHUhTyFQOHUhUCFRJlIhUSFbOHUhWyFdOHUhXSFeJGshXiFfKGshXyFhJlIhYSFjJGshYyF9OHUhfSNSJGsjUiNTOHUjUyNUJGsjVCNvOHUjbyRmJGskZiRnJlIkZyR9JGskfSVPOHUlTyVXJGslVyVvOHUlbyVwJGslcCZhOHUmYSZiJGsmYjFwOHUxcDRVOHU0VTRkOHU0ZDRlJGs0ZSRJUzh1JElTJElgJGskSWAkSWI4dSRJYiRKZSRrJEplJEpnOHUkSmckS2gkayRLaCUjdDh1JSN0Ji94JGsmL3gmRXQ4dSZFdCZGViRrJkZWOydTOHU7J1M7Omo8dDs6aj8mciRrPyZyP0FoOHU/QWg/Qlkkaz9CWT9Nbjh1P01ufiRrIWE9UGVeUGlXIWBgIWJwT1gka1haJlJaXSRrXV4mUl5wJGtwcSZScXIka3JzJnFzdiRrdncpUnd4J3J4IVAkayFQIVEmUiFRIV4kayFeIV8oayFfIWEmUiFhJGYkayRmJGcmUiRnOz1gJGs7PWA8JWw4dTwlbH4kayFSPmlXIWBgIWJwT3Eoa3FyP1Jycydnc3Yoa3d4KF14IWEoayFhIWJLaiFifihrIVI/WVohYGAhYnBPcihrcnMnZ3N2KGt3eChdeH0oa30hTz97IU8hZihrIWYhZ0FSIWcjVyhrI1cjWEd6I1h+KGshUkBTViFgYCFicE9yKGtycydnc3Yoa3d4KF14fShrfSFPQGkhT34oayFSQHJUIWBgIWJwIWNQT3Ioa3JzJ2dzdihrd3goXXh+KGshUkFZViFgYCFicE9yKGtycydnc3Yoa3d4KF14IXEoayFxIXJBbyFyfihrIVJBdlYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCFlKGshZSFmQl0hZn4oayFSQmRWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXghdihrIXYhd0J5IXd+KGshUkNRViFgYCFicE9yKGtycydnc3Yoa3d4KF14IXsoayF7IXxDZyF8fihrIVJDblYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCFyKGshciFzRFQhc34oayFSRFtWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXghZyhrIWchaERxIWh+KGshUkR4VyFgYCFicE9yRHFyc0Vic3ZEcXZ3RXZ3eEZmeCFgRHEhYCFhR2IhYX5EcXFFZ1QhYnBPdkVidnhFdnghYEViIWAhYUZYIWF+RWJQRXlSTyFgRXYhYCFhRlMhYX5FdlBGWE96UHFGYFEhYnB6UE92J2d4fidnYUZrViFgYE9yRmZyc0V2c3ZGZnZ3RXZ3IWBGZiFgIWFHUSFhfkZmYUdYUiFgYHpQT3IoXXN2KF13fihdIVJHa1QhYGAhYnB6UE9yKGtycydnc3Yoa3d4KF14fihrIVJIUlYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCNjKGsjYyNkSGgjZH4oayFSSG9WIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXgjVihrI1YjV0lVI1d+KGshUkldViFgYCFicE9yKGtycydnc3Yoa3d4KF14I2goayNoI2lJciNpfihrIVJJeVYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCNtKGsjbSNuSmAjbn4oayFSSmdWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXgjZChrI2QjZUp8I2V+KGshUktUViFgYCFicE9yKGtycydnc3Yoa3d4KF14I1goayNYI1lEcSNZfihrIVJLcVchYGAhYnBPcktqcnNMWnN2S2p2d0xvd3hOUHghYUtqIWEhYiEgZyFifktqcUxgVCFicE92TFp2eExveCFhTFohYSFiTV4hYn5MWlBMclJPIWFMbyFhIWJMeyFifkxvUE1PUk8hYExvIWAhYU1YIWF+TG9QTV5Pd1BxTWNUIWJwT3ZMWnZ4TG94IWBMWiFgIWFNciFhfkxacU15USFicHdQT3YnZ3h+J2dhTlVWIWBgT3JOUHJzTG9zdk5QdndMb3chYU5QIWEhYk5rIWJ+TlBhTnBWIWBgT3JOUHJzTG9zdk5QdndMb3chYE5QIWAhYSEgViFhfk5QYSEgXlIhYGB3UE9yKF1zdihdd34oXSFSISBuVyFgYCFicE9yS2pyc0xac3ZLanZ3TG93eE5QeCFgS2ohYCFhISFXIWF+S2ohUiEhYVQhYGAhYnB3UE9yKGtycydnc3Yoa3d4KF14fihrIVYhIXtWZ1NeUCFgYCFicE9yJlJycyZxc3YmUnd4J3J4IV4mUiFeIV8oayFffiZSXCIsXG4gIHRva2VuaXplcnM6IFtzY3JpcHRUb2tlbnMsIHN0eWxlVG9rZW5zLCB0ZXh0YXJlYVRva2VucywgdGFnU3RhcnQsIGNvbW1lbnRDb250ZW50LCAwLCAxLCAyLCAzLCA0LCA1XSxcbiAgdG9wUnVsZXM6IHtcIkRvY3VtZW50XCI6WzAsMTNdfSxcbiAgZGlhbGVjdHM6IHtub01hdGNoOiAwfSxcbiAgdG9rZW5QcmVjOiA0NzZcbn0pO1xuXG5mdW5jdGlvbiBnZXRBdHRycyhlbGVtZW50LCBpbnB1dCkge1xuICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBhdHQgb2YgZWxlbWVudC5maXJzdENoaWxkLmdldENoaWxkcmVuKFwiQXR0cmlidXRlXCIpKSB7XG4gICAgbGV0IG5hbWUgPSBhdHQuZ2V0Q2hpbGQoXCJBdHRyaWJ1dGVOYW1lXCIpLCB2YWx1ZSA9IGF0dC5nZXRDaGlsZChcIkF0dHJpYnV0ZVZhbHVlXCIpIHx8IGF0dC5nZXRDaGlsZChcIlVucXVvdGVkQXR0cmlidXRlVmFsdWVcIik7XG4gICAgaWYgKG5hbWUpIGF0dHJzW2lucHV0LnJlYWQobmFtZS5mcm9tLCBuYW1lLnRvKV0gPVxuICAgICAgIXZhbHVlID8gXCJcIiA6IHZhbHVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiID8gaW5wdXQucmVhZCh2YWx1ZS5mcm9tICsgMSwgdmFsdWUudG8gLSAxKSA6IGlucHV0LnJlYWQodmFsdWUuZnJvbSwgdmFsdWUudG8pO1xuICB9XG4gIHJldHVybiBhdHRyc1xufVxuXG5mdW5jdGlvbiBtYXliZU5lc3Qobm9kZSwgaW5wdXQsIHRhZ3MpIHtcbiAgbGV0IGF0dHJzO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGlmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhub2RlLm5vZGUucGFyZW50LCBpbnB1dCkpKSlcbiAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIHRhZ3M6IHtcbi8vICAgdGFnOiBcInNjcmlwdFwiIHwgXCJzdHlsZVwiIHwgXCJ0ZXh0YXJlYVwiLFxuLy8gICBhdHRycz86ICh7W2F0dHI6IHN0cmluZ106IHN0cmluZ30pID0+IGJvb2xlYW4sXG4vLyAgIHBhcnNlcjogUGFyc2VyXG4vLyB9W11cbiBcbmZ1bmN0aW9uIGNvbmZpZ3VyZU5lc3RpbmcodGFncykge1xuICBsZXQgc2NyaXB0ID0gW10sIHN0eWxlID0gW10sIHRleHRhcmVhID0gW107XG4gIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgbGV0IGFycmF5ID0gdGFnLnRhZyA9PSBcInNjcmlwdFwiID8gc2NyaXB0IDogdGFnLnRhZyA9PSBcInN0eWxlXCIgPyBzdHlsZSA6IHRhZy50YWcgPT0gXCJ0ZXh0YXJlYVwiID8gdGV4dGFyZWEgOiBudWxsO1xuICAgIGlmICghYXJyYXkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT25seSBzY3JpcHQsIHN0eWxlLCBhbmQgdGV4dGFyZWEgdGFncyBjYW4gaG9zdCBuZXN0ZWQgcGFyc2Vyc1wiKVxuICAgIGFycmF5LnB1c2godGFnKTtcbiAgfVxuICByZXR1cm4gcGFyc2VNaXhlZCgobm9kZSwgaW5wdXQpID0+IHtcbiAgICBsZXQgaWQgPSBub2RlLnR5cGUuaWQ7XG4gICAgaWYgKGlkID09IFNjcmlwdFRleHQpIHJldHVybiBtYXliZU5lc3Qobm9kZSwgaW5wdXQsIHNjcmlwdClcbiAgICBpZiAoaWQgPT0gU3R5bGVUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzdHlsZSlcbiAgICBpZiAoaWQgPT0gVGV4dGFyZWFUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCB0ZXh0YXJlYSlcbiAgICByZXR1cm4gbnVsbFxuICB9KVxufVxuXG5leHBvcnQgeyBjb25maWd1cmVOZXN0aW5nLCBwYXJzZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==