"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_julia_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/julia.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/julia.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "julia": () => (/* binding */ julia)
/* harmony export */ });
function wordRegexp(words, end, pre) {
  if (typeof pre === "undefined") pre = "";
  if (typeof end === "undefined") { end = "\\b"; }
  return new RegExp("^" + pre + "((" + words.join(")|(") + "))" + end);
}

var octChar = "\\\\[0-7]{1,3}";
var hexChar = "\\\\x[A-Fa-f0-9]{1,2}";
var sChar = "\\\\[abefnrtv0%?'\"\\\\]";
var uChar = "([^\\u0027\\u005C\\uD800-\\uDFFF]|[\\uD800-\\uDFFF][\\uDC00-\\uDFFF])";

var asciiOperatorsList = [
  "[<>]:", "[<>=]=", "<<=?", ">>>?=?", "=>", "--?>", "<--[->]?", "\\/\\/",
  "\\.{2,3}", "[\\.\\\\%*+\\-<>!\\/^|&]=?", "\\?", "\\$", "~", ":"
];
var operators = wordRegexp([
  "[<>]:", "[<>=]=", "[!=]==", "<<=?", ">>>?=?", "=>?", "--?>", "<--[->]?", "\\/\\/",
  "[\\\\%*+\\-<>!\\/^|&\\u00F7\\u22BB]=?", "\\?", "\\$", "~", ":",
  "\\u00D7", "\\u2208", "\\u2209", "\\u220B", "\\u220C", "\\u2218",
  "\\u221A", "\\u221B", "\\u2229", "\\u222A", "\\u2260", "\\u2264",
  "\\u2265", "\\u2286", "\\u2288", "\\u228A", "\\u22C5",
  "\\b(in|isa)\\b(?!\.?\\()"
], "");
var delimiters = /^[;,()[\]{}]/;
var identifiers = /^[_A-Za-z\u00A1-\u2217\u2219-\uFFFF][\w\u00A1-\u2217\u2219-\uFFFF]*!*/;

var chars = wordRegexp([octChar, hexChar, sChar, uChar], "'");

var openersList = ["begin", "function", "type", "struct", "immutable", "let",
                   "macro", "for", "while", "quote", "if", "else", "elseif", "try",
                   "finally", "catch", "do"];

var closersList = ["end", "else", "elseif", "catch", "finally"];

var keywordsList = ["if", "else", "elseif", "while", "for", "begin", "let",
                    "end", "do", "try", "catch", "finally", "return", "break", "continue",
                    "global", "local", "const", "export", "import", "importall", "using",
                    "function", "where", "macro", "module", "baremodule", "struct", "type",
                    "mutable", "immutable", "quote", "typealias", "abstract", "primitive",
                    "bitstype"];

var builtinsList = ["true", "false", "nothing", "NaN", "Inf"];

var openers = wordRegexp(openersList);
var closers = wordRegexp(closersList);
var keywords = wordRegexp(keywordsList);
var builtins = wordRegexp(builtinsList);

var macro = /^@[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
var symbol = /^:[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
var stringPrefixes = /^(`|([_A-Za-z\u00A1-\uFFFF]*"("")?))/;

var macroOperators = wordRegexp(asciiOperatorsList, "", "@");
var symbolOperators = wordRegexp(asciiOperatorsList, "", ":");

function inArray(state) {
  return (state.nestedArrays > 0);
}

function inGenerator(state) {
  return (state.nestedGenerators > 0);
}

function currentScope(state, n) {
  if (typeof(n) === "undefined") { n = 0; }
  if (state.scopes.length <= n) {
    return null;
  }
  return state.scopes[state.scopes.length - (n + 1)];
}

// tokenizers
function tokenBase(stream, state) {
  // Handle multiline comments
  if (stream.match('#=', false)) {
    state.tokenize = tokenComment;
    return state.tokenize(stream, state);
  }

  // Handle scope changes
  var leavingExpr = state.leavingExpr;
  if (stream.sol()) {
    leavingExpr = false;
  }
  state.leavingExpr = false;

  if (leavingExpr) {
    if (stream.match(/^'+/)) {
      return "operator";
    }
  }

  if (stream.match(/\.{4,}/)) {
    return "error";
  } else if (stream.match(/\.{1,3}/)) {
    return "operator";
  }

  if (stream.eatSpace()) {
    return null;
  }

  var ch = stream.peek();

  // Handle single line comments
  if (ch === '#') {
    stream.skipToEnd();
    return "comment";
  }

  if (ch === '[') {
    state.scopes.push('[');
    state.nestedArrays++;
  }

  if (ch === '(') {
    state.scopes.push('(');
    state.nestedGenerators++;
  }

  if (inArray(state) && ch === ']') {
    while (state.scopes.length && currentScope(state) !== "[") { state.scopes.pop(); }
    state.scopes.pop();
    state.nestedArrays--;
    state.leavingExpr = true;
  }

  if (inGenerator(state) && ch === ')') {
    while (state.scopes.length && currentScope(state) !== "(") { state.scopes.pop(); }
    state.scopes.pop();
    state.nestedGenerators--;
    state.leavingExpr = true;
  }

  if (inArray(state)) {
    if (state.lastToken == "end" && stream.match(':')) {
      return "operator";
    }
    if (stream.match('end')) {
      return "number";
    }
  }

  var match;
  if (match = stream.match(openers, false)) {
    state.scopes.push(match[0]);
  }

  if (stream.match(closers, false)) {
    state.scopes.pop();
  }

  // Handle type annotations
  if (stream.match(/^::(?![:\$])/)) {
    state.tokenize = tokenAnnotation;
    return state.tokenize(stream, state);
  }

  // Handle symbols
  if (!leavingExpr && (stream.match(symbol) || stream.match(symbolOperators))) {
    return "builtin";
  }

  // Handle parametric types
  //if (stream.match(/^{[^}]*}(?=\()/)) {
  //  return "builtin";
  //}

  // Handle operators and Delimiters
  if (stream.match(operators)) {
    return "operator";
  }

  // Handle Number Literals
  if (stream.match(/^\.?\d/, false)) {
    var imMatcher = RegExp(/^im\b/);
    var numberLiteral = false;
    if (stream.match(/^0x\.[0-9a-f_]+p[\+\-]?[_\d]+/i)) { numberLiteral = true; }
    // Integers
    if (stream.match(/^0x[0-9a-f_]+/i)) { numberLiteral = true; } // Hex
    if (stream.match(/^0b[01_]+/i)) { numberLiteral = true; } // Binary
    if (stream.match(/^0o[0-7_]+/i)) { numberLiteral = true; } // Octal
    // Floats
    if (stream.match(/^(?:(?:\d[_\d]*)?\.(?!\.)(?:\d[_\d]*)?|\d[_\d]*\.(?!\.)(?:\d[_\d]*))?([Eef][\+\-]?[_\d]+)?/i)) { numberLiteral = true; }
    if (stream.match(/^\d[_\d]*(e[\+\-]?\d+)?/i)) { numberLiteral = true; } // Decimal
    if (numberLiteral) {
      // Integer literals may be "long"
      stream.match(imMatcher);
      state.leavingExpr = true;
      return "number";
    }
  }

  // Handle Chars
  if (stream.match("'")) {
    state.tokenize = tokenChar;
    return state.tokenize(stream, state);
  }

  // Handle Strings
  if (stream.match(stringPrefixes)) {
    state.tokenize = tokenStringFactory(stream.current());
    return state.tokenize(stream, state);
  }

  if (stream.match(macro) || stream.match(macroOperators)) {
    return "meta";
  }

  if (stream.match(delimiters)) {
    return null;
  }

  if (stream.match(keywords)) {
    return "keyword";
  }

  if (stream.match(builtins)) {
    return "builtin";
  }

  var isDefinition = state.isDefinition || state.lastToken == "function" ||
      state.lastToken == "macro" || state.lastToken == "type" ||
      state.lastToken == "struct" || state.lastToken == "immutable";

  if (stream.match(identifiers)) {
    if (isDefinition) {
      if (stream.peek() === '.') {
        state.isDefinition = true;
        return "variable";
      }
      state.isDefinition = false;
      return "def";
    }
    state.leavingExpr = true;
    return "variable";
  }

  // Handle non-detected items
  stream.next();
  return "error";
}

function tokenAnnotation(stream, state) {
  stream.match(/.*?(?=[,;{}()=\s]|$)/);
  if (stream.match('{')) {
    state.nestedParameters++;
  } else if (stream.match('}') && state.nestedParameters > 0) {
    state.nestedParameters--;
  }
  if (state.nestedParameters > 0) {
    stream.match(/.*?(?={|})/) || stream.next();
  } else if (state.nestedParameters == 0) {
    state.tokenize = tokenBase;
  }
  return "builtin";
}

function tokenComment(stream, state) {
  if (stream.match('#=')) {
    state.nestedComments++;
  }
  if (!stream.match(/.*?(?=(#=|=#))/)) {
    stream.skipToEnd();
  }
  if (stream.match('=#')) {
    state.nestedComments--;
    if (state.nestedComments == 0)
      state.tokenize = tokenBase;
  }
  return "comment";
}

function tokenChar(stream, state) {
  var isChar = false, match;
  if (stream.match(chars)) {
    isChar = true;
  } else if (match = stream.match(/\\u([a-f0-9]{1,4})(?=')/i)) {
    var value = parseInt(match[1], 16);
    if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)
      isChar = true;
      stream.next();
    }
  } else if (match = stream.match(/\\U([A-Fa-f0-9]{5,8})(?=')/)) {
    var value = parseInt(match[1], 16);
    if (value <= 1114111) { // U+10FFFF
      isChar = true;
      stream.next();
    }
  }
  if (isChar) {
    state.leavingExpr = true;
    state.tokenize = tokenBase;
    return "string";
  }
  if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }
  if (stream.match("'")) { state.tokenize = tokenBase; }
  return "error";
}

function tokenStringFactory(delimiter) {
  if (delimiter.substr(-3) === '"""') {
    delimiter = '"""';
  } else if (delimiter.substr(-1) === '"') {
    delimiter = '"';
  }
  function tokenString(stream, state) {
    if (stream.eat('\\')) {
      stream.next();
    } else if (stream.match(delimiter)) {
      state.tokenize = tokenBase;
      state.leavingExpr = true;
      return "string";
    } else {
      stream.eat(/[`"]/);
    }
    stream.eatWhile(/[^\\`"]/);
    return "string";
  }
  return tokenString;
}

const julia = {
  startState: function() {
    return {
      tokenize: tokenBase,
      scopes: [],
      lastToken: null,
      leavingExpr: false,
      isDefinition: false,
      nestedArrays: 0,
      nestedComments: 0,
      nestedGenerators: 0,
      nestedParameters: 0,
      firstParenPos: -1
    };
  },

  token: function(stream, state) {
    var style = state.tokenize(stream, state);
    var current = stream.current();

    if (current && style) {
      state.lastToken = current;
    }

    return style;
  },

  indent: function(state, textAfter, cx) {
    var delta = 0;
    if ( textAfter === ']' || textAfter === ')' || /^end\b/.test(textAfter) ||
         /^else/.test(textAfter) || /^catch\b/.test(textAfter) || /^elseif\b/.test(textAfter) ||
         /^finally/.test(textAfter) ) {
      delta = -1;
    }
    return (state.scopes.length + delta) * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*(end|else|catch|finally)\b$/,
    commentTokens: {line: "#", block: {open: "#=", close: "=#"}},
    closeBrackets: {brackets: ["(", "[", "{", '"']},
    autocomplete: keywordsList.concat(builtinsList)
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9qdWxpYV9qcy41NTA3ZmVmOTBmM2Q4YjcxMGQ4YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBLHlCQUF5QixJQUFJO0FBQzdCLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0EsSUFBSSwwQkFBMEIsSUFBSTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsR0FBRyxHQUFHO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFLHNDQUFzQyx3QkFBd0I7QUFDOUQsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBLHVIQUF1SDtBQUN2SCxvREFBb0Qsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNENBQTRDLElBQUk7QUFDcEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQ0FBK0MsSUFBSTtBQUN2RDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLHlCQUF5QjtBQUNoRSxvQkFBb0IsdUJBQXVCLFFBQVE7QUFDbkQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9qdWxpYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzLCBlbmQsIHByZSkge1xuICBpZiAodHlwZW9mIHByZSA9PT0gXCJ1bmRlZmluZWRcIikgcHJlID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBlbmQgPT09IFwidW5kZWZpbmVkXCIpIHsgZW5kID0gXCJcXFxcYlwiOyB9XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiICsgcHJlICsgXCIoKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcIiArIGVuZCk7XG59XG5cbnZhciBvY3RDaGFyID0gXCJcXFxcXFxcXFswLTddezEsM31cIjtcbnZhciBoZXhDaGFyID0gXCJcXFxcXFxcXHhbQS1GYS1mMC05XXsxLDJ9XCI7XG52YXIgc0NoYXIgPSBcIlxcXFxcXFxcW2FiZWZucnR2MCU/J1xcXCJcXFxcXFxcXF1cIjtcbnZhciB1Q2hhciA9IFwiKFteXFxcXHUwMDI3XFxcXHUwMDVDXFxcXHVEODAwLVxcXFx1REZGRl18W1xcXFx1RDgwMC1cXFxcdURGRkZdW1xcXFx1REMwMC1cXFxcdURGRkZdKVwiO1xuXG52YXIgYXNjaWlPcGVyYXRvcnNMaXN0ID0gW1xuICBcIls8Pl06XCIsIFwiWzw+PV09XCIsIFwiPDw9P1wiLCBcIj4+Pj89P1wiLCBcIj0+XCIsIFwiLS0/PlwiLCBcIjwtLVstPl0/XCIsIFwiXFxcXC9cXFxcL1wiLFxuICBcIlxcXFwuezIsM31cIiwgXCJbXFxcXC5cXFxcXFxcXCUqK1xcXFwtPD4hXFxcXC9efCZdPT9cIiwgXCJcXFxcP1wiLCBcIlxcXFwkXCIsIFwiflwiLCBcIjpcIlxuXTtcbnZhciBvcGVyYXRvcnMgPSB3b3JkUmVnZXhwKFtcbiAgXCJbPD5dOlwiLCBcIls8Pj1dPVwiLCBcIlshPV09PVwiLCBcIjw8PT9cIiwgXCI+Pj4/PT9cIiwgXCI9Pj9cIiwgXCItLT8+XCIsIFwiPC0tWy0+XT9cIiwgXCJcXFxcL1xcXFwvXCIsXG4gIFwiW1xcXFxcXFxcJSorXFxcXC08PiFcXFxcL158JlxcXFx1MDBGN1xcXFx1MjJCQl09P1wiLCBcIlxcXFw/XCIsIFwiXFxcXCRcIiwgXCJ+XCIsIFwiOlwiLFxuICBcIlxcXFx1MDBEN1wiLCBcIlxcXFx1MjIwOFwiLCBcIlxcXFx1MjIwOVwiLCBcIlxcXFx1MjIwQlwiLCBcIlxcXFx1MjIwQ1wiLCBcIlxcXFx1MjIxOFwiLFxuICBcIlxcXFx1MjIxQVwiLCBcIlxcXFx1MjIxQlwiLCBcIlxcXFx1MjIyOVwiLCBcIlxcXFx1MjIyQVwiLCBcIlxcXFx1MjI2MFwiLCBcIlxcXFx1MjI2NFwiLFxuICBcIlxcXFx1MjI2NVwiLCBcIlxcXFx1MjI4NlwiLCBcIlxcXFx1MjI4OFwiLCBcIlxcXFx1MjI4QVwiLCBcIlxcXFx1MjJDNVwiLFxuICBcIlxcXFxiKGlufGlzYSlcXFxcYig/IVxcLj9cXFxcKClcIlxuXSwgXCJcIik7XG52YXIgZGVsaW1pdGVycyA9IC9eWzssKClbXFxde31dLztcbnZhciBpZGVudGlmaWVycyA9IC9eW19BLVphLXpcXHUwMEExLVxcdTIyMTdcXHUyMjE5LVxcdUZGRkZdW1xcd1xcdTAwQTEtXFx1MjIxN1xcdTIyMTktXFx1RkZGRl0qISovO1xuXG52YXIgY2hhcnMgPSB3b3JkUmVnZXhwKFtvY3RDaGFyLCBoZXhDaGFyLCBzQ2hhciwgdUNoYXJdLCBcIidcIik7XG5cbnZhciBvcGVuZXJzTGlzdCA9IFtcImJlZ2luXCIsIFwiZnVuY3Rpb25cIiwgXCJ0eXBlXCIsIFwic3RydWN0XCIsIFwiaW1tdXRhYmxlXCIsIFwibGV0XCIsXG4gICAgICAgICAgICAgICAgICAgXCJtYWNyb1wiLCBcImZvclwiLCBcIndoaWxlXCIsIFwicXVvdGVcIiwgXCJpZlwiLCBcImVsc2VcIiwgXCJlbHNlaWZcIiwgXCJ0cnlcIixcbiAgICAgICAgICAgICAgICAgICBcImZpbmFsbHlcIiwgXCJjYXRjaFwiLCBcImRvXCJdO1xuXG52YXIgY2xvc2Vyc0xpc3QgPSBbXCJlbmRcIiwgXCJlbHNlXCIsIFwiZWxzZWlmXCIsIFwiY2F0Y2hcIiwgXCJmaW5hbGx5XCJdO1xuXG52YXIga2V5d29yZHNMaXN0ID0gW1wiaWZcIiwgXCJlbHNlXCIsIFwiZWxzZWlmXCIsIFwid2hpbGVcIiwgXCJmb3JcIiwgXCJiZWdpblwiLCBcImxldFwiLFxuICAgICAgICAgICAgICAgICAgICBcImVuZFwiLCBcImRvXCIsIFwidHJ5XCIsIFwiY2F0Y2hcIiwgXCJmaW5hbGx5XCIsIFwicmV0dXJuXCIsIFwiYnJlYWtcIiwgXCJjb250aW51ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdsb2JhbFwiLCBcImxvY2FsXCIsIFwiY29uc3RcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJpbXBvcnRhbGxcIiwgXCJ1c2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIsIFwid2hlcmVcIiwgXCJtYWNyb1wiLCBcIm1vZHVsZVwiLCBcImJhcmVtb2R1bGVcIiwgXCJzdHJ1Y3RcIiwgXCJ0eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXV0YWJsZVwiLCBcImltbXV0YWJsZVwiLCBcInF1b3RlXCIsIFwidHlwZWFsaWFzXCIsIFwiYWJzdHJhY3RcIiwgXCJwcmltaXRpdmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaXRzdHlwZVwiXTtcblxudmFyIGJ1aWx0aW5zTGlzdCA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm5vdGhpbmdcIiwgXCJOYU5cIiwgXCJJbmZcIl07XG5cbnZhciBvcGVuZXJzID0gd29yZFJlZ2V4cChvcGVuZXJzTGlzdCk7XG52YXIgY2xvc2VycyA9IHdvcmRSZWdleHAoY2xvc2Vyc0xpc3QpO1xudmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChrZXl3b3Jkc0xpc3QpO1xudmFyIGJ1aWx0aW5zID0gd29yZFJlZ2V4cChidWlsdGluc0xpc3QpO1xuXG52YXIgbWFjcm8gPSAvXkBbX0EtWmEtelxcdTAwQTEtXFx1RkZGRl1bXFx3XFx1MDBBMS1cXHVGRkZGXSohKi87XG52YXIgc3ltYm9sID0gL146W19BLVphLXpcXHUwMEExLVxcdUZGRkZdW1xcd1xcdTAwQTEtXFx1RkZGRl0qISovO1xudmFyIHN0cmluZ1ByZWZpeGVzID0gL14oYHwoW19BLVphLXpcXHUwMEExLVxcdUZGRkZdKlwiKFwiXCIpPykpLztcblxudmFyIG1hY3JvT3BlcmF0b3JzID0gd29yZFJlZ2V4cChhc2NpaU9wZXJhdG9yc0xpc3QsIFwiXCIsIFwiQFwiKTtcbnZhciBzeW1ib2xPcGVyYXRvcnMgPSB3b3JkUmVnZXhwKGFzY2lpT3BlcmF0b3JzTGlzdCwgXCJcIiwgXCI6XCIpO1xuXG5mdW5jdGlvbiBpbkFycmF5KHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUubmVzdGVkQXJyYXlzID4gMCk7XG59XG5cbmZ1bmN0aW9uIGluR2VuZXJhdG9yKHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUubmVzdGVkR2VuZXJhdG9ycyA+IDApO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50U2NvcGUoc3RhdGUsIG4pIHtcbiAgaWYgKHR5cGVvZihuKSA9PT0gXCJ1bmRlZmluZWRcIikgeyBuID0gMDsgfVxuICBpZiAoc3RhdGUuc2NvcGVzLmxlbmd0aCA8PSBuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnNjb3Blc1tzdGF0ZS5zY29wZXMubGVuZ3RoIC0gKG4gKyAxKV07XG59XG5cbi8vIHRva2VuaXplcnNcbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEhhbmRsZSBtdWx0aWxpbmUgY29tbWVudHNcbiAgaWYgKHN0cmVhbS5tYXRjaCgnIz0nLCBmYWxzZSkpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgc2NvcGUgY2hhbmdlc1xuICB2YXIgbGVhdmluZ0V4cHIgPSBzdGF0ZS5sZWF2aW5nRXhwcjtcbiAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgIGxlYXZpbmdFeHByID0gZmFsc2U7XG4gIH1cbiAgc3RhdGUubGVhdmluZ0V4cHIgPSBmYWxzZTtcblxuICBpZiAobGVhdmluZ0V4cHIpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eJysvKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKC9cXC57NCx9LykpIHtcbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXFwuezEsM30vKSkge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgLy8gSGFuZGxlIHNpbmdsZSBsaW5lIGNvbW1lbnRzXG4gIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgc3RhdGUuc2NvcGVzLnB1c2goJ1snKTtcbiAgICBzdGF0ZS5uZXN0ZWRBcnJheXMrKztcbiAgfVxuXG4gIGlmIChjaCA9PT0gJygnKSB7XG4gICAgc3RhdGUuc2NvcGVzLnB1c2goJygnKTtcbiAgICBzdGF0ZS5uZXN0ZWRHZW5lcmF0b3JzKys7XG4gIH1cblxuICBpZiAoaW5BcnJheShzdGF0ZSkgJiYgY2ggPT09ICddJykge1xuICAgIHdoaWxlIChzdGF0ZS5zY29wZXMubGVuZ3RoICYmIGN1cnJlbnRTY29wZShzdGF0ZSkgIT09IFwiW1wiKSB7IHN0YXRlLnNjb3Blcy5wb3AoKTsgfVxuICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgICBzdGF0ZS5uZXN0ZWRBcnJheXMtLTtcbiAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gIH1cblxuICBpZiAoaW5HZW5lcmF0b3Ioc3RhdGUpICYmIGNoID09PSAnKScpIHtcbiAgICB3aGlsZSAoc3RhdGUuc2NvcGVzLmxlbmd0aCAmJiBjdXJyZW50U2NvcGUoc3RhdGUpICE9PSBcIihcIikgeyBzdGF0ZS5zY29wZXMucG9wKCk7IH1cbiAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG4gICAgc3RhdGUubmVzdGVkR2VuZXJhdG9ycy0tO1xuICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpbkFycmF5KHN0YXRlKSkge1xuICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT0gXCJlbmRcIiAmJiBzdHJlYW0ubWF0Y2goJzonKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgnZW5kJykpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaDtcbiAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKG9wZW5lcnMsIGZhbHNlKSkge1xuICAgIHN0YXRlLnNjb3Blcy5wdXNoKG1hdGNoWzBdKTtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goY2xvc2VycywgZmFsc2UpKSB7XG4gICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHR5cGUgYW5ub3RhdGlvbnNcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXjo6KD8hWzpcXCRdKS8pKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkFubm90YXRpb247XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHN5bWJvbHNcbiAgaWYgKCFsZWF2aW5nRXhwciAmJiAoc3RyZWFtLm1hdGNoKHN5bWJvbCkgfHwgc3RyZWFtLm1hdGNoKHN5bWJvbE9wZXJhdG9ycykpKSB7XG4gICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIHBhcmFtZXRyaWMgdHlwZXNcbiAgLy9pZiAoc3RyZWFtLm1hdGNoKC9ee1tefV0qfSg/PVxcKCkvKSkge1xuICAvLyAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAvL31cblxuICAvLyBIYW5kbGUgb3BlcmF0b3JzIGFuZCBEZWxpbWl0ZXJzXG4gIGlmIChzdHJlYW0ubWF0Y2gob3BlcmF0b3JzKSkge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cblxuICAvLyBIYW5kbGUgTnVtYmVyIExpdGVyYWxzXG4gIGlmIChzdHJlYW0ubWF0Y2goL15cXC4/XFxkLywgZmFsc2UpKSB7XG4gICAgdmFyIGltTWF0Y2hlciA9IFJlZ0V4cCgvXmltXFxiLyk7XG4gICAgdmFyIG51bWJlckxpdGVyYWwgPSBmYWxzZTtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMHhcXC5bMC05YS1mX10rcFtcXCtcXC1dP1tfXFxkXSsvaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH1cbiAgICAvLyBJbnRlZ2Vyc1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14weFswLTlhLWZfXSsvaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH0gLy8gSGV4XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXjBiWzAxX10rL2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9IC8vIEJpbmFyeVxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14wb1swLTdfXSsvaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH0gLy8gT2N0YWxcbiAgICAvLyBGbG9hdHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKD86KD86XFxkW19cXGRdKik/XFwuKD8hXFwuKSg/OlxcZFtfXFxkXSopP3xcXGRbX1xcZF0qXFwuKD8hXFwuKSg/OlxcZFtfXFxkXSopKT8oW0VlZl1bXFwrXFwtXT9bX1xcZF0rKT8vaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxkW19cXGRdKihlW1xcK1xcLV0/XFxkKyk/L2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9IC8vIERlY2ltYWxcbiAgICBpZiAobnVtYmVyTGl0ZXJhbCkge1xuICAgICAgLy8gSW50ZWdlciBsaXRlcmFscyBtYXkgYmUgXCJsb25nXCJcbiAgICAgIHN0cmVhbS5tYXRjaChpbU1hdGNoZXIpO1xuICAgICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIENoYXJzXG4gIGlmIChzdHJlYW0ubWF0Y2goXCInXCIpKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNoYXI7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gSGFuZGxlIFN0cmluZ3NcbiAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdQcmVmaXhlcykpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nRmFjdG9yeShzdHJlYW0uY3VycmVudCgpKTtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKG1hY3JvKSB8fCBzdHJlYW0ubWF0Y2gobWFjcm9PcGVyYXRvcnMpKSB7XG4gICAgcmV0dXJuIFwibWV0YVwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXJzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGJ1aWx0aW5zKSkge1xuICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgfVxuXG4gIHZhciBpc0RlZmluaXRpb24gPSBzdGF0ZS5pc0RlZmluaXRpb24gfHwgc3RhdGUubGFzdFRva2VuID09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgc3RhdGUubGFzdFRva2VuID09IFwibWFjcm9cIiB8fCBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJ0eXBlXCIgfHxcbiAgICAgIHN0YXRlLmxhc3RUb2tlbiA9PSBcInN0cnVjdFwiIHx8IHN0YXRlLmxhc3RUb2tlbiA9PSBcImltbXV0YWJsZVwiO1xuXG4gIGlmIChzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSB7XG4gICAgaWYgKGlzRGVmaW5pdGlvbikge1xuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICcuJykge1xuICAgICAgICBzdGF0ZS5pc0RlZmluaXRpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgfVxuICAgICAgc3RhdGUuaXNEZWZpbml0aW9uID0gZmFsc2U7XG4gICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG4gICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gIHN0cmVhbS5uZXh0KCk7XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuQW5ub3RhdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5tYXRjaCgvLio/KD89Wyw7e30oKT1cXHNdfCQpLyk7XG4gIGlmIChzdHJlYW0ubWF0Y2goJ3snKSkge1xuICAgIHN0YXRlLm5lc3RlZFBhcmFtZXRlcnMrKztcbiAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ30nKSAmJiBzdGF0ZS5uZXN0ZWRQYXJhbWV0ZXJzID4gMCkge1xuICAgIHN0YXRlLm5lc3RlZFBhcmFtZXRlcnMtLTtcbiAgfVxuICBpZiAoc3RhdGUubmVzdGVkUGFyYW1ldGVycyA+IDApIHtcbiAgICBzdHJlYW0ubWF0Y2goLy4qPyg/PXt8fSkvKSB8fCBzdHJlYW0ubmV4dCgpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm5lc3RlZFBhcmFtZXRlcnMgPT0gMCkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG4gIHJldHVybiBcImJ1aWx0aW5cIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0cmVhbS5tYXRjaCgnIz0nKSkge1xuICAgIHN0YXRlLm5lc3RlZENvbW1lbnRzKys7XG4gIH1cbiAgaWYgKCFzdHJlYW0ubWF0Y2goLy4qPyg/PSgjPXw9IykpLykpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaCgnPSMnKSkge1xuICAgIHN0YXRlLm5lc3RlZENvbW1lbnRzLS07XG4gICAgaWYgKHN0YXRlLm5lc3RlZENvbW1lbnRzID09IDApXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuQ2hhcihzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBpc0NoYXIgPSBmYWxzZSwgbWF0Y2g7XG4gIGlmIChzdHJlYW0ubWF0Y2goY2hhcnMpKSB7XG4gICAgaXNDaGFyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXFxcXHUoW2EtZjAtOV17MSw0fSkoPz0nKS9pKSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgaWYgKHZhbHVlIDw9IDU1Mjk1IHx8IHZhbHVlID49IDU3MzQ0KSB7IC8vIChVKzAsVStEN0ZGKSwgKFUrRTAwMCxVK0ZGRkYpXG4gICAgICBpc0NoYXIgPSB0cnVlO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL1xcXFxVKFtBLUZhLWYwLTldezUsOH0pKD89JykvKSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgaWYgKHZhbHVlIDw9IDExMTQxMTEpIHsgLy8gVSsxMEZGRkZcbiAgICAgIGlzQ2hhciA9IHRydWU7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDaGFyKSB7XG4gICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIGlmICghc3RyZWFtLm1hdGNoKC9eW14nXSsoPz0nKS8pKSB7IHN0cmVhbS5za2lwVG9FbmQoKTsgfVxuICBpZiAoc3RyZWFtLm1hdGNoKFwiJ1wiKSkgeyBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTsgfVxuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZ0ZhY3RvcnkoZGVsaW1pdGVyKSB7XG4gIGlmIChkZWxpbWl0ZXIuc3Vic3RyKC0zKSA9PT0gJ1wiXCJcIicpIHtcbiAgICBkZWxpbWl0ZXIgPSAnXCJcIlwiJztcbiAgfSBlbHNlIGlmIChkZWxpbWl0ZXIuc3Vic3RyKC0xKSA9PT0gJ1wiJykge1xuICAgIGRlbGltaXRlciA9ICdcIic7XG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0KCdcXFxcJykpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goZGVsaW1pdGVyKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdCgvW2BcIl0vKTtcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXlxcXFxgXCJdLyk7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHRva2VuU3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QganVsaWEgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgc2NvcGVzOiBbXSxcbiAgICAgIGxhc3RUb2tlbjogbnVsbCxcbiAgICAgIGxlYXZpbmdFeHByOiBmYWxzZSxcbiAgICAgIGlzRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgICBuZXN0ZWRBcnJheXM6IDAsXG4gICAgICBuZXN0ZWRDb21tZW50czogMCxcbiAgICAgIG5lc3RlZEdlbmVyYXRvcnM6IDAsXG4gICAgICBuZXN0ZWRQYXJhbWV0ZXJzOiAwLFxuICAgICAgZmlyc3RQYXJlblBvczogLTFcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgdmFyIGN1cnJlbnQgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gICAgaWYgKGN1cnJlbnQgJiYgc3R5bGUpIHtcbiAgICAgIHN0YXRlLmxhc3RUb2tlbiA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGlmICggdGV4dEFmdGVyID09PSAnXScgfHwgdGV4dEFmdGVyID09PSAnKScgfHwgL15lbmRcXGIvLnRlc3QodGV4dEFmdGVyKSB8fFxuICAgICAgICAgL15lbHNlLy50ZXN0KHRleHRBZnRlcikgfHwgL15jYXRjaFxcYi8udGVzdCh0ZXh0QWZ0ZXIpIHx8IC9eZWxzZWlmXFxiLy50ZXN0KHRleHRBZnRlcikgfHxcbiAgICAgICAgIC9eZmluYWxseS8udGVzdCh0ZXh0QWZ0ZXIpICkge1xuICAgICAgZGVsdGEgPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIChzdGF0ZS5zY29wZXMubGVuZ3RoICsgZGVsdGEpICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccyooZW5kfGVsc2V8Y2F0Y2h8ZmluYWxseSlcXGIkLyxcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCIsIGJsb2NrOiB7b3BlbjogXCIjPVwiLCBjbG9zZTogXCI9I1wifX0sXG4gICAgY2xvc2VCcmFja2V0czoge2JyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgJ1wiJ119LFxuICAgIGF1dG9jb21wbGV0ZToga2V5d29yZHNMaXN0LmNvbmNhdChidWlsdGluc0xpc3QpXG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=