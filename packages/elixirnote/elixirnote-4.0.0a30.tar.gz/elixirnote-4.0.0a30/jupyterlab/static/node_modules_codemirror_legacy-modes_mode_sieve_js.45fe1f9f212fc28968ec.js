"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_sieve_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/sieve.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/sieve.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sieve": () => (/* binding */ sieve)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = words("if elsif else stop require");
var atoms = words("true false not");

function tokenBase(stream, state) {

  var ch = stream.next();
  if (ch == "/" && stream.eat("*")) {
    state.tokenize = tokenCComment;
    return tokenCComment(stream, state);
  }

  if (ch === '#') {
    stream.skipToEnd();
    return "comment";
  }

  if (ch == "\"") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }

  if (ch == "(") {
    state._indent.push("(");
    // add virtual angel wings so that editor behaves...
    // ...more sane incase of broken brackets
    state._indent.push("{");
    return null;
  }

  if (ch === "{") {
    state._indent.push("{");
    return null;
  }

  if (ch == ")")  {
    state._indent.pop();
    state._indent.pop();
  }

  if (ch === "}") {
    state._indent.pop();
    return null;
  }

  if (ch == ",")
    return null;

  if (ch == ";")
    return null;


  if (/[{}\(\),;]/.test(ch))
    return null;

  // 1*DIGIT "K" / "M" / "G"
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\d]/);
    stream.eat(/[KkMmGg]/);
    return "number";
  }

  // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
  if (ch == ":") {
    stream.eatWhile(/[a-zA-Z_]/);
    stream.eatWhile(/[a-zA-Z0-9_]/);

    return "operator";
  }

  stream.eatWhile(/\w/);
  var cur = stream.current();

  // "text:" *(SP / HTAB) (hash-comment / CRLF)
  // *(multiline-literal / multiline-dotstart)
  // "." CRLF
  if ((cur == "text") && stream.eat(":"))
  {
    state.tokenize = tokenMultiLineString;
    return "string";
  }

  if (keywords.propertyIsEnumerable(cur))
    return "keyword";

  if (atoms.propertyIsEnumerable(cur))
    return "atom";

  return null;
}

function tokenMultiLineString(stream, state)
{
  state._multiLineString = true;
  // the first line is special it may contain a comment
  if (!stream.sol()) {
    stream.eatSpace();

    if (stream.peek() == "#") {
      stream.skipToEnd();
      return "comment";
    }

    stream.skipToEnd();
    return "string";
  }

  if ((stream.next() == ".")  && (stream.eol()))
  {
    state._multiLineString = false;
    state.tokenize = tokenBase;
  }

  return "string";
}

function tokenCComment(stream, state) {
  var maybeEnd = false, ch;
  while ((ch = stream.next()) != null) {
    if (maybeEnd && ch == "/") {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped)
        break;
      escaped = !escaped && ch == "\\";
    }
    if (!escaped) state.tokenize = tokenBase;
    return "string";
  };
}

const sieve = {
  startState: function(base) {
    return {tokenize: tokenBase,
            baseIndent: base || 0,
            _indent: []};
  },

  token: function(stream, state) {
    if (stream.eatSpace())
      return null;

    return (state.tokenize || tokenBase)(stream, state);
  },

  indent: function(state, _textAfter, cx) {
    var length = state._indent.length;
    if (_textAfter && (_textAfter[0] == "}"))
      length--;

    if (length <0)
      length = 0;

    return length * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*\}$/
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc2lldmVfanMuNDVmZTFmOWYyMTJmYzI4OTY4ZWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7O0FBR0EsVUFBVSxNQUFNO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zaWV2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG52YXIga2V5d29yZHMgPSB3b3JkcyhcImlmIGVsc2lmIGVsc2Ugc3RvcCByZXF1aXJlXCIpO1xudmFyIGF0b21zID0gd29yZHMoXCJ0cnVlIGZhbHNlIG5vdFwiKTtcblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcblxuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0NvbW1lbnQ7XG4gICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoY2ggPT09ICcjJykge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBpZiAoY2ggPT0gXCJcXFwiXCIpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoY2ggPT0gXCIoXCIpIHtcbiAgICBzdGF0ZS5faW5kZW50LnB1c2goXCIoXCIpO1xuICAgIC8vIGFkZCB2aXJ0dWFsIGFuZ2VsIHdpbmdzIHNvIHRoYXQgZWRpdG9yIGJlaGF2ZXMuLi5cbiAgICAvLyAuLi5tb3JlIHNhbmUgaW5jYXNlIG9mIGJyb2tlbiBicmFja2V0c1xuICAgIHN0YXRlLl9pbmRlbnQucHVzaChcIntcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgc3RhdGUuX2luZGVudC5wdXNoKFwie1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIilcIikgIHtcbiAgICBzdGF0ZS5faW5kZW50LnBvcCgpO1xuICAgIHN0YXRlLl9pbmRlbnQucG9wKCk7XG4gIH1cblxuICBpZiAoY2ggPT09IFwifVwiKSB7XG4gICAgc3RhdGUuX2luZGVudC5wb3AoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIixcIilcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoY2ggPT0gXCI7XCIpXG4gICAgcmV0dXJuIG51bGw7XG5cblxuICBpZiAoL1t7fVxcKFxcKSw7XS8udGVzdChjaCkpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgLy8gMSpESUdJVCBcIktcIiAvIFwiTVwiIC8gXCJHXCJcbiAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkXS8pO1xuICAgIHN0cmVhbS5lYXQoL1tLa01tR2ddLyk7XG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH1cblxuICAvLyBcIjpcIiAoQUxQSEEgLyBcIl9cIikgKihBTFBIQSAvIERJR0lUIC8gXCJfXCIpXG4gIGlmIChjaCA9PSBcIjpcIikge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2EtekEtWl9dLyk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16QS1aMC05X10vKTtcblxuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cblxuICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAvLyBcInRleHQ6XCIgKihTUCAvIEhUQUIpIChoYXNoLWNvbW1lbnQgLyBDUkxGKVxuICAvLyAqKG11bHRpbGluZS1saXRlcmFsIC8gbXVsdGlsaW5lLWRvdHN0YXJ0KVxuICAvLyBcIi5cIiBDUkxGXG4gIGlmICgoY3VyID09IFwidGV4dFwiKSAmJiBzdHJlYW0uZWF0KFwiOlwiKSlcbiAge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5NdWx0aUxpbmVTdHJpbmc7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cblxuICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSlcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpXG4gICAgcmV0dXJuIFwiYXRvbVwiO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b2tlbk11bHRpTGluZVN0cmluZyhzdHJlYW0sIHN0YXRlKVxue1xuICBzdGF0ZS5fbXVsdGlMaW5lU3RyaW5nID0gdHJ1ZTtcbiAgLy8gdGhlIGZpcnN0IGxpbmUgaXMgc3BlY2lhbCBpdCBtYXkgY29udGFpbiBhIGNvbW1lbnRcbiAgaWYgKCFzdHJlYW0uc29sKCkpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcblxuICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuXG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgaWYgKChzdHJlYW0ubmV4dCgpID09IFwiLlwiKSAgJiYgKHN0cmVhbS5lb2woKSkpXG4gIHtcbiAgICBzdGF0ZS5fbXVsdGlMaW5lU3RyaW5nID0gZmFsc2U7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cblxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZClcbiAgICAgICAgYnJlYWs7XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIGlmICghZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBzaWV2ZSA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZSkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgIGJhc2VJbmRlbnQ6IGJhc2UgfHwgMCxcbiAgICAgICAgICAgIF9pbmRlbnQ6IFtdfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIF90ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIGxlbmd0aCA9IHN0YXRlLl9pbmRlbnQubGVuZ3RoO1xuICAgIGlmIChfdGV4dEFmdGVyICYmIChfdGV4dEFmdGVyWzBdID09IFwifVwiKSlcbiAgICAgIGxlbmd0aC0tO1xuXG4gICAgaWYgKGxlbmd0aCA8MClcbiAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gbGVuZ3RoICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypcXH0kL1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9