"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_eiffel_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/eiffel.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/eiffel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eiffel": () => (/* binding */ eiffel)
/* harmony export */ });
function wordObj(words) {
  var o = {};
  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
  return o;
}
var keywords = wordObj([
  'note',
  'across',
  'when',
  'variant',
  'until',
  'unique',
  'undefine',
  'then',
  'strip',
  'select',
  'retry',
  'rescue',
  'require',
  'rename',
  'reference',
  'redefine',
  'prefix',
  'once',
  'old',
  'obsolete',
  'loop',
  'local',
  'like',
  'is',
  'inspect',
  'infix',
  'include',
  'if',
  'frozen',
  'from',
  'external',
  'export',
  'ensure',
  'end',
  'elseif',
  'else',
  'do',
  'creation',
  'create',
  'check',
  'alias',
  'agent',
  'separate',
  'invariant',
  'inherit',
  'indexing',
  'feature',
  'expanded',
  'deferred',
  'class',
  'Void',
  'True',
  'Result',
  'Precursor',
  'False',
  'Current',
  'create',
  'attached',
  'detachable',
  'as',
  'and',
  'implies',
  'not',
  'or'
]);
var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

function chain(newtok, stream, state) {
  state.tokenize.push(newtok);
  return newtok(stream, state);
}

function tokenBase(stream, state) {
  if (stream.eatSpace()) return null;
  var ch = stream.next();
  if (ch == '"'||ch == "'") {
    return chain(readQuoted(ch, "string"), stream, state);
  } else if (ch == "-"&&stream.eat("-")) {
    stream.skipToEnd();
    return "comment";
  } else if (ch == ":"&&stream.eat("=")) {
    return "operator";
  } else if (/[0-9]/.test(ch)) {
    stream.eatWhile(/[xXbBCc0-9\.]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[a-zA-Z_0-9]/.test(ch)) {
    stream.eatWhile(/[a-zA-Z_0-9]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[=+\-\/*^%<>~]/.test(ch)) {
    stream.eatWhile(/[=+\-\/*^%<>~]/);
    return "operator";
  } else {
    return null;
  }
}

function readQuoted(quote, style,  unescaped) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && (unescaped || !escaped)) {
        state.tokenize.pop();
        break;
      }
      escaped = !escaped && ch == "%";
    }
    return style;
  };
}

const eiffel = {
  startState: function() {
    return {tokenize: [tokenBase]};
  },

  token: function(stream, state) {
    var style = state.tokenize[state.tokenize.length-1](stream, state);
    if (style == "variable") {
      var word = stream.current();
      style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
        : operators.propertyIsEnumerable(stream.current()) ? "operator"
        : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
        : /^0[bB][0-1]+$/g.test(word) ? "number"
        : /^0[cC][0-7]+$/g.test(word) ? "number"
        : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
        : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
        : /^[0-9]+$/g.test(word) ? "number"
        : "variable";
    }
    return style;
  },
  languageData: {
    commentTokens: {line: "--"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZWlmZmVsX2pzLjMzNzViOTQ2ZmI4Y2U2ODcxZDBkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxZQUFZO0FBQ1osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZWlmZmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRPYmood29yZHMpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSB3b3Jkcy5sZW5ndGg7IGkgPCBlOyArK2kpIG9bd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG87XG59XG52YXIga2V5d29yZHMgPSB3b3JkT2JqKFtcbiAgJ25vdGUnLFxuICAnYWNyb3NzJyxcbiAgJ3doZW4nLFxuICAndmFyaWFudCcsXG4gICd1bnRpbCcsXG4gICd1bmlxdWUnLFxuICAndW5kZWZpbmUnLFxuICAndGhlbicsXG4gICdzdHJpcCcsXG4gICdzZWxlY3QnLFxuICAncmV0cnknLFxuICAncmVzY3VlJyxcbiAgJ3JlcXVpcmUnLFxuICAncmVuYW1lJyxcbiAgJ3JlZmVyZW5jZScsXG4gICdyZWRlZmluZScsXG4gICdwcmVmaXgnLFxuICAnb25jZScsXG4gICdvbGQnLFxuICAnb2Jzb2xldGUnLFxuICAnbG9vcCcsXG4gICdsb2NhbCcsXG4gICdsaWtlJyxcbiAgJ2lzJyxcbiAgJ2luc3BlY3QnLFxuICAnaW5maXgnLFxuICAnaW5jbHVkZScsXG4gICdpZicsXG4gICdmcm96ZW4nLFxuICAnZnJvbScsXG4gICdleHRlcm5hbCcsXG4gICdleHBvcnQnLFxuICAnZW5zdXJlJyxcbiAgJ2VuZCcsXG4gICdlbHNlaWYnLFxuICAnZWxzZScsXG4gICdkbycsXG4gICdjcmVhdGlvbicsXG4gICdjcmVhdGUnLFxuICAnY2hlY2snLFxuICAnYWxpYXMnLFxuICAnYWdlbnQnLFxuICAnc2VwYXJhdGUnLFxuICAnaW52YXJpYW50JyxcbiAgJ2luaGVyaXQnLFxuICAnaW5kZXhpbmcnLFxuICAnZmVhdHVyZScsXG4gICdleHBhbmRlZCcsXG4gICdkZWZlcnJlZCcsXG4gICdjbGFzcycsXG4gICdWb2lkJyxcbiAgJ1RydWUnLFxuICAnUmVzdWx0JyxcbiAgJ1ByZWN1cnNvcicsXG4gICdGYWxzZScsXG4gICdDdXJyZW50JyxcbiAgJ2NyZWF0ZScsXG4gICdhdHRhY2hlZCcsXG4gICdkZXRhY2hhYmxlJyxcbiAgJ2FzJyxcbiAgJ2FuZCcsXG4gICdpbXBsaWVzJyxcbiAgJ25vdCcsXG4gICdvcidcbl0pO1xudmFyIG9wZXJhdG9ycyA9IHdvcmRPYmooW1wiOj1cIiwgXCJhbmQgdGhlblwiLFwiYW5kXCIsIFwib3JcIixcIjw8XCIsXCI+PlwiXSk7XG5cbmZ1bmN0aW9uIGNoYWluKG5ld3Rvaywgc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS50b2tlbml6ZS5wdXNoKG5ld3Rvayk7XG4gIHJldHVybiBuZXd0b2soc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSAnXCInfHxjaCA9PSBcIidcIikge1xuICAgIHJldHVybiBjaGFpbihyZWFkUXVvdGVkKGNoLCBcInN0cmluZ1wiKSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCItXCImJnN0cmVhbS5lYXQoXCItXCIpKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIiYmc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9IGVsc2UgaWYgKC9bMC05XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1t4WGJCQ2MwLTlcXC5dLyk7XG4gICAgc3RyZWFtLmVhdCgvW1xcP1xcIV0vKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9IGVsc2UgaWYgKC9bYS16QS1aXzAtOV0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16QS1aXzAtOV0vKTtcbiAgICBzdHJlYW0uZWF0KC9bXFw/XFwhXS8pO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH0gZWxzZSBpZiAoL1s9K1xcLVxcLypeJTw+fl0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bPStcXC1cXC8qXiU8Pn5dLyk7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkUXVvdGVkKHF1b3RlLCBzdHlsZSwgIHVuZXNjYXBlZCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgKHVuZXNjYXBlZCB8fCAhZXNjYXBlZCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiJVwiO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBlaWZmZWwgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IFt0b2tlbkJhc2VdfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aC0xXShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBzdHlsZSA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpID8gXCJrZXl3b3JkXCJcbiAgICAgICAgOiBvcGVyYXRvcnMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkgPyBcIm9wZXJhdG9yXCJcbiAgICAgICAgOiAvXltBLVpdW0EtWl8wLTldKiQvZy50ZXN0KHdvcmQpID8gXCJ0YWdcIlxuICAgICAgICA6IC9eMFtiQl1bMC0xXSskL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgOiAvXjBbY0NdWzAtN10rJC9nLnRlc3Qod29yZCkgPyBcIm51bWJlclwiXG4gICAgICAgIDogL14wW3hYXVthLWZBLUYwLTldKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICA6IC9eKFswLTldK1xcLlswLTldKil8KFswLTldKlxcLlswLTldKykkL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgOiAvXlswLTldKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICA6IFwidmFyaWFibGVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCItLVwifVxuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=