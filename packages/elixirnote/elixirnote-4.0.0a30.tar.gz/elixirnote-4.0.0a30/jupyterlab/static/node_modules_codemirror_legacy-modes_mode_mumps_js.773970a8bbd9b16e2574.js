"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_mumps_js"],{

/***/ "../../node_modules/@codemirror/legacy-modes/mode/mumps.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@codemirror/legacy-modes/mode/mumps.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mumps": () => (/* binding */ mumps)
/* harmony export */ });
function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
}

var singleOperators = new RegExp("^[\\+\\-\\*/&#!_?\\\\<>=\\'\\[\\]]");
var doubleOperators = new RegExp("^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))");
var singleDelimiters = new RegExp("^[\\.,:]");
var brackets = new RegExp("[()]");
var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
// The following list includes intrinsic functions _and_ special variables
var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
var command = wordRegexp(commandKeywords);

function tokenBase(stream, state) {
  if (stream.sol()) {
    state.label = true;
    state.commandMode = 0;
  }

  // The <space> character has meaning in MUMPS. Ignoring consecutive
  // spaces would interfere with interpreting whether the next non-space
  // character belongs to the command or argument context.

  // Examine each character and update a mode variable whose interpretation is:
  //   >0 => command    0 => argument    <0 => command post-conditional
  var ch = stream.peek();

  if (ch == " " || ch == "\t") { // Pre-process <space>
    state.label = false;
    if (state.commandMode == 0)
      state.commandMode = 1;
    else if ((state.commandMode < 0) || (state.commandMode == 2))
      state.commandMode = 0;
  } else if ((ch != ".") && (state.commandMode > 0)) {
    if (ch == ":")
      state.commandMode = -1;   // SIS - Command post-conditional
    else
      state.commandMode = 2;
  }

  // Do not color parameter list as line tag
  if ((ch === "(") || (ch === "\u0009"))
    state.label = false;

  // MUMPS comment starts with ";"
  if (ch === ";") {
    stream.skipToEnd();
    return "comment";
  }

  // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
  if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
    return "number";

  // Handle Strings
  if (ch == '"') {
    if (stream.skipTo('"')) {
      stream.next();
      return "string";
    } else {
      stream.skipToEnd();
      return "error";
    }
  }

  // Handle operators and Delimiters
  if (stream.match(doubleOperators) || stream.match(singleOperators))
    return "operator";

  // Prevents leading "." in DO block from falling through to error
  if (stream.match(singleDelimiters))
    return null;

  if (brackets.test(ch)) {
    stream.next();
    return "bracket";
  }

  if (state.commandMode > 0 && stream.match(command))
    return "controlKeyword";

  if (stream.match(intrinsicFuncs))
    return "builtin";

  if (stream.match(identifiers))
    return "variable";

  // Detect dollar-sign when not a documented intrinsic function
  // "^" may introduce a GVN or SSVN - Color same as function
  if (ch === "$" || ch === "^") {
    stream.next();
    return "builtin";
  }

  // MUMPS Indirection
  if (ch === "@") {
    stream.next();
    return "string.special";
  }

  if (/[\w%]/.test(ch)) {
    stream.eatWhile(/[\w%]/);
    return "variable";
  }

  // Handle non-detected items
  stream.next();
  return "error";
}

const mumps = {
  startState: function() {
    return {
      label: false,
      commandMode: 0
    };
  },

  token: function(stream, state) {
    var style = tokenBase(stream, state);
    if (state.label) return "tag";
    return style;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfbXVtcHNfanMuNzczOTcwYThiYmQ5YjE2ZTI1NzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9tdW1wcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIsIFwiaVwiKTtcbn1cblxudmFyIHNpbmdsZU9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeW1xcXFwrXFxcXC1cXFxcKi8mIyFfP1xcXFxcXFxcPD49XFxcXCdcXFxcW1xcXFxdXVwiKTtcbnZhciBkb3VibGVPcGVyYXRvcnMgPSBuZXcgUmVnRXhwKFwiXigoJz0pfCg8PSl8KD49KXwoJz4pfCgnPCl8KFtbKXwoXV0pfCheJCkpXCIpO1xudmFyIHNpbmdsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxcLiw6XVwiKTtcbnZhciBicmFja2V0cyA9IG5ldyBSZWdFeHAoXCJbKCldXCIpO1xudmFyIGlkZW50aWZpZXJzID0gbmV3IFJlZ0V4cChcIl5bJUEtWmEtel1bQS1aYS16MC05XSpcIik7XG52YXIgY29tbWFuZEtleXdvcmRzID0gW1wiYnJlYWtcIixcImNsb3NlXCIsXCJkb1wiLFwiZWxzZVwiLFwiZm9yXCIsXCJnb3RvXCIsIFwiaGFsdFwiLCBcImhhbmdcIiwgXCJpZlwiLCBcImpvYlwiLFwia2lsbFwiLFwibG9ja1wiLFwibWVyZ2VcIixcIm5ld1wiLFwib3BlblwiLCBcInF1aXRcIiwgXCJyZWFkXCIsIFwic2V0XCIsIFwidGNvbW1pdFwiLCBcInRyb2xsYmFja1wiLCBcInRzdGFydFwiLCBcInVzZVwiLCBcInZpZXdcIiwgXCJ3cml0ZVwiLCBcInhlY3V0ZVwiLCBcImJcIixcImNcIixcImRcIixcImVcIixcImZcIixcImdcIiwgXCJoXCIsIFwiaVwiLCBcImpcIixcImtcIixcImxcIixcIm1cIixcIm5cIixcIm9cIiwgXCJxXCIsIFwiclwiLCBcInNcIiwgXCJ0Y1wiLCBcInRyb1wiLCBcInRzXCIsIFwidVwiLCBcInZcIiwgXCJ3XCIsIFwieFwiXTtcbi8vIFRoZSBmb2xsb3dpbmcgbGlzdCBpbmNsdWRlcyBpbnRyaW5zaWMgZnVuY3Rpb25zIF9hbmRfIHNwZWNpYWwgdmFyaWFibGVzXG52YXIgaW50cmluc2ljRnVuY3NXb3JkcyA9IFtcIlxcXFwkYXNjaWlcIiwgXCJcXFxcJGNoYXJcIiwgXCJcXFxcJGRhdGFcIiwgXCJcXFxcJGVjb2RlXCIsIFwiXFxcXCRlc3RhY2tcIiwgXCJcXFxcJGV0cmFwXCIsIFwiXFxcXCRleHRyYWN0XCIsIFwiXFxcXCRmaW5kXCIsIFwiXFxcXCRmbnVtYmVyXCIsIFwiXFxcXCRnZXRcIiwgXCJcXFxcJGhvcm9sb2dcIiwgXCJcXFxcJGlvXCIsIFwiXFxcXCRpbmNyZW1lbnRcIiwgXCJcXFxcJGpvYlwiLCBcIlxcXFwkanVzdGlmeVwiLCBcIlxcXFwkbGVuZ3RoXCIsIFwiXFxcXCRuYW1lXCIsIFwiXFxcXCRuZXh0XCIsIFwiXFxcXCRvcmRlclwiLCBcIlxcXFwkcGllY2VcIiwgXCJcXFxcJHFsZW5ndGhcIiwgXCJcXFxcJHFzdWJzY3JpcHRcIiwgXCJcXFxcJHF1ZXJ5XCIsIFwiXFxcXCRxdWl0XCIsIFwiXFxcXCRyYW5kb21cIiwgXCJcXFxcJHJldmVyc2VcIiwgXCJcXFxcJHNlbGVjdFwiLCBcIlxcXFwkc3RhY2tcIiwgXCJcXFxcJHRlc3RcIiwgXCJcXFxcJHRleHRcIiwgXCJcXFxcJHRyYW5zbGF0ZVwiLCBcIlxcXFwkdmlld1wiLCBcIlxcXFwkeFwiLCBcIlxcXFwkeVwiLCBcIlxcXFwkYVwiLCBcIlxcXFwkY1wiLCBcIlxcXFwkZFwiLCBcIlxcXFwkZVwiLCBcIlxcXFwkZWNcIiwgXCJcXFxcJGVzXCIsIFwiXFxcXCRldFwiLCBcIlxcXFwkZlwiLCBcIlxcXFwkZm5cIiwgXCJcXFxcJGdcIiwgXCJcXFxcJGhcIiwgXCJcXFxcJGlcIiwgXCJcXFxcJGpcIiwgXCJcXFxcJGxcIiwgXCJcXFxcJG5cIiwgXCJcXFxcJG5hXCIsIFwiXFxcXCRvXCIsIFwiXFxcXCRwXCIsIFwiXFxcXCRxXCIsIFwiXFxcXCRxbFwiLCBcIlxcXFwkcXNcIiwgXCJcXFxcJHJcIiwgXCJcXFxcJHJlXCIsIFwiXFxcXCRzXCIsIFwiXFxcXCRzdFwiLCBcIlxcXFwkdFwiLCBcIlxcXFwkdHJcIiwgXCJcXFxcJHZcIiwgXCJcXFxcJHpcIl07XG52YXIgaW50cmluc2ljRnVuY3MgPSB3b3JkUmVnZXhwKGludHJpbnNpY0Z1bmNzV29yZHMpO1xudmFyIGNvbW1hbmQgPSB3b3JkUmVnZXhwKGNvbW1hbmRLZXl3b3Jkcyk7XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICBzdGF0ZS5sYWJlbCA9IHRydWU7XG4gICAgc3RhdGUuY29tbWFuZE1vZGUgPSAwO1xuICB9XG5cbiAgLy8gVGhlIDxzcGFjZT4gY2hhcmFjdGVyIGhhcyBtZWFuaW5nIGluIE1VTVBTLiBJZ25vcmluZyBjb25zZWN1dGl2ZVxuICAvLyBzcGFjZXMgd291bGQgaW50ZXJmZXJlIHdpdGggaW50ZXJwcmV0aW5nIHdoZXRoZXIgdGhlIG5leHQgbm9uLXNwYWNlXG4gIC8vIGNoYXJhY3RlciBiZWxvbmdzIHRvIHRoZSBjb21tYW5kIG9yIGFyZ3VtZW50IGNvbnRleHQuXG5cbiAgLy8gRXhhbWluZSBlYWNoIGNoYXJhY3RlciBhbmQgdXBkYXRlIGEgbW9kZSB2YXJpYWJsZSB3aG9zZSBpbnRlcnByZXRhdGlvbiBpczpcbiAgLy8gICA+MCA9PiBjb21tYW5kICAgIDAgPT4gYXJndW1lbnQgICAgPDAgPT4gY29tbWFuZCBwb3N0LWNvbmRpdGlvbmFsXG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgaWYgKGNoID09IFwiIFwiIHx8IGNoID09IFwiXFx0XCIpIHsgLy8gUHJlLXByb2Nlc3MgPHNwYWNlPlxuICAgIHN0YXRlLmxhYmVsID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlLmNvbW1hbmRNb2RlID09IDApXG4gICAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IDE7XG4gICAgZWxzZSBpZiAoKHN0YXRlLmNvbW1hbmRNb2RlIDwgMCkgfHwgKHN0YXRlLmNvbW1hbmRNb2RlID09IDIpKVxuICAgICAgc3RhdGUuY29tbWFuZE1vZGUgPSAwO1xuICB9IGVsc2UgaWYgKChjaCAhPSBcIi5cIikgJiYgKHN0YXRlLmNvbW1hbmRNb2RlID4gMCkpIHtcbiAgICBpZiAoY2ggPT0gXCI6XCIpXG4gICAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IC0xOyAgIC8vIFNJUyAtIENvbW1hbmQgcG9zdC1jb25kaXRpb25hbFxuICAgIGVsc2VcbiAgICAgIHN0YXRlLmNvbW1hbmRNb2RlID0gMjtcbiAgfVxuXG4gIC8vIERvIG5vdCBjb2xvciBwYXJhbWV0ZXIgbGlzdCBhcyBsaW5lIHRhZ1xuICBpZiAoKGNoID09PSBcIihcIikgfHwgKGNoID09PSBcIlxcdTAwMDlcIikpXG4gICAgc3RhdGUubGFiZWwgPSBmYWxzZTtcblxuICAvLyBNVU1QUyBjb21tZW50IHN0YXJ0cyB3aXRoIFwiO1wiXG4gIGlmIChjaCA9PT0gXCI7XCIpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgLy8gTnVtYmVyIExpdGVyYWxzIC8vIFNJUy9STE0gLSBNVU1QUyBwZXJtaXRzIGNhbm9uaWMgbnVtYmVyIGZvbGxvd2VkIGJ5IGNvbmNhdGVuYXRlIG9wZXJhdG9yXG4gIGlmIChzdHJlYW0ubWF0Y2goL15bLStdP1xcZCsoXFwuXFxkKyk/KFtlRV1bLStdP1xcZCspPy8pKVxuICAgIHJldHVybiBcIm51bWJlclwiO1xuXG4gIC8vIEhhbmRsZSBTdHJpbmdzXG4gIGlmIChjaCA9PSAnXCInKSB7XG4gICAgaWYgKHN0cmVhbS5za2lwVG8oJ1wiJykpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgb3BlcmF0b3JzIGFuZCBEZWxpbWl0ZXJzXG4gIGlmIChzdHJlYW0ubWF0Y2goZG91YmxlT3BlcmF0b3JzKSB8fCBzdHJlYW0ubWF0Y2goc2luZ2xlT3BlcmF0b3JzKSlcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuXG4gIC8vIFByZXZlbnRzIGxlYWRpbmcgXCIuXCIgaW4gRE8gYmxvY2sgZnJvbSBmYWxsaW5nIHRocm91Z2ggdG8gZXJyb3JcbiAgaWYgKHN0cmVhbS5tYXRjaChzaW5nbGVEZWxpbWl0ZXJzKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYnJhY2tldHMudGVzdChjaCkpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5jb21tYW5kTW9kZSA+IDAgJiYgc3RyZWFtLm1hdGNoKGNvbW1hbmQpKVxuICAgIHJldHVybiBcImNvbnRyb2xLZXl3b3JkXCI7XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChpbnRyaW5zaWNGdW5jcykpXG4gICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuXG4gIGlmIChzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKVxuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG5cbiAgLy8gRGV0ZWN0IGRvbGxhci1zaWduIHdoZW4gbm90IGEgZG9jdW1lbnRlZCBpbnRyaW5zaWMgZnVuY3Rpb25cbiAgLy8gXCJeXCIgbWF5IGludHJvZHVjZSBhIEdWTiBvciBTU1ZOIC0gQ29sb3Igc2FtZSBhcyBmdW5jdGlvblxuICBpZiAoY2ggPT09IFwiJFwiIHx8IGNoID09PSBcIl5cIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICB9XG5cbiAgLy8gTVVNUFMgSW5kaXJlY3Rpb25cbiAgaWYgKGNoID09PSBcIkBcIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwic3RyaW5nLnNwZWNpYWxcIjtcbiAgfVxuXG4gIGlmICgvW1xcdyVdLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdyVdLyk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBub24tZGV0ZWN0ZWQgaXRlbXNcbiAgc3RyZWFtLm5leHQoKTtcbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZXhwb3J0IGNvbnN0IG11bXBzID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGZhbHNlLFxuICAgICAgY29tbWFuZE1vZGU6IDBcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5sYWJlbCkgcmV0dXJuIFwidGFnXCI7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9