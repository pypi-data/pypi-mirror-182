"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_r_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/r.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/r.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ r)
/* harmony export */ });
function wordObj(words) {
  var res = {};
  for (var i = 0; i < words.length; ++i) res[words[i]] = true;
  return res;
}
var commonAtoms = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
var commonBuiltins = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
var commonKeywords = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
var commonBlockKeywords = ["if", "else", "repeat", "while", "function", "for"];

var atoms = wordObj(commonAtoms);
var builtins = wordObj(commonBuiltins);
var keywords = wordObj(commonKeywords);
var blockkeywords = wordObj(commonBlockKeywords);
var opChars = /[+\-*\/^<>=!&|~$:]/;
var curPunc;

function tokenBase(stream, state) {
  curPunc = null;
  var ch = stream.next();
  if (ch == "#") {
    stream.skipToEnd();
    return "comment";
  } else if (ch == "0" && stream.eat("x")) {
    stream.eatWhile(/[\da-f]/i);
    return "number";
  } else if (ch == "." && stream.eat(/\d/)) {
    stream.match(/\d*(?:e[+\-]?\d+)?/);
    return "number";
  } else if (/\d/.test(ch)) {
    stream.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/);
    return "number";
  } else if (ch == "'" || ch == '"') {
    state.tokenize = tokenString(ch);
    return "string";
  } else if (ch == "`") {
    stream.match(/[^`]+`/);
    return "string.special";
  } else if (ch == "." && stream.match(/.(?:[.]|\d+)/)) {
    return "keyword";
  } else if (/[a-zA-Z\.]/.test(ch)) {
    stream.eatWhile(/[\w\.]/);
    var word = stream.current();
    if (atoms.propertyIsEnumerable(word)) return "atom";
    if (keywords.propertyIsEnumerable(word)) {
      // Block keywords start new blocks, except 'else if', which only starts
      // one new block for the 'if', no block for the 'else'.
      if (blockkeywords.propertyIsEnumerable(word) &&
          !stream.match(/\s*if(\s+|$)/, false))
        curPunc = "block";
      return "keyword";
    }
    if (builtins.propertyIsEnumerable(word)) return "builtin";
    return "variable";
  } else if (ch == "%") {
    if (stream.skipTo("%")) stream.next();
    return "variableName.special";
  } else if (
    (ch == "<" && stream.eat("-")) ||
      (ch == "<" && stream.match("<-")) ||
      (ch == "-" && stream.match(/>>?/))
  ) {
    return "operator";
  } else if (ch == "=" && state.ctx.argList) {
    return "operator";
  } else if (opChars.test(ch)) {
    if (ch == "$") return "operator";
    stream.eatWhile(opChars);
    return "operator";
  } else if (/[\(\){}\[\];]/.test(ch)) {
    curPunc = ch;
    if (ch == ";") return "punctuation";
    return null;
  } else {
    return null;
  }
}

function tokenString(quote) {
  return function(stream, state) {
    if (stream.eat("\\")) {
      var ch = stream.next();
      if (ch == "x") stream.match(/^[a-f0-9]{2}/i);
      else if ((ch == "u" || ch == "U") && stream.eat("{") && stream.skipTo("}")) stream.next();
      else if (ch == "u") stream.match(/^[a-f0-9]{4}/i);
      else if (ch == "U") stream.match(/^[a-f0-9]{8}/i);
      else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);
      return "string.special";
    } else {
      var next;
      while ((next = stream.next()) != null) {
        if (next == quote) { state.tokenize = tokenBase; break; }
        if (next == "\\") { stream.backUp(1); break; }
      }
      return "string";
    }
  };
}

var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4

function push(state, type, stream) {
  state.ctx = {type: type,
               indent: state.indent,
               flags: 0,
               column: stream.column(),
               prev: state.ctx};
}
function setFlag(state, flag) {
  var ctx = state.ctx
  state.ctx = {type: ctx.type,
               indent: ctx.indent,
               flags: ctx.flags | flag,
               column: ctx.column,
               prev: ctx.prev}
}
function pop(state) {
  state.indent = state.ctx.indent;
  state.ctx = state.ctx.prev;
}

const r = {
  startState: function(indentUnit) {
    return {tokenize: tokenBase,
            ctx: {type: "top",
                  indent: -indentUnit,
                  flags: ALIGN_NO},
            indent: 0,
            afterIdent: false};
  },

  token: function(stream, state) {
    if (stream.sol()) {
      if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO
      if (state.ctx.flags & BRACELESS) pop(state)
      state.indent = stream.indentation();
    }
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);
    if (style != "comment" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES)

    if ((curPunc == ";" || curPunc == "{" || curPunc == "}") && state.ctx.type == "block") pop(state);
    if (curPunc == "{") push(state, "}", stream);
    else if (curPunc == "(") {
      push(state, ")", stream);
      if (state.afterIdent) state.ctx.argList = true;
    }
    else if (curPunc == "[") push(state, "]", stream);
    else if (curPunc == "block") push(state, "block", stream);
    else if (curPunc == state.ctx.type) pop(state);
    else if (state.ctx.type == "block" && style != "comment") setFlag(state, BRACELESS)
    state.afterIdent = style == "variable" || style == "keyword";
    return style;
  },

  indent: function(state, textAfter, cx) {
    if (state.tokenize != tokenBase) return 0;
    var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,
        closing = firstChar == ctx.type;
    if (ctx.flags & BRACELESS) ctx = ctx.prev
    if (ctx.type == "block") return ctx.indent + (firstChar == "{" ? 0 : cx.unit);
    else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);
    else return ctx.indent + (closing ? 0 : cx.unit);
  },

  languageData: {
    wordChars: ".",
    commentTokens: {line: "#"},
    autocomplete: commonAtoms.concat(commonBuiltins, commonKeywords)
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfcl9qcy5mODg2MjhiM2Y0MmM0MjhmMjEzMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQixLQUFLO0FBQzFCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DLHdEQUF3RCxzQkFBc0I7QUFDOUUsa0RBQWtELEVBQUU7QUFDcEQsa0RBQWtELEVBQUU7QUFDcEQsc0RBQXNELElBQUk7QUFDMUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWTtBQUNaLGtCQUFrQjtBQUNsQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQixrQkFBa0I7QUFDMUQscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZE9iaih3b3Jkcykge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHJlc1t3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gcmVzO1xufVxudmFyIGNvbW1vbkF0b21zID0gW1wiTlVMTFwiLCBcIk5BXCIsIFwiSW5mXCIsIFwiTmFOXCIsIFwiTkFfaW50ZWdlcl9cIiwgXCJOQV9yZWFsX1wiLCBcIk5BX2NvbXBsZXhfXCIsIFwiTkFfY2hhcmFjdGVyX1wiLCBcIlRSVUVcIiwgXCJGQUxTRVwiXTtcbnZhciBjb21tb25CdWlsdGlucyA9IFtcImxpc3RcIiwgXCJxdW90ZVwiLCBcImJxdW90ZVwiLCBcImV2YWxcIiwgXCJyZXR1cm5cIiwgXCJjYWxsXCIsIFwicGFyc2VcIiwgXCJkZXBhcnNlXCJdO1xudmFyIGNvbW1vbktleXdvcmRzID0gW1wiaWZcIiwgXCJlbHNlXCIsIFwicmVwZWF0XCIsIFwid2hpbGVcIiwgXCJmdW5jdGlvblwiLCBcImZvclwiLCBcImluXCIsIFwibmV4dFwiLCBcImJyZWFrXCJdO1xudmFyIGNvbW1vbkJsb2NrS2V5d29yZHMgPSBbXCJpZlwiLCBcImVsc2VcIiwgXCJyZXBlYXRcIiwgXCJ3aGlsZVwiLCBcImZ1bmN0aW9uXCIsIFwiZm9yXCJdO1xuXG52YXIgYXRvbXMgPSB3b3JkT2JqKGNvbW1vbkF0b21zKTtcbnZhciBidWlsdGlucyA9IHdvcmRPYmooY29tbW9uQnVpbHRpbnMpO1xudmFyIGtleXdvcmRzID0gd29yZE9iaihjb21tb25LZXl3b3Jkcyk7XG52YXIgYmxvY2trZXl3b3JkcyA9IHdvcmRPYmooY29tbW9uQmxvY2tLZXl3b3Jkcyk7XG52YXIgb3BDaGFycyA9IC9bK1xcLSpcXC9ePD49ISZ8fiQ6XS87XG52YXIgY3VyUHVuYztcblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgY3VyUHVuYyA9IG51bGw7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIgJiYgc3RyZWFtLmVhdChcInhcIikpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiLlwiICYmIHN0cmVhbS5lYXQoL1xcZC8pKSB7XG4gICAgc3RyZWFtLm1hdGNoKC9cXGQqKD86ZVsrXFwtXT9cXGQrKT8vKTtcbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXFxkKig/OlxcLlxcZCspPyg/OmVbK1xcLV1cXGQrKT9MPy8pO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcImBcIikge1xuICAgIHN0cmVhbS5tYXRjaCgvW15gXStgLyk7XG4gICAgcmV0dXJuIFwic3RyaW5nLnNwZWNpYWxcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goLy4oPzpbLl18XFxkKykvKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfSBlbHNlIGlmICgvW2EtekEtWlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBpZiAoYXRvbXMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpIHJldHVybiBcImF0b21cIjtcbiAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpIHtcbiAgICAgIC8vIEJsb2NrIGtleXdvcmRzIHN0YXJ0IG5ldyBibG9ja3MsIGV4Y2VwdCAnZWxzZSBpZicsIHdoaWNoIG9ubHkgc3RhcnRzXG4gICAgICAvLyBvbmUgbmV3IGJsb2NrIGZvciB0aGUgJ2lmJywgbm8gYmxvY2sgZm9yIHRoZSAnZWxzZScuXG4gICAgICBpZiAoYmxvY2trZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJlxuICAgICAgICAgICFzdHJlYW0ubWF0Y2goL1xccyppZihcXHMrfCQpLywgZmFsc2UpKVxuICAgICAgICBjdXJQdW5jID0gXCJibG9ja1wiO1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH1cbiAgICBpZiAoYnVpbHRpbnMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiJVwiKSB7XG4gICAgaWYgKHN0cmVhbS5za2lwVG8oXCIlXCIpKSBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCI7XG4gIH0gZWxzZSBpZiAoXG4gICAgKGNoID09IFwiPFwiICYmIHN0cmVhbS5lYXQoXCItXCIpKSB8fFxuICAgICAgKGNoID09IFwiPFwiICYmIHN0cmVhbS5tYXRjaChcIjwtXCIpKSB8fFxuICAgICAgKGNoID09IFwiLVwiICYmIHN0cmVhbS5tYXRjaCgvPj4/LykpXG4gICkge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIgJiYgc3RhdGUuY3R4LmFyZ0xpc3QpIHtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9IGVsc2UgaWYgKG9wQ2hhcnMudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gXCIkXCIpIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgc3RyZWFtLmVhdFdoaWxlKG9wQ2hhcnMpO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSBpZiAoL1tcXChcXCl7fVxcW1xcXTtdLy50ZXN0KGNoKSkge1xuICAgIGN1clB1bmMgPSBjaDtcbiAgICBpZiAoY2ggPT0gXCI7XCIpIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIlxcXFxcIikpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gXCJ4XCIpIHN0cmVhbS5tYXRjaCgvXlthLWYwLTldezJ9L2kpO1xuICAgICAgZWxzZSBpZiAoKGNoID09IFwidVwiIHx8IGNoID09IFwiVVwiKSAmJiBzdHJlYW0uZWF0KFwie1wiKSAmJiBzdHJlYW0uc2tpcFRvKFwifVwiKSkgc3RyZWFtLm5leHQoKTtcbiAgICAgIGVsc2UgaWYgKGNoID09IFwidVwiKSBzdHJlYW0ubWF0Y2goL15bYS1mMC05XXs0fS9pKTtcbiAgICAgIGVsc2UgaWYgKGNoID09IFwiVVwiKSBzdHJlYW0ubWF0Y2goL15bYS1mMC05XXs4fS9pKTtcbiAgICAgIGVsc2UgaWYgKC9bMC03XS8udGVzdChjaCkpIHN0cmVhbS5tYXRjaCgvXlswLTddezEsMn0vKTtcbiAgICAgIHJldHVybiBcInN0cmluZy5zcGVjaWFsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0O1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSkgeyBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTsgYnJlYWs7IH1cbiAgICAgICAgaWYgKG5leHQgPT0gXCJcXFxcXCIpIHsgc3RyZWFtLmJhY2tVcCgxKTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIEFMSUdOX1lFUyA9IDEsIEFMSUdOX05PID0gMiwgQlJBQ0VMRVNTID0gNFxuXG5mdW5jdGlvbiBwdXNoKHN0YXRlLCB0eXBlLCBzdHJlYW0pIHtcbiAgc3RhdGUuY3R4ID0ge3R5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICBpbmRlbnQ6IHN0YXRlLmluZGVudCxcbiAgICAgICAgICAgICAgIGZsYWdzOiAwLFxuICAgICAgICAgICAgICAgY29sdW1uOiBzdHJlYW0uY29sdW1uKCksXG4gICAgICAgICAgICAgICBwcmV2OiBzdGF0ZS5jdHh9O1xufVxuZnVuY3Rpb24gc2V0RmxhZyhzdGF0ZSwgZmxhZykge1xuICB2YXIgY3R4ID0gc3RhdGUuY3R4XG4gIHN0YXRlLmN0eCA9IHt0eXBlOiBjdHgudHlwZSxcbiAgICAgICAgICAgICAgIGluZGVudDogY3R4LmluZGVudCxcbiAgICAgICAgICAgICAgIGZsYWdzOiBjdHguZmxhZ3MgfCBmbGFnLFxuICAgICAgICAgICAgICAgY29sdW1uOiBjdHguY29sdW1uLFxuICAgICAgICAgICAgICAgcHJldjogY3R4LnByZXZ9XG59XG5mdW5jdGlvbiBwb3Aoc3RhdGUpIHtcbiAgc3RhdGUuaW5kZW50ID0gc3RhdGUuY3R4LmluZGVudDtcbiAgc3RhdGUuY3R4ID0gc3RhdGUuY3R4LnByZXY7XG59XG5cbmV4cG9ydCBjb25zdCByID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgICAgY3R4OiB7dHlwZTogXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgIGluZGVudDogLWluZGVudFVuaXQsXG4gICAgICAgICAgICAgICAgICBmbGFnczogQUxJR05fTk99LFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgYWZ0ZXJJZGVudDogZmFsc2V9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgaWYgKChzdGF0ZS5jdHguZmxhZ3MgJiAzKSA9PSAwKSBzdGF0ZS5jdHguZmxhZ3MgfD0gQUxJR05fTk9cbiAgICAgIGlmIChzdGF0ZS5jdHguZmxhZ3MgJiBCUkFDRUxFU1MpIHBvcChzdGF0ZSlcbiAgICAgIHN0YXRlLmluZGVudCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdHlsZSAhPSBcImNvbW1lbnRcIiAmJiAoc3RhdGUuY3R4LmZsYWdzICYgQUxJR05fTk8pID09IDApIHNldEZsYWcoc3RhdGUsIEFMSUdOX1lFUylcblxuICAgIGlmICgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwie1wiIHx8IGN1clB1bmMgPT0gXCJ9XCIpICYmIHN0YXRlLmN0eC50eXBlID09IFwiYmxvY2tcIikgcG9wKHN0YXRlKTtcbiAgICBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaChzdGF0ZSwgXCJ9XCIsIHN0cmVhbSk7XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikge1xuICAgICAgcHVzaChzdGF0ZSwgXCIpXCIsIHN0cmVhbSk7XG4gICAgICBpZiAoc3RhdGUuYWZ0ZXJJZGVudCkgc3RhdGUuY3R4LmFyZ0xpc3QgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoKHN0YXRlLCBcIl1cIiwgc3RyZWFtKTtcbiAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiYmxvY2tcIikgcHVzaChzdGF0ZSwgXCJibG9ja1wiLCBzdHJlYW0pO1xuICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gc3RhdGUuY3R4LnR5cGUpIHBvcChzdGF0ZSk7XG4gICAgZWxzZSBpZiAoc3RhdGUuY3R4LnR5cGUgPT0gXCJibG9ja1wiICYmIHN0eWxlICE9IFwiY29tbWVudFwiKSBzZXRGbGFnKHN0YXRlLCBCUkFDRUxFU1MpXG4gICAgc3RhdGUuYWZ0ZXJJZGVudCA9IHN0eWxlID09IFwidmFyaWFibGVcIiB8fCBzdHlsZSA9PSBcImtleXdvcmRcIjtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSwgY3R4ID0gc3RhdGUuY3R4LFxuICAgICAgICBjbG9zaW5nID0gZmlyc3RDaGFyID09IGN0eC50eXBlO1xuICAgIGlmIChjdHguZmxhZ3MgJiBCUkFDRUxFU1MpIGN0eCA9IGN0eC5wcmV2XG4gICAgaWYgKGN0eC50eXBlID09IFwiYmxvY2tcIikgcmV0dXJuIGN0eC5pbmRlbnQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IGN4LnVuaXQpO1xuICAgIGVsc2UgaWYgKGN0eC5mbGFncyAmIEFMSUdOX1lFUykgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICBlbHNlIHJldHVybiBjdHguaW5kZW50ICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgd29yZENoYXJzOiBcIi5cIixcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCJ9LFxuICAgIGF1dG9jb21wbGV0ZTogY29tbW9uQXRvbXMuY29uY2F0KGNvbW1vbkJ1aWx0aW5zLCBjb21tb25LZXl3b3JkcylcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==