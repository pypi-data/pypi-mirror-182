"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_haxe_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haxe.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haxe.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "haxe": () => (/* binding */ haxe),
/* harmony export */   "hxml": () => (/* binding */ hxml)
/* harmony export */ });
// Tokenizer

function kw(type) {return {type: type, style: "keyword"};}
var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
var operator = kw("operator"), atom = {type: "atom", style: "atom"}, attribute = {type:"attribute", style: "attribute"};
var type = kw("typedef");
var keywords = {
  "if": A, "while": A, "else": B, "do": B, "try": B,
  "return": C, "break": C, "continue": C, "new": C, "throw": C,
  "var": kw("var"), "inline":attribute, "static": attribute, "using":kw("import"),
  "public": attribute, "private": attribute, "cast": kw("cast"), "import": kw("import"), "macro": kw("macro"),
  "function": kw("function"), "catch": kw("catch"), "untyped": kw("untyped"), "callback": kw("cb"),
  "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
  "in": operator, "never": kw("property_access"), "trace":kw("trace"),
  "class": type, "abstract":type, "enum":type, "interface":type, "typedef":type, "extends":type, "implements":type, "dynamic":type,
  "true": atom, "false": atom, "null": atom
};

var isOperatorChar = /[+\-*&%=<>!?|]/;

function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

function toUnescaped(stream, end) {
  var escaped = false, next;
  while ((next = stream.next()) != null) {
    if (next == end && !escaped)
      return true;
    escaped = !escaped && next == "\\";
  }
}

// Used as scratch variables to communicate multiple values without
// consing up tons of objects.
var type, content;
function ret(tp, style, cont) {
  type = tp; content = cont;
  return style;
}

function haxeTokenBase(stream, state) {
  var ch = stream.next();
  if (ch == '"' || ch == "'") {
    return chain(stream, state, haxeTokenString(ch));
  } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
    return ret(ch);
  } else if (ch == "0" && stream.eat(/x/i)) {
    stream.eatWhile(/[\da-f]/i);
    return ret("number", "number");
  } else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
    stream.match(/^\d*(?:\.\d*(?!\.))?(?:[eE][+\-]?\d+)?/);
    return ret("number", "number");
  } else if (state.reAllowed && (ch == "~" && stream.eat(/\//))) {
    toUnescaped(stream, "/");
    stream.eatWhile(/[gimsu]/);
    return ret("regexp", "string.special");
  } else if (ch == "/") {
    if (stream.eat("*")) {
      return chain(stream, state, haxeTokenComment);
    } else if (stream.eat("/")) {
      stream.skipToEnd();
      return ret("comment", "comment");
    } else {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
  } else if (ch == "#") {
    stream.skipToEnd();
    return ret("conditional", "meta");
  } else if (ch == "@") {
    stream.eat(/:/);
    stream.eatWhile(/[\w_]/);
    return ret ("metadata", "meta");
  } else if (isOperatorChar.test(ch)) {
    stream.eatWhile(isOperatorChar);
    return ret("operator", null, stream.current());
  } else {
    var word;
    if(/[A-Z]/.test(ch)) {
      stream.eatWhile(/[\w_<>]/);
      word = stream.current();
      return ret("type", "type", word);
    } else {
      stream.eatWhile(/[\w_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :
        ret("variable", "variable", word);
    }
  }
}

function haxeTokenString(quote) {
  return function(stream, state) {
    if (toUnescaped(stream, quote))
      state.tokenize = haxeTokenBase;
    return ret("string", "string");
  };
}

function haxeTokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == "/" && maybeEnd) {
      state.tokenize = haxeTokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return ret("comment", "comment");
}

// Parser

var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true};

function HaxeLexical(indented, column, type, align, prev, info) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.prev = prev;
  this.info = info;
  if (align != null) this.align = align;
}

function inScope(state, varname) {
  for (var v = state.localVars; v; v = v.next)
    if (v.name == varname) return true;
}

function parseHaxe(state, style, type, content, stream) {
  var cc = state.cc;
  // Communicate our context to the combinators.
  // (Less wasteful than consing up a hundred closures on every call.)
  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

  if (!state.lexical.hasOwnProperty("align"))
    state.lexical.align = true;

  while(true) {
    var combinator = cc.length ? cc.pop() : statement;
    if (combinator(type, content)) {
      while(cc.length && cc[cc.length - 1].lex)
        cc.pop()();
      if (cx.marked) return cx.marked;
      if (type == "variable" && inScope(state, content)) return "variableName.local";
      if (type == "variable" && imported(state, content)) return "variableName.special";
      return style;
    }
  }
}

function imported(state, typename) {
  if (/[a-z]/.test(typename.charAt(0)))
    return false;
  var len = state.importedtypes.length;
  for (var i = 0; i<len; i++)
    if(state.importedtypes[i]==typename) return true;
}

function registerimport(importname) {
  var state = cx.state;
  for (var t = state.importedtypes; t; t = t.next)
    if(t.name == importname) return;
  state.importedtypes = { name: importname, next: state.importedtypes };
}
// Combinator utils

var cx = {state: null, column: null, marked: null, cc: null};
function pass() {
  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
}
function cont() {
  pass.apply(null, arguments);
  return true;
}
function inList(name, list) {
  for (var v = list; v; v = v.next)
    if (v.name == name) return true;
  return false;
}
function register(varname) {
  var state = cx.state;
  if (state.context) {
    cx.marked = "def";
    if (inList(varname, state.localVars)) return;
    state.localVars = {name: varname, next: state.localVars};
  } else if (state.globalVars) {
    if (inList(varname, state.globalVars)) return;
    state.globalVars = {name: varname, next: state.globalVars};
  }
}

// Combinators

var defaultVars = {name: "this", next: null};
function pushcontext() {
  if (!cx.state.context) cx.state.localVars = defaultVars;
  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
}
function popcontext() {
  cx.state.localVars = cx.state.context.vars;
  cx.state.context = cx.state.context.prev;
}
popcontext.lex = true;
function pushlex(type, info) {
  var result = function() {
    var state = cx.state;
    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
  };
  result.lex = true;
  return result;
}
function poplex() {
  var state = cx.state;
  if (state.lexical.prev) {
    if (state.lexical.type == ")")
      state.indented = state.lexical.indented;
    state.lexical = state.lexical.prev;
  }
}
poplex.lex = true;

function expect(wanted) {
  function f(type) {
    if (type == wanted) return cont();
    else if (wanted == ";") return pass();
    else return cont(f);
  }
  return f;
}

function statement(type) {
  if (type == "@") return cont(metadef);
  if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
  if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
  if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
  if (type == "{") return cont(pushlex("}"), pushcontext, block, poplex, popcontext);
  if (type == ";") return cont();
  if (type == "attribute") return cont(maybeattribute);
  if (type == "function") return cont(functiondef);
  if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                 poplex, statement, poplex);
  if (type == "variable") return cont(pushlex("stat"), maybelabel);
  if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                    block, poplex, poplex);
  if (type == "case") return cont(expression, expect(":"));
  if (type == "default") return cont(expect(":"));
  if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                   statement, poplex, popcontext);
  if (type == "import") return cont(importdef, expect(";"));
  if (type == "typedef") return cont(typedef);
  return pass(pushlex("stat"), expression, expect(";"), poplex);
}
function expression(type) {
  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
  if (type == "type" ) return cont(maybeoperator);
  if (type == "function") return cont(functiondef);
  if (type == "keyword c") return cont(maybeexpression);
  if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
  if (type == "operator") return cont(expression);
  if (type == "[") return cont(pushlex("]"), commasep(maybeexpression, "]"), poplex, maybeoperator);
  if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
  return cont();
}
function maybeexpression(type) {
  if (type.match(/[;\}\)\],]/)) return pass();
  return pass(expression);
}

function maybeoperator(type, value) {
  if (type == "operator" && /\+\+|--/.test(value)) return cont(maybeoperator);
  if (type == "operator" || type == ":") return cont(expression);
  if (type == ";") return;
  if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
  if (type == ".") return cont(property, maybeoperator);
  if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
}

function maybeattribute(type) {
  if (type == "attribute") return cont(maybeattribute);
  if (type == "function") return cont(functiondef);
  if (type == "var") return cont(vardef1);
}

function metadef(type) {
  if(type == ":") return cont(metadef);
  if(type == "variable") return cont(metadef);
  if(type == "(") return cont(pushlex(")"), commasep(metaargs, ")"), poplex, statement);
}
function metaargs(type) {
  if(type == "variable") return cont();
}

function importdef (type, value) {
  if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
  else if(type == "variable" || type == "property" || type == "." || value == "*") return cont(importdef);
}

function typedef (type, value)
{
  if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
  else if (type == "type" && /[A-Z]/.test(value.charAt(0))) { return cont(); }
}

function maybelabel(type) {
  if (type == ":") return cont(poplex, statement);
  return pass(maybeoperator, expect(";"), poplex);
}
function property(type) {
  if (type == "variable") {cx.marked = "property"; return cont();}
}
function objprop(type) {
  if (type == "variable") cx.marked = "property";
  if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
}
function commasep(what, end) {
  function proceed(type) {
    if (type == ",") return cont(what, proceed);
    if (type == end) return cont();
    return cont(expect(end));
  }
  return function(type) {
    if (type == end) return cont();
    else return pass(what, proceed);
  };
}
function block(type) {
  if (type == "}") return cont();
  return pass(statement, block);
}
function vardef1(type, value) {
  if (type == "variable"){register(value); return cont(typeuse, vardef2);}
  return cont();
}
function vardef2(type, value) {
  if (value == "=") return cont(expression, vardef2);
  if (type == ",") return cont(vardef1);
}
function forspec1(type, value) {
  if (type == "variable") {
    register(value);
    return cont(forin, expression)
  } else {
    return pass()
  }
}
function forin(_type, value) {
  if (value == "in") return cont();
}
function functiondef(type, value) {
  //function names starting with upper-case letters are recognised as types, so cludging them together here.
  if (type == "variable" || type == "type") {register(value); return cont(functiondef);}
  if (value == "new") return cont(functiondef);
  if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, typeuse, statement, popcontext);
}
function typeuse(type) {
  if(type == ":") return cont(typestring);
}
function typestring(type) {
  if(type == "type") return cont();
  if(type == "variable") return cont();
  if(type == "{") return cont(pushlex("}"), commasep(typeprop, "}"), poplex);
}
function typeprop(type) {
  if(type == "variable") return cont(typeuse);
}
function funarg(type, value) {
  if (type == "variable") {register(value); return cont(typeuse);}
}

// Interface
const haxe = {
  startState: function(indentUnit) {
    var defaulttypes = ["Int", "Float", "String", "Void", "Std", "Bool", "Dynamic", "Array"];
    var state = {
      tokenize: haxeTokenBase,
      reAllowed: true,
      kwAllowed: true,
      cc: [],
      lexical: new HaxeLexical(-indentUnit, 0, "block", false),
      importedtypes: defaulttypes,
      context: null,
      indented: 0
    };
    return state;
  },

  token: function(stream, state) {
    if (stream.sol()) {
      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = false;
      state.indented = stream.indentation();
    }
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);
    if (type == "comment") return style;
    state.reAllowed = !!(type == "operator" || type == "keyword c" || type.match(/^[\[{}\(,;:]$/));
    state.kwAllowed = type != '.';
    return parseHaxe(state, style, type, content, stream);
  },

  indent: function(state, textAfter, cx) {
    if (state.tokenize != haxeTokenBase) return 0;
    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
    if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
    var type = lexical.type, closing = firstChar == type;
    if (type == "vardef") return lexical.indented + 4;
    else if (type == "form" && firstChar == "{") return lexical.indented;
    else if (type == "stat" || type == "form") return lexical.indented + cx.unit;
    else if (lexical.info == "switch" && !closing)
      return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? cx.unit : 2 * cx.unit);
    else if (lexical.align) return lexical.column + (closing ? 0 : 1);
    else return lexical.indented + (closing ? 0 : cx.unit);
  },

  languageData: {
    indentOnInput: /^\s*[{}]$/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}}
  }
};

const hxml = {
  startState: function () {
    return {
      define: false,
      inString: false
    };
  },
  token: function (stream, state) {
    var ch = stream.peek();
    var sol = stream.sol();

    ///* comments */
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    if (sol && ch == "-") {
      var style = "variable-2";

      stream.eat(/-/);

      if (stream.peek() == "-") {
        stream.eat(/-/);
        style = "keyword a";
      }

      if (stream.peek() == "D") {
        stream.eat(/[D]/);
        style = "keyword c";
        state.define = true;
      }

      stream.eatWhile(/[A-Z]/i);
      return style;
    }

    var ch = stream.peek();

    if (state.inString == false && ch == "'") {
      state.inString = true;
      stream.next();
    }

    if (state.inString == true) {
      if (stream.skipTo("'")) {

      } else {
        stream.skipToEnd();
      }

      if (stream.peek() == "'") {
        stream.next();
        state.inString = false;
      }

      return "string";
    }

    stream.next();
    return null;
  },
  languageData: {
    commentTokens: {line: "#"}
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9oYXhlX2pzLjFjNTY5MmFjMDQzYzE3MDc0YTAwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSx1Q0FBdUMsNEJBQTRCLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCLE1BQU07QUFDM0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JB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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9oYXhlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRva2VuaXplclxuXG5mdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbnZhciBBID0ga3coXCJrZXl3b3JkIGFcIiksIEIgPSBrdyhcImtleXdvcmQgYlwiKSwgQyA9IGt3KFwia2V5d29yZCBjXCIpO1xudmFyIG9wZXJhdG9yID0ga3coXCJvcGVyYXRvclwiKSwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifSwgYXR0cmlidXRlID0ge3R5cGU6XCJhdHRyaWJ1dGVcIiwgc3R5bGU6IFwiYXR0cmlidXRlXCJ9O1xudmFyIHR5cGUgPSBrdyhcInR5cGVkZWZcIik7XG52YXIga2V5d29yZHMgPSB7XG4gIFwiaWZcIjogQSwgXCJ3aGlsZVwiOiBBLCBcImVsc2VcIjogQiwgXCJkb1wiOiBCLCBcInRyeVwiOiBCLFxuICBcInJldHVyblwiOiBDLCBcImJyZWFrXCI6IEMsIFwiY29udGludWVcIjogQywgXCJuZXdcIjogQywgXCJ0aHJvd1wiOiBDLFxuICBcInZhclwiOiBrdyhcInZhclwiKSwgXCJpbmxpbmVcIjphdHRyaWJ1dGUsIFwic3RhdGljXCI6IGF0dHJpYnV0ZSwgXCJ1c2luZ1wiOmt3KFwiaW1wb3J0XCIpLFxuICBcInB1YmxpY1wiOiBhdHRyaWJ1dGUsIFwicHJpdmF0ZVwiOiBhdHRyaWJ1dGUsIFwiY2FzdFwiOiBrdyhcImNhc3RcIiksIFwiaW1wb3J0XCI6IGt3KFwiaW1wb3J0XCIpLCBcIm1hY3JvXCI6IGt3KFwibWFjcm9cIiksXG4gIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLCBcInVudHlwZWRcIjoga3coXCJ1bnR5cGVkXCIpLCBcImNhbGxiYWNrXCI6IGt3KFwiY2JcIiksXG4gIFwiZm9yXCI6IGt3KFwiZm9yXCIpLCBcInN3aXRjaFwiOiBrdyhcInN3aXRjaFwiKSwgXCJjYXNlXCI6IGt3KFwiY2FzZVwiKSwgXCJkZWZhdWx0XCI6IGt3KFwiZGVmYXVsdFwiKSxcbiAgXCJpblwiOiBvcGVyYXRvciwgXCJuZXZlclwiOiBrdyhcInByb3BlcnR5X2FjY2Vzc1wiKSwgXCJ0cmFjZVwiOmt3KFwidHJhY2VcIiksXG4gIFwiY2xhc3NcIjogdHlwZSwgXCJhYnN0cmFjdFwiOnR5cGUsIFwiZW51bVwiOnR5cGUsIFwiaW50ZXJmYWNlXCI6dHlwZSwgXCJ0eXBlZGVmXCI6dHlwZSwgXCJleHRlbmRzXCI6dHlwZSwgXCJpbXBsZW1lbnRzXCI6dHlwZSwgXCJkeW5hbWljXCI6dHlwZSxcbiAgXCJ0cnVlXCI6IGF0b20sIFwiZmFsc2VcIjogYXRvbSwgXCJudWxsXCI6IGF0b21cbn07XG5cbnZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fF0vO1xuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHRvVW5lc2NhcGVkKHN0cmVhbSwgZW5kKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PSBlbmQgJiYgIWVzY2FwZWQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgfVxufVxuXG4vLyBVc2VkIGFzIHNjcmF0Y2ggdmFyaWFibGVzIHRvIGNvbW11bmljYXRlIG11bHRpcGxlIHZhbHVlcyB3aXRob3V0XG4vLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbnZhciB0eXBlLCBjb250ZW50O1xuZnVuY3Rpb24gcmV0KHRwLCBzdHlsZSwgY29udCkge1xuICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGhheGVUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCBoYXhlVG9rZW5TdHJpbmcoY2gpKTtcbiAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgIHJldHVybiByZXQoY2gpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiMFwiICYmIHN0cmVhbS5lYXQoL3gvaSkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgfHwgY2ggPT0gXCItXCIgJiYgc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKig/IVxcLikpPyg/OltlRV1bK1xcLV0/XFxkKyk/Lyk7XG4gICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5yZUFsbG93ZWQgJiYgKGNoID09IFwiflwiICYmIHN0cmVhbS5lYXQoL1xcLy8pKSkge1xuICAgIHRvVW5lc2NhcGVkKHN0cmVhbSwgXCIvXCIpO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2dpbXN1XS8pO1xuICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmcuc3BlY2lhbFwiKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIGhheGVUb2tlbkNvbW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBudWxsLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIHJldChcImNvbmRpdGlvbmFsXCIsIFwibWV0YVwiKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIkBcIikge1xuICAgIHN0cmVhbS5lYXQoLzovKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICAgIHJldHVybiByZXQgKFwibWV0YWRhdGFcIiwgXCJtZXRhXCIpO1xuICB9IGVsc2UgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgbnVsbCwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdvcmQ7XG4gICAgaWYoL1tBLVpdLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3Xzw+XS8pO1xuICAgICAgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICByZXR1cm4gcmV0KFwidHlwZVwiLCBcInR5cGVcIiwgd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19dLyk7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG4gICAgICByZXR1cm4gKGtub3duICYmIHN0YXRlLmt3QWxsb3dlZCkgPyByZXQoa25vd24udHlwZSwga25vd24uc3R5bGUsIHdvcmQpIDpcbiAgICAgICAgcmV0KFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB3b3JkKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGF4ZVRva2VuU3RyaW5nKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHRvVW5lc2NhcGVkKHN0cmVhbSwgcXVvdGUpKVxuICAgICAgc3RhdGUudG9rZW5pemUgPSBoYXhlVG9rZW5CYXNlO1xuICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhheGVUb2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaGF4ZVRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xufVxuXG4vLyBQYXJzZXJcblxudmFyIGF0b21pY1R5cGVzID0ge1wiYXRvbVwiOiB0cnVlLCBcIm51bWJlclwiOiB0cnVlLCBcInZhcmlhYmxlXCI6IHRydWUsIFwic3RyaW5nXCI6IHRydWUsIFwicmVnZXhwXCI6IHRydWV9O1xuXG5mdW5jdGlvbiBIYXhlTGV4aWNhbChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldiwgaW5mbykge1xuICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZXYgPSBwcmV2O1xuICB0aGlzLmluZm8gPSBpbmZvO1xuICBpZiAoYWxpZ24gIT0gbnVsbCkgdGhpcy5hbGlnbiA9IGFsaWduO1xufVxuXG5mdW5jdGlvbiBpblNjb3BlKHN0YXRlLCB2YXJuYW1lKSB7XG4gIGZvciAodmFyIHYgPSBzdGF0ZS5sb2NhbFZhcnM7IHY7IHYgPSB2Lm5leHQpXG4gICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIYXhlKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gIHZhciBjYyA9IHN0YXRlLmNjO1xuICAvLyBDb21tdW5pY2F0ZSBvdXIgY29udGV4dCB0byB0aGUgY29tYmluYXRvcnMuXG4gIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gIGN4LnN0YXRlID0gc3RhdGU7IGN4LnN0cmVhbSA9IHN0cmVhbTsgY3gubWFya2VkID0gbnVsbCwgY3guY2MgPSBjYztcblxuICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICB3aGlsZSh0cnVlKSB7XG4gICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IHN0YXRlbWVudDtcbiAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgd2hpbGUoY2MubGVuZ3RoICYmIGNjW2NjLmxlbmd0aCAtIDFdLmxleClcbiAgICAgICAgY2MucG9wKCkoKTtcbiAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgaW5TY29wZShzdGF0ZSwgY29udGVudCkpIHJldHVybiBcInZhcmlhYmxlTmFtZS5sb2NhbFwiO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGltcG9ydGVkKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIjtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0ZWQoc3RhdGUsIHR5cGVuYW1lKSB7XG4gIGlmICgvW2Etel0vLnRlc3QodHlwZW5hbWUuY2hhckF0KDApKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBsZW4gPSBzdGF0ZS5pbXBvcnRlZHR5cGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGk8bGVuOyBpKyspXG4gICAgaWYoc3RhdGUuaW1wb3J0ZWR0eXBlc1tpXT09dHlwZW5hbWUpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlcmltcG9ydChpbXBvcnRuYW1lKSB7XG4gIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICBmb3IgKHZhciB0ID0gc3RhdGUuaW1wb3J0ZWR0eXBlczsgdDsgdCA9IHQubmV4dClcbiAgICBpZih0Lm5hbWUgPT0gaW1wb3J0bmFtZSkgcmV0dXJuO1xuICBzdGF0ZS5pbXBvcnRlZHR5cGVzID0geyBuYW1lOiBpbXBvcnRuYW1lLCBuZXh0OiBzdGF0ZS5pbXBvcnRlZHR5cGVzIH07XG59XG4vLyBDb21iaW5hdG9yIHV0aWxzXG5cbnZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbmZ1bmN0aW9uIHBhc3MoKSB7XG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbn1cbmZ1bmN0aW9uIGNvbnQoKSB7XG4gIHBhc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpbkxpc3QobmFtZSwgbGlzdCkge1xuICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dClcbiAgICBpZiAodi5uYW1lID09IG5hbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgIGN4Lm1hcmtlZCA9IFwiZGVmXCI7XG4gICAgaWYgKGluTGlzdCh2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpKSByZXR1cm47XG4gICAgc3RhdGUubG9jYWxWYXJzID0ge25hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmxvY2FsVmFyc307XG4gIH0gZWxzZSBpZiAoc3RhdGUuZ2xvYmFsVmFycykge1xuICAgIGlmIChpbkxpc3QodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycykpIHJldHVybjtcbiAgICBzdGF0ZS5nbG9iYWxWYXJzID0ge25hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmdsb2JhbFZhcnN9O1xuICB9XG59XG5cbi8vIENvbWJpbmF0b3JzXG5cbnZhciBkZWZhdWx0VmFycyA9IHtuYW1lOiBcInRoaXNcIiwgbmV4dDogbnVsbH07XG5mdW5jdGlvbiBwdXNoY29udGV4dCgpIHtcbiAgaWYgKCFjeC5zdGF0ZS5jb250ZXh0KSBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBkZWZhdWx0VmFycztcbiAgY3guc3RhdGUuY29udGV4dCA9IHtwcmV2OiBjeC5zdGF0ZS5jb250ZXh0LCB2YXJzOiBjeC5zdGF0ZS5sb2NhbFZhcnN9O1xufVxuZnVuY3Rpb24gcG9wY29udGV4dCgpIHtcbiAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzO1xuICBjeC5zdGF0ZS5jb250ZXh0ID0gY3guc3RhdGUuY29udGV4dC5wcmV2O1xufVxucG9wY29udGV4dC5sZXggPSB0cnVlO1xuZnVuY3Rpb24gcHVzaGxleCh0eXBlLCBpbmZvKSB7XG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEhheGVMZXhpY2FsKHN0YXRlLmluZGVudGVkLCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUsIG51bGwsIHN0YXRlLmxleGljYWwsIGluZm8pO1xuICB9O1xuICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gIGlmIChzdGF0ZS5sZXhpY2FsLnByZXYpIHtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgIHN0YXRlLmxleGljYWwgPSBzdGF0ZS5sZXhpY2FsLnByZXY7XG4gIH1cbn1cbnBvcGxleC5sZXggPSB0cnVlO1xuXG5mdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gIGZ1bmN0aW9uIGYodHlwZSkge1xuICAgIGlmICh0eXBlID09IHdhbnRlZCkgcmV0dXJuIGNvbnQoKTtcbiAgICBlbHNlIGlmICh3YW50ZWQgPT0gXCI7XCIpIHJldHVybiBwYXNzKCk7XG4gICAgZWxzZSByZXR1cm4gY29udChmKTtcbiAgfVxuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gc3RhdGVtZW50KHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJAXCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIpLCB2YXJkZWYxLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcImtleXdvcmQgYVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHB1c2hjb250ZXh0LCBibG9jaywgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KCk7XG4gIGlmICh0eXBlID09IFwiYXR0cmlidXRlXCIpIHJldHVybiBjb250KG1heWJlYXR0cmlidXRlKTtcbiAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHBlY3QoXCIoXCIpLCBwdXNobGV4KFwiKVwiKSwgZm9yc3BlYzEsIGV4cGVjdChcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BsZXgsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgbWF5YmVsYWJlbCk7XG4gIGlmICh0eXBlID09IFwic3dpdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBwdXNobGV4KFwifVwiLCBcInN3aXRjaFwiKSwgZXhwZWN0KFwie1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLCBwb3BsZXgsIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwiY2FzZVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpKTtcbiAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICBpZiAodHlwZSA9PSBcImNhdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgZXhwZWN0KFwiKFwiKSwgZnVuYXJnLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQsIHBvcGxleCwgcG9wY29udGV4dCk7XG4gIGlmICh0eXBlID09IFwiaW1wb3J0XCIpIHJldHVybiBjb250KGltcG9ydGRlZiwgZXhwZWN0KFwiO1wiKSk7XG4gIGlmICh0eXBlID09IFwidHlwZWRlZlwiKSByZXR1cm4gY29udCh0eXBlZGVmKTtcbiAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG59XG5mdW5jdGlvbiBleHByZXNzaW9uKHR5cGUpIHtcbiAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJ0eXBlXCIgKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwia2V5d29yZCBjXCIpIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbik7XG4gIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGNvbW1hc2VwKG1heWJlZXhwcmVzc2lvbiwgXCJdXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNvbW1hc2VwKG9ianByb3AsIFwifVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgcmV0dXJuIGNvbnQoKTtcbn1cbmZ1bmN0aW9uIG1heWJlZXhwcmVzc2lvbih0eXBlKSB7XG4gIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xufVxuXG5mdW5jdGlvbiBtYXliZW9wZXJhdG9yKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiB8fCB0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChleHByZXNzaW9uLCBcIilcIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChwcm9wZXJ0eSwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVhdHRyaWJ1dGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBcImF0dHJpYnV0ZVwiKSByZXR1cm4gY29udChtYXliZWF0dHJpYnV0ZSk7XG4gIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udCh2YXJkZWYxKTtcbn1cblxuZnVuY3Rpb24gbWV0YWRlZih0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gIGlmKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChtZXRhYXJncywgXCIpXCIpLCBwb3BsZXgsIHN0YXRlbWVudCk7XG59XG5mdW5jdGlvbiBtZXRhYXJncyh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCgpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnRkZWYgKHR5cGUsIHZhbHVlKSB7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJlZ2lzdGVyaW1wb3J0KHZhbHVlKTsgcmV0dXJuIGNvbnQoKTsgfVxuICBlbHNlIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IHR5cGUgPT0gXCJwcm9wZXJ0eVwiIHx8IHR5cGUgPT0gXCIuXCIgfHwgdmFsdWUgPT0gXCIqXCIpIHJldHVybiBjb250KGltcG9ydGRlZik7XG59XG5cbmZ1bmN0aW9uIHR5cGVkZWYgKHR5cGUsIHZhbHVlKVxue1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZWdpc3RlcmltcG9ydCh2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcInR5cGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZXR1cm4gY29udCgpOyB9XG59XG5cbmZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQocG9wbGV4LCBzdGF0ZW1lbnQpO1xuICByZXR1cm4gcGFzcyhtYXliZW9wZXJhdG9yLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xufVxuZnVuY3Rpb24gcHJvcGVydHkodHlwZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7IHJldHVybiBjb250KCk7fVxufVxuZnVuY3Rpb24gb2JqcHJvcCh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIGV4cHJlc3Npb24pO1xufVxuZnVuY3Rpb24gY29tbWFzZXAod2hhdCwgZW5kKSB7XG4gIGZ1bmN0aW9uIHByb2NlZWQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh3aGF0LCBwcm9jZWVkKTtcbiAgICBpZiAodHlwZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgIGVsc2UgcmV0dXJuIHBhc3Mod2hhdCwgcHJvY2VlZCk7XG4gIH07XG59XG5mdW5jdGlvbiBibG9jayh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbn1cbmZ1bmN0aW9uIHZhcmRlZjEodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKXtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KHR5cGV1c2UsIHZhcmRlZjIpO31cbiAgcmV0dXJuIGNvbnQoKTtcbn1cbmZ1bmN0aW9uIHZhcmRlZjIodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IFwiPVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCB2YXJkZWYyKTtcbiAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KHZhcmRlZjEpO1xufVxuZnVuY3Rpb24gZm9yc3BlYzEodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgcmVnaXN0ZXIodmFsdWUpO1xuICAgIHJldHVybiBjb250KGZvcmluLCBleHByZXNzaW9uKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXNzKClcbiAgfVxufVxuZnVuY3Rpb24gZm9yaW4oX3R5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBcImluXCIpIHJldHVybiBjb250KCk7XG59XG5mdW5jdGlvbiBmdW5jdGlvbmRlZih0eXBlLCB2YWx1ZSkge1xuICAvL2Z1bmN0aW9uIG5hbWVzIHN0YXJ0aW5nIHdpdGggdXBwZXItY2FzZSBsZXR0ZXJzIGFyZSByZWNvZ25pc2VkIGFzIHR5cGVzLCBzbyBjbHVkZ2luZyB0aGVtIHRvZ2V0aGVyIGhlcmUuXG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIiB8fCB0eXBlID09IFwidHlwZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICBpZiAodmFsdWUgPT0gXCJuZXdcIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIHB1c2hjb250ZXh0LCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCB0eXBldXNlLCBzdGF0ZW1lbnQsIHBvcGNvbnRleHQpO1xufVxuZnVuY3Rpb24gdHlwZXVzZSh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVzdHJpbmcpO1xufVxuZnVuY3Rpb24gdHlwZXN0cmluZyh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCJ0eXBlXCIpIHJldHVybiBjb250KCk7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCgpO1xuICBpZih0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY29tbWFzZXAodHlwZXByb3AsIFwifVwiKSwgcG9wbGV4KTtcbn1cbmZ1bmN0aW9uIHR5cGVwcm9wKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHR5cGV1c2UpO1xufVxuZnVuY3Rpb24gZnVuYXJnKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQodHlwZXVzZSk7fVxufVxuXG4vLyBJbnRlcmZhY2VcbmV4cG9ydCBjb25zdCBoYXhlID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgdmFyIGRlZmF1bHR0eXBlcyA9IFtcIkludFwiLCBcIkZsb2F0XCIsIFwiU3RyaW5nXCIsIFwiVm9pZFwiLCBcIlN0ZFwiLCBcIkJvb2xcIiwgXCJEeW5hbWljXCIsIFwiQXJyYXlcIl07XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgdG9rZW5pemU6IGhheGVUb2tlbkJhc2UsXG4gICAgICByZUFsbG93ZWQ6IHRydWUsXG4gICAgICBrd0FsbG93ZWQ6IHRydWUsXG4gICAgICBjYzogW10sXG4gICAgICBsZXhpY2FsOiBuZXcgSGF4ZUxleGljYWwoLWluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgaW1wb3J0ZWR0eXBlczogZGVmYXVsdHR5cGVzLFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIGluZGVudGVkOiAwXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgIHN0YXRlLnJlQWxsb3dlZCA9ICEhKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlLm1hdGNoKC9eW1xcW3t9XFwoLDs6XSQvKSk7XG4gICAgc3RhdGUua3dBbGxvd2VkID0gdHlwZSAhPSAnLic7XG4gICAgcmV0dXJuIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBoYXhlVG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGxleGljYWwgPSBzdGF0ZS5sZXhpY2FsO1xuICAgIGlmIChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgIHZhciB0eXBlID0gbGV4aWNhbC50eXBlLCBjbG9zaW5nID0gZmlyc3RDaGFyID09IHR5cGU7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyA0O1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtcbiAgICBlbHNlIGlmICh0eXBlID09IFwic3RhdFwiIHx8IHR5cGUgPT0gXCJmb3JtXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgY3gudW5pdDtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmluZm8gPT0gXCJzd2l0Y2hcIiAmJiAhY2xvc2luZylcbiAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gY3gudW5pdCA6IDIgKiBjeC51bml0KTtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmFsaWduKSByZXR1cm4gbGV4aWNhbC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW3t9XSQvLFxuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGh4bWwgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmaW5lOiBmYWxzZSxcbiAgICAgIGluU3RyaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKTtcblxuICAgIC8vLyogY29tbWVudHMgKi9cbiAgICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgaWYgKHNvbCAmJiBjaCA9PSBcIi1cIikge1xuICAgICAgdmFyIHN0eWxlID0gXCJ2YXJpYWJsZS0yXCI7XG5cbiAgICAgIHN0cmVhbS5lYXQoLy0vKTtcblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCItXCIpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgvLS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBhXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiRFwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1tEXS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBjXCI7XG4gICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW0EtWl0vaSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIGlmIChzdGF0ZS5pblN0cmluZyA9PSBmYWxzZSAmJiBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gdHJ1ZSkge1xuICAgICAgaWYgKHN0cmVhbS5za2lwVG8oXCInXCIpKSB7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=