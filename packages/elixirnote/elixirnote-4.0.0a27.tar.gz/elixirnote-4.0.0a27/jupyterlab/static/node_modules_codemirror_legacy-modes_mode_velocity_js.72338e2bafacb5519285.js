"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_velocity_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/velocity.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/velocity.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "velocity": () => (/* binding */ velocity)
/* harmony export */ });
function parseWords(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = parseWords("#end #else #break #stop #[[ #]] " +
                          "#{end} #{else} #{break} #{stop}");
var functions = parseWords("#if #elseif #foreach #set #include #parse #macro #define #evaluate " +
                           "#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}");
var specials = parseWords("$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent");
var isOperatorChar = /[+\-*&%=<>!?:\/|]/;

function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}
function tokenBase(stream, state) {
  var beforeParams = state.beforeParams;
  state.beforeParams = false;
  var ch = stream.next();
  // start of unparsed string?
  if ((ch == "'") && !state.inString && state.inParams) {
    state.lastTokenWasBuiltin = false;
    return chain(stream, state, tokenString(ch));
  }
  // start of parsed string?
  else if ((ch == '"')) {
    state.lastTokenWasBuiltin = false;
    if (state.inString) {
      state.inString = false;
      return "string";
    }
    else if (state.inParams)
      return chain(stream, state, tokenString(ch));
  }
  // is it one of the special signs []{}().,;? Separator?
  else if (/[\[\]{}\(\),;\.]/.test(ch)) {
    if (ch == "(" && beforeParams)
      state.inParams = true;
    else if (ch == ")") {
      state.inParams = false;
      state.lastTokenWasBuiltin = true;
    }
    return null;
  }
  // start of a number value?
  else if (/\d/.test(ch)) {
    state.lastTokenWasBuiltin = false;
    stream.eatWhile(/[\w\.]/);
    return "number";
  }
  // multi line comment?
  else if (ch == "#" && stream.eat("*")) {
    state.lastTokenWasBuiltin = false;
    return chain(stream, state, tokenComment);
  }
  // unparsed content?
  else if (ch == "#" && stream.match(/ *\[ *\[/)) {
    state.lastTokenWasBuiltin = false;
    return chain(stream, state, tokenUnparsed);
  }
  // single line comment?
  else if (ch == "#" && stream.eat("#")) {
    state.lastTokenWasBuiltin = false;
    stream.skipToEnd();
    return "comment";
  }
  // variable?
  else if (ch == "$") {
    stream.eat("!");
    stream.eatWhile(/[\w\d\$_\.{}-]/);
    // is it one of the specials?
    if (specials && specials.propertyIsEnumerable(stream.current())) {
      return "keyword";
    }
    else {
      state.lastTokenWasBuiltin = true;
      state.beforeParams = true;
      return "builtin";
    }
  }
  // is it a operator?
  else if (isOperatorChar.test(ch)) {
    state.lastTokenWasBuiltin = false;
    stream.eatWhile(isOperatorChar);
    return "operator";
  }
  else {
    // get the whole word
    stream.eatWhile(/[\w\$_{}@]/);
    var word = stream.current();
    // is it one of the listed keywords?
    if (keywords && keywords.propertyIsEnumerable(word))
      return "keyword";
    // is it one of the listed functions?
    if (functions && functions.propertyIsEnumerable(word) ||
        (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()=="(") &&
        !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {
      state.beforeParams = true;
      state.lastTokenWasBuiltin = false;
      return "keyword";
    }
    if (state.inString) {
      state.lastTokenWasBuiltin = false;
      return "string";
    }
    if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)=="." && state.lastTokenWasBuiltin)
      return "builtin";
    // default: just a "word"
    state.lastTokenWasBuiltin = false;
    return null;
  }
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if ((next == quote) && !escaped) {
        end = true;
        break;
      }
      if (quote=='"' && stream.peek() == '$' && !escaped) {
        state.inString = true;
        end = true;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end) state.tokenize = tokenBase;
    return "string";
  };
}

function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == "#" && maybeEnd) {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function tokenUnparsed(stream, state) {
  var maybeEnd = 0, ch;
  while (ch = stream.next()) {
    if (ch == "#" && maybeEnd == 2) {
      state.tokenize = tokenBase;
      break;
    }
    if (ch == "]")
      maybeEnd++;
    else if (ch != " ")
      maybeEnd = 0;
  }
  return "meta";
}
// Interface

const velocity = {
  startState: function() {
    return {
      tokenize: tokenBase,
      beforeParams: false,
      inParams: false,
      inString: false,
      lastTokenWasBuiltin: false
    };
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    return state.tokenize(stream, state);
  },
  languageData: {
    commentTokens: {line: "##", block: {open: "#*", close: "*#"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfdmVsb2NpdHlfanMuNzIzMzhlMmJhZmFjYjU1MTkyODUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLO0FBQzFEO0FBQ0EsOEJBQThCLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsU0FBUztBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QyxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdmVsb2NpdHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcGFyc2VXb3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG52YXIga2V5d29yZHMgPSBwYXJzZVdvcmRzKFwiI2VuZCAjZWxzZSAjYnJlYWsgI3N0b3AgI1tbICNdXSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiI3tlbmR9ICN7ZWxzZX0gI3ticmVha30gI3tzdG9wfVwiKTtcbnZhciBmdW5jdGlvbnMgPSBwYXJzZVdvcmRzKFwiI2lmICNlbHNlaWYgI2ZvcmVhY2ggI3NldCAjaW5jbHVkZSAjcGFyc2UgI21hY3JvICNkZWZpbmUgI2V2YWx1YXRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI3tpZn0gI3tlbHNlaWZ9ICN7Zm9yZWFjaH0gI3tzZXR9ICN7aW5jbHVkZX0gI3twYXJzZX0gI3ttYWNyb30gI3tkZWZpbmV9ICN7ZXZhbHVhdGV9XCIpO1xudmFyIHNwZWNpYWxzID0gcGFyc2VXb3JkcyhcIiRmb3JlYWNoLmNvdW50ICRmb3JlYWNoLmhhc05leHQgJGZvcmVhY2guZmlyc3QgJGZvcmVhY2gubGFzdCAkZm9yZWFjaC50b3Btb3N0ICRmb3JlYWNoLnBhcmVudC5jb3VudCAkZm9yZWFjaC5wYXJlbnQuaGFzTmV4dCAkZm9yZWFjaC5wYXJlbnQuZmlyc3QgJGZvcmVhY2gucGFyZW50Lmxhc3QgJGZvcmVhY2gucGFyZW50ICR2ZWxvY2l0eUNvdW50ICQhYm9keUNvbnRlbnQgJGJvZHlDb250ZW50XCIpO1xudmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT86XFwvfF0vO1xuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgYmVmb3JlUGFyYW1zID0gc3RhdGUuYmVmb3JlUGFyYW1zO1xuICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSBmYWxzZTtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgLy8gc3RhcnQgb2YgdW5wYXJzZWQgc3RyaW5nP1xuICBpZiAoKGNoID09IFwiJ1wiKSAmJiAhc3RhdGUuaW5TdHJpbmcgJiYgc3RhdGUuaW5QYXJhbXMpIHtcbiAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gIH1cbiAgLy8gc3RhcnQgb2YgcGFyc2VkIHN0cmluZz9cbiAgZWxzZSBpZiAoKGNoID09ICdcIicpKSB7XG4gICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZS5pblN0cmluZykge1xuICAgICAgc3RhdGUuaW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5pblBhcmFtcylcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCkpO1xuICB9XG4gIC8vIGlzIGl0IG9uZSBvZiB0aGUgc3BlY2lhbCBzaWducyBbXXt9KCkuLDs/IFNlcGFyYXRvcj9cbiAgZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFwuXS8udGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gXCIoXCIgJiYgYmVmb3JlUGFyYW1zKVxuICAgICAgc3RhdGUuaW5QYXJhbXMgPSB0cnVlO1xuICAgIGVsc2UgaWYgKGNoID09IFwiKVwiKSB7XG4gICAgICBzdGF0ZS5pblBhcmFtcyA9IGZhbHNlO1xuICAgICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIHN0YXJ0IG9mIGEgbnVtYmVyIHZhbHVlP1xuICBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH1cbiAgLy8gbXVsdGkgbGluZSBjb21tZW50P1xuICBlbHNlIGlmIChjaCA9PSBcIiNcIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5Db21tZW50KTtcbiAgfVxuICAvLyB1bnBhcnNlZCBjb250ZW50P1xuICBlbHNlIGlmIChjaCA9PSBcIiNcIiAmJiBzdHJlYW0ubWF0Y2goLyAqXFxbICpcXFsvKSkge1xuICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5VbnBhcnNlZCk7XG4gIH1cbiAgLy8gc2luZ2xlIGxpbmUgY29tbWVudD9cbiAgZWxzZSBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLmVhdChcIiNcIikpIHtcbiAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuICAvLyB2YXJpYWJsZT9cbiAgZWxzZSBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICBzdHJlYW0uZWF0KFwiIVwiKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXGRcXCRfXFwue30tXS8pO1xuICAgIC8vIGlzIGl0IG9uZSBvZiB0aGUgc3BlY2lhbHM/XG4gICAgaWYgKHNwZWNpYWxzICYmIHNwZWNpYWxzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IHRydWU7XG4gICAgICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH1cbiAgfVxuICAvLyBpcyBpdCBhIG9wZXJhdG9yP1xuICBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0IHRoZSB3aG9sZSB3b3JkXG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX3t9QF0vKTtcbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgLy8gaXMgaXQgb25lIG9mIHRoZSBsaXN0ZWQga2V5d29yZHM/XG4gICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIC8vIGlzIGl0IG9uZSBvZiB0aGUgbGlzdGVkIGZ1bmN0aW9ucz9cbiAgICBpZiAoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSB8fFxuICAgICAgICAoc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvXiNAP1thLXowLTlfXSsgKiQvaSkgJiYgc3RyZWFtLnBlZWsoKT09XCIoXCIpICYmXG4gICAgICAgICEoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkLnRvTG93ZXJDYXNlKCkpKSkge1xuICAgICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmluU3RyaW5nKSB7XG4gICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5wb3MgPiB3b3JkLmxlbmd0aCAmJiBzdHJlYW0uc3RyaW5nLmNoYXJBdChzdHJlYW0ucG9zLXdvcmQubGVuZ3RoLTEpPT1cIi5cIiAmJiBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluKVxuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIC8vIGRlZmF1bHQ6IGp1c3QgYSBcIndvcmRcIlxuICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmICgobmV4dCA9PSBxdW90ZSkgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocXVvdGU9PSdcIicgJiYgc3RyZWFtLnBlZWsoKSA9PSAnJCcgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICBpZiAoZW5kKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiI1wiICYmIG1heWJlRW5kKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblVucGFyc2VkKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gMCwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIjXCIgJiYgbWF5YmVFbmQgPT0gMikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09IFwiXVwiKVxuICAgICAgbWF5YmVFbmQrKztcbiAgICBlbHNlIGlmIChjaCAhPSBcIiBcIilcbiAgICAgIG1heWJlRW5kID0gMDtcbiAgfVxuICByZXR1cm4gXCJtZXRhXCI7XG59XG4vLyBJbnRlcmZhY2VcblxuZXhwb3J0IGNvbnN0IHZlbG9jaXR5ID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGJlZm9yZVBhcmFtczogZmFsc2UsXG4gICAgICBpblBhcmFtczogZmFsc2UsXG4gICAgICBpblN0cmluZzogZmFsc2UsXG4gICAgICBsYXN0VG9rZW5XYXNCdWlsdGluOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiIyNcIiwgYmxvY2s6IHtvcGVuOiBcIiMqXCIsIGNsb3NlOiBcIiojXCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9