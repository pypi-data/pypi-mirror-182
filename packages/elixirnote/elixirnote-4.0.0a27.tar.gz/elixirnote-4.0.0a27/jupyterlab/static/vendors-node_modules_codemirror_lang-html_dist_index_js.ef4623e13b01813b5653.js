"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_lang-html_dist_index_js"],{

/***/ "./node_modules/@codemirror/lang-html/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/lang-html/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "autoCloseTags": () => (/* binding */ autoCloseTags),
/* harmony export */   "html": () => (/* binding */ html),
/* harmony export */   "htmlCompletionSource": () => (/* binding */ htmlCompletionSource),
/* harmony export */   "htmlCompletionSourceWith": () => (/* binding */ htmlCompletionSourceWith),
/* harmony export */   "htmlLanguage": () => (/* binding */ htmlLanguage)
/* harmony export */ });
/* harmony import */ var _lezer_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/html */ "./node_modules/@lezer/html/dist/index.es.js");
/* harmony import */ var _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/lang-css */ "./node_modules/@codemirror/lang-css/dist/index.js");
/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/lang-javascript */ "./node_modules/@codemirror/lang-javascript/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.js");







const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    acronym: S,
    address: S,
    applet: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    basefont: S,
    bdi: S,
    bdo: S,
    big: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    dir: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    font: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    frame: S,
    frameset: S,
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noframes: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"] },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    s: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strike: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    tt: S,
    u: S,
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    onclick: null,
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: /*@__PURE__*/"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = /*@__PURE__*/new Schema;
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (let cur = tree.parent; cur; cur = cur.parent)
        if (cur.name == "Element") {
            if (skip)
                skip = false;
            else
                return cur;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[elementName(doc, findParentElement(tree, true))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = tree; parent = findParentElement(parent);) {
        let tagName = elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: allowedChildren(state.doc, tree, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: identifier };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
    let names = (info && info.attrs ? Object.keys(info.attrs).concat(schema.globalAttrNames) : schema.globalAttrNames);
    return { from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: identifier };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(pos), tree = around.resolve(pos, -1);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/**
HTML tag completion. Opens and closes tags and attributes in a
context-aware way.
*/
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/**
Create a completion source for HTML extended with additional tags
or attributes.
*/
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LRLanguage.define({
    parser: /*@__PURE__*/_lezer_html__WEBPACK_IMPORTED_MODULE_0__.parser.configure({
        props: [
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null, close;
                    for (let cur = context.node;;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
                }
            })
        ],
        wrap: /*@__PURE__*/(0,_lezer_html__WEBPACK_IMPORTED_MODULE_0__.configureNesting)([
            { tag: "script",
                attrs(attrs) {
                    return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
                },
                parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser },
            { tag: "style",
                attrs(attrs) {
                    return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
                },
                parser: _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.cssLanguage.parser }
        ])
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
/**
Language support for HTML, including
[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and
CSS support extensions.
*/
function html(config = {}) {
    let lang = htmlLanguage;
    if (config.matchClosingTags === false)
        lang = lang.configure({ dialect: "noMatch" });
    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(lang, [
        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
        config.autoCloseTags !== false ? autoCloseTags : [],
        (0,_codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascript)().support,
        (0,_codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.css)().support
    ]);
}
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text) => {
    if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
        !htmlLanguage.isActiveAt(view.state, from, -1))
        return false;
    let { state } = view;
    let changes = state.changeByRange(range => {
        var _a, _b, _c;
        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(head, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, around.parent, head)))
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name}>` } };
        }
        else if (text == "/" && around.name == "OpenTag") {
            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;
            if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
                let insert = `/${name}>`;
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length), changes: { from: head, insert } };
            }
        }
        return { range };
    });
    if (changes.changes.empty)
        return false;
    view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
});




/***/ }),

/***/ "./node_modules/@lezer/html/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/@lezer/html/dist/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "configureNesting": () => (/* binding */ configureNesting),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.js");
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.js");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.js");




// This file was generated by lezer-generator. You probably shouldn't edit it.
const scriptText = 53,
  StartCloseScriptTag = 1,
  styleText = 54,
  StartCloseStyleTag = 2,
  textareaText = 55,
  StartCloseTextareaTag = 3,
  StartTag = 4,
  StartScriptTag = 5,
  StartStyleTag = 6,
  StartTextareaTag = 7,
  StartSelfClosingTag = 8,
  StartCloseTag = 9,
  NoMatchStartCloseTag = 10,
  MismatchedStartCloseTag = 11,
  missingCloseTag = 56,
  IncompleteCloseTag = 12,
  commentContent$1 = 57,
  Element = 18,
  ScriptText = 27,
  StyleText = 30,
  TextareaText = 33,
  OpenTag = 35,
  Dialect_noMatch = 0;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset);
  while (isSpace(next)) next = input.peek(++offset);
  let name = "";
  for (;;) {
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  // Undefined to signal there's a <? or <!, null for just missing
  cachedInput = input; cachedPos = pos;
  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}

const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];

const elementContext = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  hash(context) { return context ? context.hash : 0 },
  strict: false
});

const tagStart = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    // End of file, close any open tags
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name = tagNameAfter(input, 0);
  if (name === undefined) return
  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)

  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name == parent) return input.acceptToken(StartCloseTag)
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name == "script") return input.acceptToken(StartScriptTag)
    if (name == "style") return input.acceptToken(StartStyleTag)
    if (name == "textarea") return input.acceptToken(StartTextareaTag)
    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, {contextual: true});

const commentContent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {
  for (let dashes = 0, i = 0;; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break
    }
    if (input.next == dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i > 3) input.acceptToken(commentContent$1, -2);
      break
    } else {
      dashes = 0;
    }
    input.advance();
  }
});

function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {
    // state means:
    // - 0 nothing matched
    // - 1 '<' matched
    // - 2 '</' + possibly whitespace matched
    // - 3-(1+tag.length) part of the tag matched
    // - lastState whole tag + possibly whitespace matched
    for (let state = 0, matchedLen = 0, i = 0;; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break
      }
      if (state == 0 && input.next == lessThan ||
          state == 1 && input.next == slash ||
          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break
      } else if ((input.next == 10 /* '\n' */ || input.next == 13 /* '\r' */) && i) {
        input.acceptToken(textToken, 1);
        break
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  })
}

const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);

const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);

const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);

const htmlHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({
  "Text RawText": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,
  "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,
  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,
  "MismatchedCloseTag/TagName": [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,  _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid],
  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,
  "AttributeValue UnquotedAttributeValue": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,
  Is: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,
  "EntityReference CharacterReference": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,
  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,
  ProcessingInst: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,
  DoctypeDecl: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.documentMeta
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 14,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*ZO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*lO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*}O7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
  stateData: "+h~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!_!wO!`!uO~O_!xO`!xOa!xO!a!wO!b!xO~O_!uO`!uOa!uO!_!{O!`!uO~O_!xO`!xOa!xO!a!{O!b!xO~O`_a!cwz!c~",
  goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 66,
  context: elementContext,
  nodeProps: [
    ["closedBy", -11,1,2,3,4,5,6,7,8,9,10,11,"EndTag",-4,19,29,32,35,"CloseTag"],
    ["group", -9,12,15,16,17,18,38,39,40,41,"Entity",14,"Entity TextContent",-3,27,30,33,"TextContent Entity"],
    ["openedBy", 26,"StartTag StartCloseTag",-4,28,31,34,36,"OpenTag"]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWa!ROX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: {"Document":[0,13]},
  dialects: {noMatch: 0},
  tokenPrec: 476
});

function getAttrs(element, input) {
  let attrs = Object.create(null);
  for (let att of element.firstChild.getChildren("Attribute")) {
    let name = att.getChild("AttributeName"), value = att.getChild("AttributeValue") || att.getChild("UnquotedAttributeValue");
    if (name) attrs[input.read(name.from, name.to)] =
      !value ? "" : value.name == "AttributeValue" ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs
}

function maybeNest(node, input, tags) {
  let attrs;
  for (let tag of tags) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input))))
      return {parser: tag.parser}
  }
  return null
}

// tags: {
//   tag: "script" | "style" | "textarea",
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser: Parser
// }[]
 
function configureNesting(tags) {
  let script = [], style = [], textarea = [];
  for (let tag of tags) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
    if (!array) throw new RangeError("Only script, style, and textarea tags can host nested parsers")
    array.push(tag);
  }
  return (0,_lezer_common__WEBPACK_IMPORTED_MODULE_2__.parseMixed)((node, input) => {
    let id = node.type.id;
    if (id == ScriptText) return maybeNest(node, input, script)
    if (id == StyleText) return maybeNest(node, input, style)
    if (id == TextareaText) return maybeNest(node, input, textarea)
    return null
  })
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sYW5nLWh0bWxfZGlzdF9pbmRleF9qcy5lZjQ2MjNlMTNiMDE4MTNiNTY1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNDO0FBQ3FCO0FBQy9CO0FBQ007QUFDeUQ7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxTQUFTLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxTQUFTLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxjQUFjO0FBQ2xDLGdCQUFnQixTQUFTLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxTQUFTLGVBQWU7QUFDcEMsZ0JBQWdCLFNBQVMsa0RBQWtEO0FBQzNFLGdCQUFnQixTQUFTLGNBQWM7QUFDdkM7QUFDQSxXQUFXLFNBQVMsOEJBQThCO0FBQ2xELGVBQWUsU0FBUyxrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLG9EQUFvRDtBQUMxRSxtQkFBbUIsU0FBUyxhQUFhO0FBQ3pDLGdCQUFnQixTQUFTLGtEQUFrRDtBQUMzRTtBQUNBO0FBQ0E7QUFD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LDhDQUE4Qyw4QkFBOEIsVUFBVSxxQ0FBcUMsdUVBQXVFLEdBQUcsa0JBQWtCO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRywrREFBK0QsSUFBSSwySkFBMkosS0FBSyxHQUFHLEtBQUssMG5DQUEwbkMsR0FBRyw0WEFBNFgsR0FBRyx3REFBd0QsSUFBSSxzQ0FBc0MsSUFBSSw2SUFBNkksS0FBSyxHQUFHLEtBQUssNElBQTRJLEtBQUsseUZBQXlGLEdBQUcsSUFBSSwwREFBMEQsR0FBRywwTUFBME0sSUFBSSxxcEJBQXFwQiw0UUFBNFE7QUFDLzhHO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWh0bWwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGxlemVyL2h0bWwvZGlzdC9pbmRleC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZXIsIGNvbmZpZ3VyZU5lc3RpbmcgfSBmcm9tICdAbGV6ZXIvaHRtbCc7XG5pbXBvcnQgeyBjc3NMYW5ndWFnZSwgY3NzIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZy1jc3MnO1xuaW1wb3J0IHsgamF2YXNjcmlwdExhbmd1YWdlLCBqYXZhc2NyaXB0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0JztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBmb2xkTm9kZVByb3AsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuY29uc3QgVGFyZ2V0cyA9IFtcIl9ibGFua1wiLCBcIl9zZWxmXCIsIFwiX3RvcFwiLCBcIl9wYXJlbnRcIl07XG5jb25zdCBDaGFyc2V0cyA9IFtcImFzY2lpXCIsIFwidXRmLThcIiwgXCJ1dGYtMTZcIiwgXCJsYXRpbjFcIiwgXCJsYXRpbjFcIl07XG5jb25zdCBNZXRob2RzID0gW1wiZ2V0XCIsIFwicG9zdFwiLCBcInB1dFwiLCBcImRlbGV0ZVwiXTtcbmNvbnN0IEVuY3MgPSBbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXTtcbmNvbnN0IEJvb2wgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIl07XG5jb25zdCBTID0ge307IC8vIEVtcHR5IHRhZyBzcGVjXG5jb25zdCBUYWdzID0ge1xuICAgIGE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhyZWY6IG51bGwsIHBpbmc6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBtZWRpYTogbnVsbCxcbiAgICAgICAgICAgIHRhcmdldDogVGFyZ2V0cyxcbiAgICAgICAgICAgIGhyZWZsYW5nOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFiYnI6IFMsXG4gICAgYWNyb255bTogUyxcbiAgICBhZGRyZXNzOiBTLFxuICAgIGFwcGxldDogUyxcbiAgICBhcmVhOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhbHQ6IG51bGwsIGNvb3JkczogbnVsbCwgaHJlZjogbnVsbCwgdGFyZ2V0OiBudWxsLCBwaW5nOiBudWxsLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsIGhyZWZsYW5nOiBudWxsLCB0eXBlOiBudWxsLFxuICAgICAgICAgICAgc2hhcGU6IFtcImRlZmF1bHRcIiwgXCJyZWN0XCIsIFwiY2lyY2xlXCIsIFwicG9seVwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhcnRpY2xlOiBTLFxuICAgIGFzaWRlOiBTLFxuICAgIGF1ZGlvOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIG1lZGlhZ3JvdXA6IG51bGwsXG4gICAgICAgICAgICBjcm9zc29yaWdpbjogW1wiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCJdLFxuICAgICAgICAgICAgcHJlbG9hZDogW1wibm9uZVwiLCBcIm1ldGFkYXRhXCIsIFwiYXV0b1wiXSxcbiAgICAgICAgICAgIGF1dG9wbGF5OiBbXCJhdXRvcGxheVwiXSxcbiAgICAgICAgICAgIGxvb3A6IFtcImxvb3BcIl0sXG4gICAgICAgICAgICBjb250cm9sczogW1wiY29udHJvbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYjogUyxcbiAgICBiYXNlOiB7IGF0dHJzOiB7IGhyZWY6IG51bGwsIHRhcmdldDogVGFyZ2V0cyB9IH0sXG4gICAgYmFzZWZvbnQ6IFMsXG4gICAgYmRpOiBTLFxuICAgIGJkbzogUyxcbiAgICBiaWc6IFMsXG4gICAgYmxvY2txdW90ZTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBib2R5OiBTLFxuICAgIGJyOiBTLFxuICAgIGJ1dHRvbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCwgbmFtZTogbnVsbCwgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICB0eXBlOiBbXCJzdWJtaXRcIiwgXCJyZXNldFwiLCBcImJ1dHRvblwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW52YXM6IHsgYXR0cnM6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgY2FwdGlvbjogUyxcbiAgICBjZW50ZXI6IFMsXG4gICAgY2l0ZTogUyxcbiAgICBjb2RlOiBTLFxuICAgIGNvbDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb2xncm91cDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb21tYW5kOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJjb21tYW5kXCIsIFwiY2hlY2tib3hcIiwgXCJyYWRpb1wiXSxcbiAgICAgICAgICAgIGxhYmVsOiBudWxsLCBpY29uOiBudWxsLCByYWRpb2dyb3VwOiBudWxsLCBjb21tYW5kOiBudWxsLCB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gICAgZGF0YWdyaWQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0gfSB9LFxuICAgIGRhdGFsaXN0OiB7IGF0dHJzOiB7IGRhdGE6IG51bGwgfSB9LFxuICAgIGRkOiBTLFxuICAgIGRlbDogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAgZGV0YWlsczogeyBhdHRyczogeyBvcGVuOiBbXCJvcGVuXCJdIH0gfSxcbiAgICBkZm46IFMsXG4gICAgZGlyOiBTLFxuICAgIGRpdjogUyxcbiAgICBkbDogUyxcbiAgICBkdDogUyxcbiAgICBlbTogUyxcbiAgICBlbWJlZDogeyBhdHRyczogeyBzcmM6IG51bGwsIHR5cGU6IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwgfSB9LFxuICAgIGV2ZW50c291cmNlOiB7IGF0dHJzOiB7IHNyYzogbnVsbCB9IH0sXG4gICAgZmllbGRzZXQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgICBmaWdjYXB0aW9uOiBTLFxuICAgIGZpZ3VyZTogUyxcbiAgICBmb250OiBTLFxuICAgIGZvb3RlcjogUyxcbiAgICBmb3JtOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhY3Rpb246IG51bGwsIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IENoYXJzZXRzLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgICAgICAgIGVuY3R5cGU6IEVuY3MsXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgdGFyZ2V0OiBUYXJnZXRzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZyYW1lOiBTLFxuICAgIGZyYW1lc2V0OiBTLFxuICAgIGgxOiBTLCBoMjogUywgaDM6IFMsIGg0OiBTLCBoNTogUywgaDY6IFMsXG4gICAgaGVhZDoge1xuICAgICAgICBjaGlsZHJlbjogW1widGl0bGVcIiwgXCJiYXNlXCIsIFwibGlua1wiLCBcInN0eWxlXCIsIFwibWV0YVwiLCBcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCIsIFwiY29tbWFuZFwiXVxuICAgIH0sXG4gICAgaGVhZGVyOiBTLFxuICAgIGhncm91cDogUyxcbiAgICBocjogUyxcbiAgICBodG1sOiB7XG4gICAgICAgIGF0dHJzOiB7IG1hbmlmZXN0OiBudWxsIH1cbiAgICB9LFxuICAgIGk6IFMsXG4gICAgaWZyYW1lOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHNyY2RvYzogbnVsbCwgbmFtZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNhbmRib3g6IFtcImFsbG93LXRvcC1uYXZpZ2F0aW9uXCIsIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiwgXCJhbGxvdy1mb3Jtc1wiLCBcImFsbG93LXNjcmlwdHNcIl0sXG4gICAgICAgICAgICBzZWFtbGVzczogW1wic2VhbWxlc3NcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhbHQ6IG51bGwsIHNyYzogbnVsbCwgaXNtYXA6IG51bGwsIHVzZW1hcDogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5wdXQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCwgbGlzdDogbnVsbCwgbWF4OiBudWxsLCBtYXhsZW5ndGg6IG51bGwsIG1pbjogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsIHBhdHRlcm46IG51bGwsIHBsYWNlaG9sZGVyOiBudWxsLCBzaXplOiBudWxsLCBzcmM6IG51bGwsXG4gICAgICAgICAgICBzdGVwOiBudWxsLCB2YWx1ZTogbnVsbCwgd2lkdGg6IG51bGwsXG4gICAgICAgICAgICBhY2NlcHQ6IFtcImF1ZGlvLypcIiwgXCJ2aWRlby8qXCIsIFwiaW1hZ2UvKlwiXSxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogW1wib25cIiwgXCJvZmZcIl0sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0sXG4gICAgICAgICAgICByZWFkb25seTogW1wicmVhZG9ubHlcIl0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wicmVxdWlyZWRcIl0sXG4gICAgICAgICAgICB0eXBlOiBbXCJoaWRkZW5cIiwgXCJ0ZXh0XCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIixcbiAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJzdWJtaXRcIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGluczogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAga2JkOiBTLFxuICAgIGtleWdlbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgY2hhbGxlbmdlOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBrZXl0eXBlOiBbXCJSU0FcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsIH0gfSxcbiAgICBsZWdlbmQ6IFMsXG4gICAgbGk6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwgfSB9LFxuICAgIGxpbms6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhyZWY6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2l6ZXM6IFtcImFsbFwiLCBcIjE2eDE2XCIsIFwiMTZ4MTYgMzJ4MzJcIiwgXCIxNngxNiAzMngzMiA2NHg2NFwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXA6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgbWFyazogUyxcbiAgICBtZW51OiB7IGF0dHJzOiB7IGxhYmVsOiBudWxsLCB0eXBlOiBbXCJsaXN0XCIsIFwiY29udGV4dFwiLCBcInRvb2xiYXJcIl0gfSB9LFxuICAgIG1ldGE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0cyxcbiAgICAgICAgICAgIG5hbWU6IFtcInZpZXdwb3J0XCIsIFwiYXBwbGljYXRpb24tbmFtZVwiLCBcImF1dGhvclwiLCBcImRlc2NyaXB0aW9uXCIsIFwiZ2VuZXJhdG9yXCIsIFwia2V5d29yZHNcIl0sXG4gICAgICAgICAgICBcImh0dHAtZXF1aXZcIjogW1wiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImRlZmF1bHQtc3R5bGVcIiwgXCJyZWZyZXNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGVyOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsLCBtaW46IG51bGwsIGxvdzogbnVsbCwgaGlnaDogbnVsbCwgbWF4OiBudWxsLCBvcHRpbXVtOiBudWxsIH0gfSxcbiAgICBuYXY6IFMsXG4gICAgbm9mcmFtZXM6IFMsXG4gICAgbm9zY3JpcHQ6IFMsXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLCB0eXBlOiBudWxsLCBuYW1lOiBudWxsLCB1c2VtYXA6IG51bGwsIGZvcm06IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlbXVzdG1hdGNoOiBbXCJ0eXBlbXVzdG1hdGNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9sOiB7IGF0dHJzOiB7IHJldmVyc2VkOiBbXCJyZXZlcnNlZFwiXSwgc3RhcnQ6IG51bGwsIHR5cGU6IFtcIjFcIiwgXCJhXCIsIFwiQVwiLCBcImlcIiwgXCJJXCJdIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXCJsaVwiLCBcInNjcmlwdFwiLCBcInRlbXBsYXRlXCIsIFwidWxcIiwgXCJvbFwiXSB9LFxuICAgIG9wdGdyb3VwOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbGFiZWw6IG51bGwgfSB9LFxuICAgIG9wdGlvbjogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGxhYmVsOiBudWxsLCBzZWxlY3RlZDogW1wic2VsZWN0ZWRcIl0sIHZhbHVlOiBudWxsIH0gfSxcbiAgICBvdXRwdXQ6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgICBwOiBTLFxuICAgIHBhcmFtOiB7IGF0dHJzOiB7IG5hbWU6IG51bGwsIHZhbHVlOiBudWxsIH0gfSxcbiAgICBwcmU6IFMsXG4gICAgcHJvZ3Jlc3M6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwsIG1heDogbnVsbCB9IH0sXG4gICAgcTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBycDogUyxcbiAgICBydDogUyxcbiAgICBydWJ5OiBTLFxuICAgIHM6IFMsXG4gICAgc2FtcDogUyxcbiAgICBzY3JpcHQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHR5cGU6IFtcInRleHQvamF2YXNjcmlwdFwiXSxcbiAgICAgICAgICAgIHNyYzogbnVsbCxcbiAgICAgICAgICAgIGFzeW5jOiBbXCJhc3luY1wiXSxcbiAgICAgICAgICAgIGRlZmVyOiBbXCJkZWZlclwiXSxcbiAgICAgICAgICAgIGNoYXJzZXQ6IENoYXJzZXRzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlY3Rpb246IFMsXG4gICAgc2VsZWN0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBmb3JtOiBudWxsLCBuYW1lOiBudWxsLCBzaXplOiBudWxsLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2xvdDogeyBhdHRyczogeyBuYW1lOiBudWxsIH0gfSxcbiAgICBzbWFsbDogUyxcbiAgICBzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsLCB0eXBlOiBudWxsLCBtZWRpYTogbnVsbCB9IH0sXG4gICAgc3BhbjogUyxcbiAgICBzdHJpa2U6IFMsXG4gICAgc3Ryb25nOiBTLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2Nzc1wiXSxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2NvcGVkOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN1YjogUyxcbiAgICBzdW1tYXJ5OiBTLFxuICAgIHN1cDogUyxcbiAgICB0YWJsZTogUyxcbiAgICB0Ym9keTogUyxcbiAgICB0ZDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsIH0gfSxcbiAgICB0ZW1wbGF0ZTogUyxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgbWF4bGVuZ3RoOiBudWxsLCBuYW1lOiBudWxsLCBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgICAgIHJvd3M6IG51bGwsIGNvbHM6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgICAgICAgIHdyYXA6IFtcInNvZnRcIiwgXCJoYXJkXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRmb290OiBTLFxuICAgIHRoOiB7IGF0dHJzOiB7IGNvbHNwYW46IG51bGwsIHJvd3NwYW46IG51bGwsIGhlYWRlcnM6IG51bGwsIHNjb3BlOiBbXCJyb3dcIiwgXCJjb2xcIiwgXCJyb3dncm91cFwiLCBcImNvbGdyb3VwXCJdIH0gfSxcbiAgICB0aGVhZDogUyxcbiAgICB0aW1lOiB7IGF0dHJzOiB7IGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICB0aXRsZTogUyxcbiAgICB0cjogUyxcbiAgICB0cmFjazoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBsYWJlbDogbnVsbCwgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIGtpbmQ6IFtcInN1YnRpdGxlc1wiLCBcImNhcHRpb25zXCIsIFwiZGVzY3JpcHRpb25zXCIsIFwiY2hhcHRlcnNcIiwgXCJtZXRhZGF0YVwiXSxcbiAgICAgICAgICAgIHNyY2xhbmc6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHQ6IFMsXG4gICAgdTogUyxcbiAgICB1bDogeyBjaGlsZHJlbjogW1wibGlcIiwgXCJzY3JpcHRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInVsXCIsIFwib2xcIl0gfSxcbiAgICB2YXI6IFMsXG4gICAgdmlkZW86IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHNyYzogbnVsbCwgcG9zdGVyOiBudWxsLCB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFtcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiXSxcbiAgICAgICAgICAgIHByZWxvYWQ6IFtcImF1dG9cIiwgXCJtZXRhZGF0YVwiLCBcIm5vbmVcIl0sXG4gICAgICAgICAgICBhdXRvcGxheTogW1wiYXV0b3BsYXlcIl0sXG4gICAgICAgICAgICBtZWRpYWdyb3VwOiBbXCJtb3ZpZVwiXSxcbiAgICAgICAgICAgIG11dGVkOiBbXCJtdXRlZFwiXSxcbiAgICAgICAgICAgIGNvbnRyb2xzOiBbXCJjb250cm9sc1wiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB3YnI6IFNcbn07XG5jb25zdCBHbG9iYWxBdHRycyA9IHtcbiAgICBhY2Nlc3NrZXk6IG51bGwsXG4gICAgY2xhc3M6IG51bGwsXG4gICAgY29udGVudGVkaXRhYmxlOiBCb29sLFxuICAgIGNvbnRleHRtZW51OiBudWxsLFxuICAgIGRpcjogW1wibHRyXCIsIFwicnRsXCIsIFwiYXV0b1wiXSxcbiAgICBkcmFnZ2FibGU6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcImF1dG9cIl0sXG4gICAgZHJvcHpvbmU6IFtcImNvcHlcIiwgXCJtb3ZlXCIsIFwibGlua1wiLCBcInN0cmluZzpcIiwgXCJmaWxlOlwiXSxcbiAgICBoaWRkZW46IFtcImhpZGRlblwiXSxcbiAgICBpZDogbnVsbCxcbiAgICBpbmVydDogW1wiaW5lcnRcIl0sXG4gICAgaXRlbWlkOiBudWxsLFxuICAgIGl0ZW1wcm9wOiBudWxsLFxuICAgIGl0ZW1yZWY6IG51bGwsXG4gICAgaXRlbXNjb3BlOiBbXCJpdGVtc2NvcGVcIl0sXG4gICAgaXRlbXR5cGU6IG51bGwsXG4gICAgbGFuZzogW1wiYXJcIiwgXCJiblwiLCBcImRlXCIsIFwiZW4tR0JcIiwgXCJlbi1VU1wiLCBcImVzXCIsIFwiZnJcIiwgXCJoaVwiLCBcImlkXCIsIFwiamFcIiwgXCJwYVwiLCBcInB0XCIsIFwicnVcIiwgXCJ0clwiLCBcInpoXCJdLFxuICAgIHNwZWxsY2hlY2s6IEJvb2wsXG4gICAgYXV0b2NvcnJlY3Q6IEJvb2wsXG4gICAgYXV0b2NhcGl0YWxpemU6IEJvb2wsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgdGFiaW5kZXg6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHJhbnNsYXRlOiBbXCJ5ZXNcIiwgXCJub1wiXSxcbiAgICBvbmNsaWNrOiBudWxsLFxuICAgIHJlbDogW1wic3R5bGVzaGVldFwiLCBcImFsdGVybmF0ZVwiLCBcImF1dGhvclwiLCBcImJvb2ttYXJrXCIsIFwiaGVscFwiLCBcImxpY2Vuc2VcIiwgXCJuZXh0XCIsIFwibm9mb2xsb3dcIiwgXCJub3JlZmVycmVyXCIsIFwicHJlZmV0Y2hcIiwgXCJwcmV2XCIsIFwic2VhcmNoXCIsIFwidGFnXCJdLFxuICAgIHJvbGU6IC8qQF9fUFVSRV9fKi9cImFsZXJ0IGFwcGxpY2F0aW9uIGFydGljbGUgYmFubmVyIGJ1dHRvbiBjZWxsIGNoZWNrYm94IGNvbXBsZW1lbnRhcnkgY29udGVudGluZm8gZGlhbG9nIGRvY3VtZW50IGZlZWQgZmlndXJlIGZvcm0gZ3JpZCBncmlkY2VsbCBoZWFkaW5nIGltZyBsaXN0IGxpc3Rib3ggbGlzdGl0ZW0gbWFpbiBuYXZpZ2F0aW9uIHJlZ2lvbiByb3cgcm93Z3JvdXAgc2VhcmNoIHN3aXRjaCB0YWIgdGFibGUgdGFicGFuZWwgdGV4dGJveCB0aW1lclwiLnNwbGl0KFwiIFwiKSxcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBudWxsLFxuICAgIFwiYXJpYS1hdG9taWNcIjogQm9vbCxcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFtcImlubGluZVwiLCBcImxpc3RcIiwgXCJib3RoXCIsIFwibm9uZVwiXSxcbiAgICBcImFyaWEtYnVzeVwiOiBCb29sLFxuICAgIFwiYXJpYS1jaGVja2VkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm1peGVkXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBudWxsLFxuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBudWxsLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBCb29sLFxuICAgIFwiYXJpYS1kcm9wZWZmZWN0XCI6IG51bGwsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtZmxvd3RvXCI6IG51bGwsXG4gICAgXCJhcmlhLWdyYWJiZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBCb29sLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogQm9vbCxcbiAgICBcImFyaWEtaW52YWxpZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJncmFtbWFyXCIsIFwic3BlbGxpbmdcIl0sXG4gICAgXCJhcmlhLWxhYmVsXCI6IG51bGwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbnVsbCxcbiAgICBcImFyaWEtbGV2ZWxcIjogbnVsbCxcbiAgICBcImFyaWEtbGl2ZVwiOiBbXCJvZmZcIiwgXCJwb2xpdGVcIiwgXCJhc3NlcnRpdmVcIl0sXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiBCb29sLFxuICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogQm9vbCxcbiAgICBcImFyaWEtb3duc1wiOiBudWxsLFxuICAgIFwiYXJpYS1wb3NpbnNldFwiOiBudWxsLFxuICAgIFwiYXJpYS1wcmVzc2VkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm1peGVkXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1yZWFkb25seVwiOiBCb29sLFxuICAgIFwiYXJpYS1yZWxldmFudFwiOiBudWxsLFxuICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBCb29sLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLXNldHNpemVcIjogbnVsbCxcbiAgICBcImFyaWEtc29ydFwiOiBbXCJhc2NlbmRpbmdcIiwgXCJkZXNjZW5kaW5nXCIsIFwibm9uZVwiLCBcIm90aGVyXCJdLFxuICAgIFwiYXJpYS12YWx1ZW1heFwiOiBudWxsLFxuICAgIFwiYXJpYS12YWx1ZW1pblwiOiBudWxsLFxuICAgIFwiYXJpYS12YWx1ZW5vd1wiOiBudWxsLFxuICAgIFwiYXJpYS12YWx1ZXRleHRcIjogbnVsbFxufTtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmFUYWdzLCBleHRyYUF0dHJzKSB7XG4gICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgVGFncyksIGV4dHJhVGFncyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsQXR0cnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdsb2JhbEF0dHJzKSwgZXh0cmFBdHRycyk7XG4gICAgICAgIHRoaXMuYWxsVGFncyA9IE9iamVjdC5rZXlzKHRoaXMudGFncyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsQXR0ck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5nbG9iYWxBdHRycyk7XG4gICAgfVxufVxuU2NoZW1hLmRlZmF1bHQgPSAvKkBfX1BVUkVfXyovbmV3IFNjaGVtYTtcbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICAgIGlmICghdHJlZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbGV0IHRhZyA9IHRyZWUuZmlyc3RDaGlsZDtcbiAgICBsZXQgbmFtZSA9IHRhZyAmJiB0YWcuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpO1xuICAgIHJldHVybiBuYW1lID8gZG9jLnNsaWNlU3RyaW5nKG5hbWUuZnJvbSwgTWF0aC5taW4obmFtZS50bywgbWF4KSkgOiBcIlwiO1xufVxuZnVuY3Rpb24gZmluZFBhcmVudEVsZW1lbnQodHJlZSwgc2tpcCA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gdHJlZS5wYXJlbnQ7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgaWYgKGN1ci5uYW1lID09IFwiRWxlbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAoc2tpcClcbiAgICAgICAgICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWxsb3dlZENoaWxkcmVuKGRvYywgdHJlZSwgc2NoZW1hKSB7XG4gICAgbGV0IHBhcmVudEluZm8gPSBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShkb2MsIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUsIHRydWUpKV07XG4gICAgcmV0dXJuIChwYXJlbnRJbmZvID09PSBudWxsIHx8IHBhcmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEluZm8uY2hpbGRyZW4pIHx8IHNjaGVtYS5hbGxUYWdzO1xufVxuZnVuY3Rpb24gb3BlblRhZ3MoZG9jLCB0cmVlKSB7XG4gICAgbGV0IG9wZW4gPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0cmVlOyBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudChwYXJlbnQpOykge1xuICAgICAgICBsZXQgdGFnTmFtZSA9IGVsZW1lbnROYW1lKGRvYywgcGFyZW50KTtcbiAgICAgICAgaWYgKHRhZ05hbWUgJiYgcGFyZW50Lmxhc3RDaGlsZC5uYW1lID09IFwiQ2xvc2VUYWdcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFnTmFtZSAmJiBvcGVuLmluZGV4T2YodGFnTmFtZSkgPCAwICYmICh0cmVlLm5hbWUgPT0gXCJFbmRUYWdcIiB8fCB0cmVlLmZyb20gPj0gcGFyZW50LmZpcnN0Q2hpbGQudG8pKVxuICAgICAgICAgICAgb3Blbi5wdXNoKHRhZ05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gb3Blbjtcbn1cbmNvbnN0IGlkZW50aWZpZXIgPSAvXls6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokLztcbmZ1bmN0aW9uIGNvbXBsZXRlVGFnKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVuZCA9IC9cXHMqPi8udGVzdChzdGF0ZS5zbGljZURvYyh0bywgdG8gKyA1KSkgPyBcIlwiIDogXCI+XCI7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IGFsbG93ZWRDaGlsZHJlbihzdGF0ZS5kb2MsIHRyZWUsIHNjaGVtYSkubWFwKHRhZ05hbWUgPT4gKHsgbGFiZWw6IHRhZ05hbWUsIHR5cGU6IFwidHlwZVwiIH0pKS5jb25jYXQob3BlblRhZ3Moc3RhdGUuZG9jLCB0cmVlKS5tYXAoKHRhZywgaSkgPT4gKHsgbGFiZWw6IFwiL1wiICsgdGFnLCBhcHBseTogXCIvXCIgKyB0YWcgKyBlbmQsXG4gICAgICAgICAgICB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gaSB9KSkpLFxuICAgICAgICB2YWxpZEZvcjogL15cXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUNsb3NlVGFnKHN0YXRlLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIGxldCBlbmQgPSAvXFxzKj4vLnRlc3Qoc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgNSkpID8gXCJcIiA6IFwiPlwiO1xuICAgIHJldHVybiB7IGZyb20sIHRvLFxuICAgICAgICBvcHRpb25zOiBvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpLm1hcCgodGFnLCBpKSA9PiAoeyBsYWJlbDogdGFnLCBhcHBseTogdGFnICsgZW5kLCB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gaSB9KSksXG4gICAgICAgIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZVN0YXJ0VGFnKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHBvcykge1xuICAgIGxldCBvcHRpb25zID0gW10sIGxldmVsID0gMDtcbiAgICBmb3IgKGxldCB0YWdOYW1lIG9mIGFsbG93ZWRDaGlsZHJlbihzdGF0ZS5kb2MsIHRyZWUsIHNjaGVtYSkpXG4gICAgICAgIG9wdGlvbnMucHVzaCh7IGxhYmVsOiBcIjxcIiArIHRhZ05hbWUsIHR5cGU6IFwidHlwZVwiIH0pO1xuICAgIGZvciAobGV0IG9wZW4gb2Ygb3BlblRhZ3Moc3RhdGUuZG9jLCB0cmVlKSlcbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IFwiPC9cIiArIG9wZW4gKyBcIj5cIiwgdHlwZTogXCJ0eXBlXCIsIGJvb3N0OiA5OSAtIGxldmVsKysgfSk7XG4gICAgcmV0dXJuIHsgZnJvbTogcG9zLCB0bzogcG9zLCBvcHRpb25zLCB2YWxpZEZvcjogL148XFwvP1s6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokLyB9O1xufVxuZnVuY3Rpb24gY29tcGxldGVBdHRyTmFtZShzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIGxldCBlbHQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKSwgaW5mbyA9IGVsdCA/IHNjaGVtYS50YWdzW2VsZW1lbnROYW1lKHN0YXRlLmRvYywgZWx0KV0gOiBudWxsO1xuICAgIGxldCBuYW1lcyA9IChpbmZvICYmIGluZm8uYXR0cnMgPyBPYmplY3Qua2V5cyhpbmZvLmF0dHJzKS5jb25jYXQoc2NoZW1hLmdsb2JhbEF0dHJOYW1lcykgOiBzY2hlbWEuZ2xvYmFsQXR0ck5hbWVzKTtcbiAgICByZXR1cm4geyBmcm9tLCB0byxcbiAgICAgICAgb3B0aW9uczogbmFtZXMubWFwKGF0dHJOYW1lID0+ICh7IGxhYmVsOiBhdHRyTmFtZSwgdHlwZTogXCJwcm9wZXJ0eVwiIH0pKSxcbiAgICAgICAgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQXR0clZhbHVlKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBuYW1lTm9kZSA9IChfYSA9IHRyZWUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q2hpbGQoXCJBdHRyaWJ1dGVOYW1lXCIpO1xuICAgIGxldCBvcHRpb25zID0gW10sIHRva2VuID0gdW5kZWZpbmVkO1xuICAgIGlmIChuYW1lTm9kZSkge1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBzdGF0ZS5zbGljZURvYyhuYW1lTm9kZS5mcm9tLCBuYW1lTm9kZS50byk7XG4gICAgICAgIGxldCBhdHRycyA9IHNjaGVtYS5nbG9iYWxBdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKSwgaW5mbyA9IGVsdCA/IHNjaGVtYS50YWdzW2VsZW1lbnROYW1lKHN0YXRlLmRvYywgZWx0KV0gOiBudWxsO1xuICAgICAgICAgICAgYXR0cnMgPSAoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmF0dHJzKSAmJiBpbmZvLmF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pLnRvTG93ZXJDYXNlKCksIHF1b3RlU3RhcnQgPSAnXCInLCBxdW90ZUVuZCA9ICdcIic7XG4gICAgICAgICAgICBpZiAoL15bJ1wiXS8udGVzdChiYXNlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gYmFzZVswXSA9PSAnXCInID8gL15bXlwiXSokLyA6IC9eW14nXSokLztcbiAgICAgICAgICAgICAgICBxdW90ZVN0YXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBxdW90ZUVuZCA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpID09IGJhc2VbMF0gPyBcIlwiIDogYmFzZVswXTtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBmcm9tKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IC9eW15cXHM8Pj0nXCJdKiQvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgYXR0cnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IHZhbHVlLCBhcHBseTogcXVvdGVTdGFydCArIHZhbHVlICsgcXVvdGVFbmQsIHR5cGU6IFwiY29uc3RhbnRcIiB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0bywgb3B0aW9ucywgdmFsaWRGb3I6IHRva2VuIH07XG59XG5mdW5jdGlvbiBodG1sQ29tcGxldGlvbkZvcihzY2hlbWEsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBzdGF0ZSwgcG9zIH0gPSBjb250ZXh0LCBhcm91bmQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zKSwgdHJlZSA9IGFyb3VuZC5yZXNvbHZlKHBvcywgLTEpO1xuICAgIGZvciAobGV0IHNjYW4gPSBwb3MsIGJlZm9yZTsgYXJvdW5kID09IHRyZWUgJiYgKGJlZm9yZSA9IHRyZWUuY2hpbGRCZWZvcmUoc2NhbikpOykge1xuICAgICAgICBsZXQgbGFzdCA9IGJlZm9yZS5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCAhbGFzdC50eXBlLmlzRXJyb3IgfHwgbGFzdC5mcm9tIDwgbGFzdC50bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBhcm91bmQgPSB0cmVlID0gYmVmb3JlO1xuICAgICAgICBzY2FuID0gbGFzdC5mcm9tO1xuICAgIH1cbiAgICBpZiAodHJlZS5uYW1lID09IFwiVGFnTmFtZVwiKSB7XG4gICAgICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiAvQ2xvc2VUYWckLy50ZXN0KHRyZWUucGFyZW50Lm5hbWUpID8gY29tcGxldGVDbG9zZVRhZyhzdGF0ZSwgdHJlZSwgdHJlZS5mcm9tLCBwb3MpXG4gICAgICAgICAgICA6IGNvbXBsZXRlVGFnKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUuZnJvbSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiU3RhcnRUYWdcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiSW5jb21wbGV0ZUNsb3NlVGFnXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dC5leHBsaWNpdCAmJiAodHJlZS5uYW1lID09IFwiT3BlblRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIlNlbGZDbG9zaW5nVGFnXCIpIHx8IHRyZWUubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVBdHRyTmFtZShzdGF0ZSwgc2NoZW1hLCB0cmVlLCB0cmVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVOYW1lXCIgPyB0cmVlLmZyb20gOiBwb3MsIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyZWUubmFtZSA9PSBcIklzXCIgfHwgdHJlZS5uYW1lID09IFwiQXR0cmlidXRlVmFsdWVcIiB8fCB0cmVlLm5hbWUgPT0gXCJVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0clZhbHVlKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUubmFtZSA9PSBcIklzXCIgPyBwb3MgOiB0cmVlLmZyb20sIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQuZXhwbGljaXQgJiYgKGFyb3VuZC5uYW1lID09IFwiRWxlbWVudFwiIHx8IGFyb3VuZC5uYW1lID09IFwiVGV4dFwiIHx8IGFyb3VuZC5uYW1lID09IFwiRG9jdW1lbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlU3RhcnRUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuSFRNTCB0YWcgY29tcGxldGlvbi4gT3BlbnMgYW5kIGNsb3NlcyB0YWdzIGFuZCBhdHRyaWJ1dGVzIGluIGFcbmNvbnRleHQtYXdhcmUgd2F5LlxuKi9cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gaHRtbENvbXBsZXRpb25Gb3IoU2NoZW1hLmRlZmF1bHQsIGNvbnRleHQpO1xufVxuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIHNvdXJjZSBmb3IgSFRNTCBleHRlbmRlZCB3aXRoIGFkZGl0aW9uYWwgdGFnc1xub3IgYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBodG1sQ29tcGxldGlvblNvdXJjZVdpdGgoY29uZmlnKSB7XG4gICAgbGV0IHsgZXh0cmFUYWdzLCBleHRyYUdsb2JhbEF0dHJpYnV0ZXM6IGV4dHJhQXR0cnMgfSA9IGNvbmZpZztcbiAgICBsZXQgc2NoZW1hID0gZXh0cmFBdHRycyB8fCBleHRyYVRhZ3MgPyBuZXcgU2NoZW1hKGV4dHJhVGFncywgZXh0cmFBdHRycykgOiBTY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IGh0bWxDb21wbGV0aW9uRm9yKHNjaGVtYSwgY29udGV4dCk7XG59XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIEhUTUxcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9odG1sKSwgZXh0ZW5kZWQgd2l0aCB0aGVcbkphdmFTY3JpcHQgYW5kIENTUyBwYXJzZXJzIHRvIHBhcnNlIHRoZSBjb250ZW50IG9mIGA8c2NyaXB0PmAgYW5kXG5gPHN0eWxlPmAgdGFncy5cbiovXG5jb25zdCBodG1sTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IC9eKFxccyopKDxcXC8pPy8uZXhlYyhjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm5vZGUudG8gPD0gY29udGV4dC5wb3MgKyBhZnRlclswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChhZnRlclsyXSA/IDAgOiBjb250ZXh0LnVuaXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJPcGVuVGFnIENsb3NlVGFnIFNlbGZDbG9zaW5nVGFnXCIoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb2x1bW4oY29udGV4dC5ub2RlLmZyb20pICsgY29udGV4dC51bml0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRG9jdW1lbnQoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5wb3MgKyAvXFxzKi8uZXhlYyhjb250ZXh0LnRleHRBZnRlcilbMF0ubGVuZ3RoIDwgY29udGV4dC5ub2RlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEVsdCA9IG51bGwsIGNsb3NlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBjb250ZXh0Lm5vZGU7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0IHx8IGxhc3QubmFtZSAhPSBcIkVsZW1lbnRcIiB8fCBsYXN0LnRvICE9IGN1ci50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEVsdCA9IGN1ciA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEVsdCAmJiAhKChjbG9zZSA9IGVuZEVsdC5sYXN0Q2hpbGQpICYmIChjbG9zZS5uYW1lID09IFwiQ2xvc2VUYWdcIiB8fCBjbG9zZS5uYW1lID09IFwiU2VsZkNsb3NpbmdUYWdcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChlbmRFbHQuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIEVsZW1lbnQobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIGxhc3QgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBmaXJzdC5uYW1lICE9IFwiT3BlblRhZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IGZpcnN0LnRvLCB0bzogbGFzdC5uYW1lID09IFwiQ2xvc2VUYWdcIiA/IGxhc3QuZnJvbSA6IG5vZGUudG8gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLFxuICAgICAgICB3cmFwOiAvKkBfX1BVUkVfXyovY29uZmlndXJlTmVzdGluZyhbXG4gICAgICAgICAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBhdHRycyhhdHRycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWF0dHJzLnR5cGUgfHwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT8oPzpqYXZhfGVjbWEpc2NyaXB0JHxebW9kdWxlJHxeJC9pLnRlc3QoYXR0cnMudHlwZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJzZXI6IGphdmFzY3JpcHRMYW5ndWFnZS5wYXJzZXIgfSxcbiAgICAgICAgICAgIHsgdGFnOiBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgYXR0cnMoYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghYXR0cnMubGFuZyB8fCBhdHRycy5sYW5nID09IFwiY3NzXCIpICYmICghYXR0cnMudHlwZSB8fCAvXih0ZXh0XFwvKT8oeC0pPyhzdHlsZXNoZWV0fGNzcykkL2kudGVzdChhdHRycy50eXBlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJzZXI6IGNzc0xhbmd1YWdlLnBhcnNlciB9XG4gICAgICAgIF0pXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCI8IS0tXCIsIGNsb3NlOiBcIi0tPlwiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqPFxcL1xcdytcXFckLyxcbiAgICAgICAgd29yZENoYXJzOiBcIi0uX1wiXG4gICAgfVxufSk7XG4vKipcbkxhbmd1YWdlIHN1cHBvcnQgZm9yIEhUTUwsIGluY2x1ZGluZ1xuW2BodG1sQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1odG1sLmh0bWxDb21wbGV0aW9uKSBhbmQgSmF2YVNjcmlwdCBhbmRcbkNTUyBzdXBwb3J0IGV4dGVuc2lvbnMuXG4qL1xuZnVuY3Rpb24gaHRtbChjb25maWcgPSB7fSkge1xuICAgIGxldCBsYW5nID0gaHRtbExhbmd1YWdlO1xuICAgIGlmIChjb25maWcubWF0Y2hDbG9zaW5nVGFncyA9PT0gZmFsc2UpXG4gICAgICAgIGxhbmcgPSBsYW5nLmNvbmZpZ3VyZSh7IGRpYWxlY3Q6IFwibm9NYXRjaFwiIH0pO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgaHRtbExhbmd1YWdlLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGh0bWxDb21wbGV0aW9uU291cmNlV2l0aChjb25maWcpIH0pLFxuICAgICAgICBjb25maWcuYXV0b0Nsb3NlVGFncyAhPT0gZmFsc2UgPyBhdXRvQ2xvc2VUYWdzIDogW10sXG4gICAgICAgIGphdmFzY3JpcHQoKS5zdXBwb3J0LFxuICAgICAgICBjc3MoKS5zdXBwb3J0XG4gICAgXSk7XG59XG4vKipcbkV4dGVuc2lvbiB0aGF0IHdpbGwgYXV0b21hdGljYWxseSBpbnNlcnQgY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQpID0+IHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcgfHwgdmlldy5zdGF0ZS5yZWFkT25seSB8fCBmcm9tICE9IHRvIHx8ICh0ZXh0ICE9IFwiPlwiICYmIHRleHQgIT0gXCIvXCIpIHx8XG4gICAgICAgICFodG1sTGFuZ3VhZ2UuaXNBY3RpdmVBdCh2aWV3LnN0YXRlLCBmcm9tLCAtMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gcmFuZ2UsIGFyb3VuZCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihoZWFkLCAtMSksIG5hbWU7XG4gICAgICAgIGlmIChhcm91bmQubmFtZSA9PSBcIlRhZ05hbWVcIiB8fCBhcm91bmQubmFtZSA9PSBcIlN0YXJ0VGFnXCIpXG4gICAgICAgICAgICBhcm91bmQgPSBhcm91bmQucGFyZW50O1xuICAgICAgICBpZiAodGV4dCA9PSBcIj5cIiAmJiBhcm91bmQubmFtZSA9PSBcIk9wZW5UYWdcIikge1xuICAgICAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSBhcm91bmQucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgIT0gXCJDbG9zZVRhZ1wiICYmIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBhcm91bmQucGFyZW50LCBoZWFkKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCArIDEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydDogYD48LyR7bmFtZX0+YCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIi9cIiAmJiBhcm91bmQubmFtZSA9PSBcIk9wZW5UYWdcIikge1xuICAgICAgICAgICAgbGV0IGVtcHR5ID0gYXJvdW5kLnBhcmVudCwgYmFzZSA9IGVtcHR5ID09PSBudWxsIHx8IGVtcHR5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbXB0eS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoZW1wdHkuZnJvbSA9PSBoZWFkIC0gMSAmJiAoKF9jID0gYmFzZS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiYgKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZS5kb2MsIGJhc2UsIGhlYWQpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBgLyR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCksIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IHsgYXV0b0Nsb3NlVGFncywgaHRtbCwgaHRtbENvbXBsZXRpb25Tb3VyY2UsIGh0bWxDb21wbGV0aW9uU291cmNlV2l0aCwgaHRtbExhbmd1YWdlIH07XG4iLCJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgcGFyc2VNaXhlZCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNjcmlwdFRleHQgPSA1MyxcbiAgU3RhcnRDbG9zZVNjcmlwdFRhZyA9IDEsXG4gIHN0eWxlVGV4dCA9IDU0LFxuICBTdGFydENsb3NlU3R5bGVUYWcgPSAyLFxuICB0ZXh0YXJlYVRleHQgPSA1NSxcbiAgU3RhcnRDbG9zZVRleHRhcmVhVGFnID0gMyxcbiAgU3RhcnRUYWcgPSA0LFxuICBTdGFydFNjcmlwdFRhZyA9IDUsXG4gIFN0YXJ0U3R5bGVUYWcgPSA2LFxuICBTdGFydFRleHRhcmVhVGFnID0gNyxcbiAgU3RhcnRTZWxmQ2xvc2luZ1RhZyA9IDgsXG4gIFN0YXJ0Q2xvc2VUYWcgPSA5LFxuICBOb01hdGNoU3RhcnRDbG9zZVRhZyA9IDEwLFxuICBNaXNtYXRjaGVkU3RhcnRDbG9zZVRhZyA9IDExLFxuICBtaXNzaW5nQ2xvc2VUYWcgPSA1NixcbiAgSW5jb21wbGV0ZUNsb3NlVGFnID0gMTIsXG4gIGNvbW1lbnRDb250ZW50JDEgPSA1NyxcbiAgRWxlbWVudCA9IDE4LFxuICBTY3JpcHRUZXh0ID0gMjcsXG4gIFN0eWxlVGV4dCA9IDMwLFxuICBUZXh0YXJlYVRleHQgPSAzMyxcbiAgT3BlblRhZyA9IDM1LFxuICBEaWFsZWN0X25vTWF0Y2ggPSAwO1xuXG4vKiBIYW5kLXdyaXR0ZW4gdG9rZW5pemVycyBmb3IgSFRNTC4gKi9cblxuY29uc3Qgc2VsZkNsb3NlcnMgPSB7XG4gIGFyZWE6IHRydWUsIGJhc2U6IHRydWUsIGJyOiB0cnVlLCBjb2w6IHRydWUsIGNvbW1hbmQ6IHRydWUsXG4gIGVtYmVkOiB0cnVlLCBmcmFtZTogdHJ1ZSwgaHI6IHRydWUsIGltZzogdHJ1ZSwgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSwgbGluazogdHJ1ZSwgbWV0YTogdHJ1ZSwgcGFyYW06IHRydWUsIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsIHdicjogdHJ1ZSwgbWVudWl0ZW06IHRydWVcbn07XG5cbmNvbnN0IGltcGxpY2l0bHlDbG9zZWQgPSB7XG4gIGRkOiB0cnVlLCBsaTogdHJ1ZSwgb3B0Z3JvdXA6IHRydWUsIG9wdGlvbjogdHJ1ZSwgcDogdHJ1ZSxcbiAgcnA6IHRydWUsIHJ0OiB0cnVlLCB0Ym9keTogdHJ1ZSwgdGQ6IHRydWUsIHRmb290OiB0cnVlLFxuICB0aDogdHJ1ZSwgdHI6IHRydWVcbn07XG5cbmNvbnN0IGNsb3NlT25PcGVuID0ge1xuICBkZDoge2RkOiB0cnVlLCBkdDogdHJ1ZX0sXG4gIGR0OiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgbGk6IHtsaTogdHJ1ZX0sXG4gIG9wdGlvbjoge29wdGlvbjogdHJ1ZSwgb3B0Z3JvdXA6IHRydWV9LFxuICBvcHRncm91cDoge29wdGdyb3VwOiB0cnVlfSxcbiAgcDoge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBkaXI6IHRydWUsXG4gICAgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSxcbiAgICBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsIGg2OiB0cnVlLFxuICAgIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbWVudTogdHJ1ZSwgbmF2OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB1bDogdHJ1ZVxuICB9LFxuICBycDoge3JwOiB0cnVlLCBydDogdHJ1ZX0sXG4gIHJ0OiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgdGJvZHk6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0ZDoge3RkOiB0cnVlLCB0aDogdHJ1ZX0sXG4gIHRmb290OiB7dGJvZHk6IHRydWV9LFxuICB0aDoge3RkOiB0cnVlLCB0aDogdHJ1ZX0sXG4gIHRoZWFkOiB7dGJvZHk6IHRydWUsIHRmb290OiB0cnVlfSxcbiAgdHI6IHt0cjogdHJ1ZX1cbn07XG5cbmZ1bmN0aW9uIG5hbWVDaGFyKGNoKSB7XG4gIHJldHVybiBjaCA9PSA0NSB8fCBjaCA9PSA0NiB8fCBjaCA9PSA1OCB8fCBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA9PSA5NSB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPj0gMTYxXG59XG5cbmZ1bmN0aW9uIGlzU3BhY2UoY2gpIHtcbiAgcmV0dXJuIGNoID09IDkgfHwgY2ggPT0gMTAgfHwgY2ggPT0gMTMgfHwgY2ggPT0gMzJcbn1cblxubGV0IGNhY2hlZE5hbWUgPSBudWxsLCBjYWNoZWRJbnB1dCA9IG51bGwsIGNhY2hlZFBvcyA9IDA7XG5mdW5jdGlvbiB0YWdOYW1lQWZ0ZXIoaW5wdXQsIG9mZnNldCkge1xuICBsZXQgcG9zID0gaW5wdXQucG9zICsgb2Zmc2V0O1xuICBpZiAoY2FjaGVkUG9zID09IHBvcyAmJiBjYWNoZWRJbnB1dCA9PSBpbnB1dCkgcmV0dXJuIGNhY2hlZE5hbWVcbiAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZnNldCk7XG4gIHdoaWxlIChpc1NwYWNlKG5leHQpKSBuZXh0ID0gaW5wdXQucGVlaygrK29mZnNldCk7XG4gIGxldCBuYW1lID0gXCJcIjtcbiAgZm9yICg7Oykge1xuICAgIGlmICghbmFtZUNoYXIobmV4dCkpIGJyZWFrXG4gICAgbmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQpO1xuICAgIG5leHQgPSBpbnB1dC5wZWVrKCsrb2Zmc2V0KTtcbiAgfVxuICAvLyBVbmRlZmluZWQgdG8gc2lnbmFsIHRoZXJlJ3MgYSA8PyBvciA8ISwgbnVsbCBmb3IganVzdCBtaXNzaW5nXG4gIGNhY2hlZElucHV0ID0gaW5wdXQ7IGNhY2hlZFBvcyA9IHBvcztcbiAgcmV0dXJuIGNhY2hlZE5hbWUgPSBuYW1lID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogbmV4dCA9PSBxdWVzdGlvbiB8fCBuZXh0ID09IGJhbmcgPyB1bmRlZmluZWQgOiBudWxsXG59XG5cbmNvbnN0IGxlc3NUaGFuID0gNjAsIGdyZWF0ZXJUaGFuID0gNjIsIHNsYXNoID0gNDcsIHF1ZXN0aW9uID0gNjMsIGJhbmcgPSAzMywgZGFzaCA9IDQ1O1xuXG5mdW5jdGlvbiBFbGVtZW50Q29udGV4dChuYW1lLCBwYXJlbnQpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuaGFzaCA9IHBhcmVudCA/IHBhcmVudC5oYXNoIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB0aGlzLmhhc2ggKz0gKHRoaXMuaGFzaCA8PCA0KSArIG5hbWUuY2hhckNvZGVBdChpKSArIChuYW1lLmNoYXJDb2RlQXQoaSkgPDwgOCk7XG59XG5cbmNvbnN0IHN0YXJ0VGFnVGVybXMgPSBbU3RhcnRUYWcsIFN0YXJ0U2VsZkNsb3NpbmdUYWcsIFN0YXJ0U2NyaXB0VGFnLCBTdGFydFN0eWxlVGFnLCBTdGFydFRleHRhcmVhVGFnXTtcblxuY29uc3QgZWxlbWVudENvbnRleHQgPSBuZXcgQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogbnVsbCxcbiAgc2hpZnQoY29udGV4dCwgdGVybSwgc3RhY2ssIGlucHV0KSB7XG4gICAgcmV0dXJuIHN0YXJ0VGFnVGVybXMuaW5kZXhPZih0ZXJtKSA+IC0xID8gbmV3IEVsZW1lbnRDb250ZXh0KHRhZ05hbWVBZnRlcihpbnB1dCwgMSkgfHwgXCJcIiwgY29udGV4dCkgOiBjb250ZXh0XG4gIH0sXG4gIHJlZHVjZShjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm0gPT0gRWxlbWVudCAmJiBjb250ZXh0ID8gY29udGV4dC5wYXJlbnQgOiBjb250ZXh0XG4gIH0sXG4gIHJldXNlKGNvbnRleHQsIG5vZGUsIHN0YWNrLCBpbnB1dCkge1xuICAgIGxldCB0eXBlID0gbm9kZS50eXBlLmlkO1xuICAgIHJldHVybiB0eXBlID09IFN0YXJ0VGFnIHx8IHR5cGUgPT0gT3BlblRhZ1xuICAgICAgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgaGFzaChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0ID8gY29udGV4dC5oYXNoIDogMCB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgdGFnU3RhcnQgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsZXNzVGhhbikge1xuICAgIC8vIEVuZCBvZiBmaWxlLCBjbG9zZSBhbnkgb3BlbiB0YWdzXG4gICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIHN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZyk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBsZXQgY2xvc2UgPSBpbnB1dC5uZXh0ID09IHNsYXNoO1xuICBpZiAoY2xvc2UpIGlucHV0LmFkdmFuY2UoKTtcbiAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKCFuYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oY2xvc2UgPyBJbmNvbXBsZXRlQ2xvc2VUYWcgOiBTdGFydFRhZylcblxuICBsZXQgcGFyZW50ID0gc3RhY2suY29udGV4dCA/IHN0YWNrLmNvbnRleHQubmFtZSA6IG51bGw7XG4gIGlmIChjbG9zZSkge1xuICAgIGlmIChuYW1lID09IHBhcmVudCkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0Q2xvc2VUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBpbXBsaWNpdGx5Q2xvc2VkW3BhcmVudF0pIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihtaXNzaW5nQ2xvc2VUYWcsIC0yKVxuICAgIGlmIChzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X25vTWF0Y2gpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oTm9NYXRjaFN0YXJ0Q2xvc2VUYWcpXG4gICAgZm9yIChsZXQgY3ggPSBzdGFjay5jb250ZXh0OyBjeDsgY3ggPSBjeC5wYXJlbnQpIGlmIChjeC5uYW1lID09IG5hbWUpIHJldHVyblxuICAgIGlucHV0LmFjY2VwdFRva2VuKE1pc21hdGNoZWRTdGFydENsb3NlVGFnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobmFtZSA9PSBcInNjcmlwdFwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTY3JpcHRUYWcpXG4gICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTdHlsZVRhZylcbiAgICBpZiAobmFtZSA9PSBcInRleHRhcmVhXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRleHRhcmVhVGFnKVxuICAgIGlmIChzZWxmQ2xvc2Vycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0U2VsZkNsb3NpbmdUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBjbG9zZU9uT3BlbltwYXJlbnRdICYmIGNsb3NlT25PcGVuW3BhcmVudF1bbmFtZV0pIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTEpO1xuICAgIGVsc2UgaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRUYWcpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBjb21tZW50Q29udGVudCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGZvciAobGV0IGRhc2hlcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICBpZiAoaSkgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBkYXNoKSB7XG4gICAgICBkYXNoZXMrKztcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4gJiYgZGFzaGVzID49IDIpIHtcbiAgICAgIGlmIChpID4gMykgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSwgLTIpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFzaGVzID0gMDtcbiAgICB9XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29udGVudFRva2VuaXplcih0YWcsIHRleHRUb2tlbiwgZW5kVG9rZW4pIHtcbiAgbGV0IGxhc3RTdGF0ZSA9IDIgKyB0YWcubGVuZ3RoO1xuICByZXR1cm4gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgICAvLyBzdGF0ZSBtZWFuczpcbiAgICAvLyAtIDAgbm90aGluZyBtYXRjaGVkXG4gICAgLy8gLSAxICc8JyBtYXRjaGVkXG4gICAgLy8gLSAyICc8LycgKyBwb3NzaWJseSB3aGl0ZXNwYWNlIG1hdGNoZWRcbiAgICAvLyAtIDMtKDErdGFnLmxlbmd0aCkgcGFydCBvZiB0aGUgdGFnIG1hdGNoZWRcbiAgICAvLyAtIGxhc3RTdGF0ZSB3aG9sZSB0YWcgKyBwb3NzaWJseSB3aGl0ZXNwYWNlIG1hdGNoZWRcbiAgICBmb3IgKGxldCBzdGF0ZSA9IDAsIG1hdGNoZWRMZW4gPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4pO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09IDAgJiYgaW5wdXQubmV4dCA9PSBsZXNzVGhhbiB8fFxuICAgICAgICAgIHN0YXRlID09IDEgJiYgaW5wdXQubmV4dCA9PSBzbGFzaCB8fFxuICAgICAgICAgIHN0YXRlID49IDIgJiYgc3RhdGUgPCBsYXN0U3RhdGUgJiYgaW5wdXQubmV4dCA9PSB0YWcuY2hhckNvZGVBdChzdGF0ZSAtIDIpKSB7XG4gICAgICAgIHN0YXRlKys7XG4gICAgICAgIG1hdGNoZWRMZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoKHN0YXRlID09IDIgfHwgc3RhdGUgPT0gbGFzdFN0YXRlKSAmJiBpc1NwYWNlKGlucHV0Lm5leHQpKSB7XG4gICAgICAgIG1hdGNoZWRMZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gbGFzdFN0YXRlICYmIGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICAgICAgaWYgKGkgPiBtYXRjaGVkTGVuKVxuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRleHRUb2tlbiwgLW1hdGNoZWRMZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oZW5kVG9rZW4sIC0obWF0Y2hlZExlbiAtIDIpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAoKGlucHV0Lm5leHQgPT0gMTAgLyogJ1xcbicgKi8gfHwgaW5wdXQubmV4dCA9PSAxMyAvKiAnXFxyJyAqLykgJiYgaSkge1xuICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4sIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBtYXRjaGVkTGVuID0gMDtcbiAgICAgIH1cbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IHNjcmlwdFRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJzY3JpcHRcIiwgc2NyaXB0VGV4dCwgU3RhcnRDbG9zZVNjcmlwdFRhZyk7XG5cbmNvbnN0IHN0eWxlVG9rZW5zID0gY29udGVudFRva2VuaXplcihcInN0eWxlXCIsIHN0eWxlVGV4dCwgU3RhcnRDbG9zZVN0eWxlVGFnKTtcblxuY29uc3QgdGV4dGFyZWFUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwidGV4dGFyZWFcIiwgdGV4dGFyZWFUZXh0LCBTdGFydENsb3NlVGV4dGFyZWFUYWcpO1xuXG5jb25zdCBodG1sSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgXCJUZXh0IFJhd1RleHRcIjogdGFncy5jb250ZW50LFxuICBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU2VsZkNsb3NlckVuZFRhZyBFbmRUYWcgU2VsZkNsb3NlRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ05hbWVcIjogW3RhZ3MudGFnTmFtZSwgIHRhZ3MuaW52YWxpZF0sXG4gIEF0dHJpYnV0ZU5hbWU6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCI6IHRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIElzOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgXCJFbnRpdHlSZWZlcmVuY2UgQ2hhcmFjdGVyUmVmZXJlbmNlXCI6IHRhZ3MuY2hhcmFjdGVyLFxuICBDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgUHJvY2Vzc2luZ0luc3Q6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLFxuICBEb2N0eXBlRGVjbDogdGFncy5kb2N1bWVudE1ldGFcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIseE9WT3hPT08hV1EhYk8nI0NvTyFdUSFiTycjQ3lPIWJRIWJPJyNDfE8hZ1EhYk8nI0RQTyFsUSFiTycjRFJPIXFPWE8nI0NuTyF8T1lPJyNDbk8jWE9bTycjQ25PJGVPeE8nI0NuT09PVycjQ24nI0NuTyRsTyFyTycjRFNPJHRRIWJPJyNEVU8keVEhYk8nI0RWT09PVycjRGonI0RqT09PVycjRFgnI0RYUVZPeE9PTyVPUSN0Tyw1OVpPJVdRI3RPLDU5ZU8lYFEjdE8sNTloTyVoUSN0Tyw1OWtPJXBRI3RPLDU5bU9PT1gnI0RdJyNEXU8leE9YTycjQ3dPJlRPWE8sNTlZT09PWScjRF4nI0ReTyZdT1lPJyNDek8maE9ZTyw1OVlPT09bJyNEXycjRF9PJnBPW08nI0N9TyZ7T1tPLDU5WU9PT1cnI0RgJyNEYE8nVE94Tyw1OVlPJ1tRIWJPJyNEUU9PT1csNTlZLDU5WU9PT2AnI0RhJyNEYU8nYU8hck8sNTluT09PVyw1OW4sNTluTydpUSFiTyw1OXBPJ25RIWJPLDU5cU9PT1ctRTdWLUU3Vk8nc1EjdE8nI0NxT09RTycjRFknI0RZTyhPUSN0TzFHLnVPT09YMUcudTFHLnVPKFdRI3RPMUcvUE9PT1kxRy9QMUcvUE8oYFEjdE8xRy9TT09PWzFHL1MxRy9TTyhoUSN0TzFHL1ZPT09XMUcvVjFHL1ZPKHBRI3RPMUcvWE9PT1cxRy9YMUcvWE9PT1gtRTdaLUU3Wk8oeFEhYk8nI0N4T09PVzFHLnQxRy50T09PWS1FN1stRTdbTyh9USFiTycjQ3tPT09bLUU3XS1FN11PKVNRIWJPJyNET09PT1ctRTdeLUU3Xk8pWFEhYk8sNTlsT09PYC1FN18tRTdfT09PVzFHL1kxRy9ZT09PVzFHL1sxRy9bT09PVzFHL10xRy9dTyleUSZqTyw1OV1PT1FPLUU3Vy1FN1dPT09YNyskYTcrJGFPT09ZNyskazcrJGtPT09bNyskbjcrJG5PT09XNyskcTcrJHFPT09XNyskczcrJHNPKWlRIWJPLDU5ZE8pblEhYk8sNTlnTylzUSFiTyw1OWpPT09XMUcvVzFHL1dPKXhPLFVPJyNDdE8qWk83W08nI0N0T09RTzFHLncxRy53T09PVzFHL08xRy9PT09PVzFHL1IxRy9ST09PVzFHL1UxRy9VT09PTycjRFonI0RaTypsTyxVTyw1OWBPT1FPLDU5YCw1OWBPT09PJyNEWycjRFtPKn1PN1tPLDU5YE9PT08tRTdYLUU3WE9PUU8xRy56MUcuek9PT08tRTdZLUU3WVwiLFxuICBzdGF0ZURhdGE6IFwiK2h+TyFdT1N+T1NTT1RQT1VRT1ZST1dUT1ldT1pbT1teT15eT19eT2BeT2FeT3deT3pfTyFjWk9+T2RhT35PZGJPfk9kY09+T2RkT35PZGVPfk8hVmZPUGtQIVlrUH5PIVdpT1FuUCFZblB+TyFYbE9ScVAhWXFQfk9TU09UUE9VUU9WUk9XVE9YcU9ZXU9aW09bXk9eXk9fXk9gXk9hXk93Xk8hY1pPfk8hWXJPflAjZE8hWnNPIWR1T35PZHZPfk9kd09+T2Z5T2p8T35PZnlPaiFPT35PZnlPaiFRT35PZnlPaiFTT35PZnlPaiFVT35PIVZmT1BrWCFZa1h+T1AhV08hWSFYT35PIVdpT1FuWCFZblh+T1EhWk8hWSFYT35PIVhsT1JxWCFZcVh+T1IhXU8hWSFYT35PIVkhWE9+UCNkT2QhX09+TyFac08hZCFhT35PaiFiT35PaiFjT35PZyFkT2ZlWGplWH5PZnlPaiFmT35PZnlPaiFnT35PZnlPaiFoT35PZnlPaiFpT35PZnlPaiFqT35PZCFrT35PZCFsT35PZCFtT35PaiFuT35PaSFxTyFfIW9PIWEhcE9+T2ohck9+T2ohc09+T2ohdE9+T18hdU9gIXVPYSF1TyFfIXdPIWAhdU9+T18heE9gIXhPYSF4TyFhIXdPIWIheE9+T18hdU9gIXVPYSF1TyFfIXtPIWAhdU9+T18heE9gIXhPYSF4TyFhIXtPIWIheE9+T2BfYSFjd3ohY35cIixcbiAgZ290bzogXCIlbyFfUFBQUFBQUFBQUFBQUFBQUFBQIWAhZlAhbFBQIXhQUCF7I08jUiNYI1sjXyNlI2gjayNxI3chYFAhYCFgUCN9JFQkayRxJHckfSVUJVolYVBQUFBQUFBQJWdYXk9YYHBYVU9YYHBlemFiY2Rle30hUCFSIVRSIXEhZFJoVVIhWGhYVk9YYHBSa1ZSIVhrWFdPWGBwUm5XUiFYblhYT1hgcFFyWFIhWHBYWU9YYHBRYE9SeGBRe2FRfWJRIVBjUSFSZFEhVGVaIWV7fSFQIVIhVFEhdiFvUiF6IXZRIXkhcFIhfCF5UWdVUiFWZ1FqVlIhWWpRbVdSIVttUXBYUiFecFF0WlIhYHRTX09gVG9YcFwiLFxuICBub2RlTmFtZXM6IFwi4pqgIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0VGFnIFN0YXJ0VGFnIFN0YXJ0VGFnIFN0YXJ0VGFnIFN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIEluY29tcGxldGVDbG9zZVRhZyBEb2N1bWVudCBUZXh0IEVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2UgSW52YWxpZEVudGl0eSBFbGVtZW50IE9wZW5UYWcgVGFnTmFtZSBBdHRyaWJ1dGUgQXR0cmlidXRlTmFtZSBJcyBBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlIEVuZFRhZyBTY3JpcHRUZXh0IENsb3NlVGFnIE9wZW5UYWcgU3R5bGVUZXh0IENsb3NlVGFnIE9wZW5UYWcgVGV4dGFyZWFUZXh0IENsb3NlVGFnIE9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWcgQ29tbWVudCBQcm9jZXNzaW5nSW5zdCBNaXNtYXRjaGVkQ2xvc2VUYWcgQ2xvc2VUYWcgRG9jdHlwZURlY2xcIixcbiAgbWF4VGVybTogNjYsXG4gIGNvbnRleHQ6IGVsZW1lbnRDb250ZXh0LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJjbG9zZWRCeVwiLCAtMTEsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsXCJFbmRUYWdcIiwtNCwxOSwyOSwzMiwzNSxcIkNsb3NlVGFnXCJdLFxuICAgIFtcImdyb3VwXCIsIC05LDEyLDE1LDE2LDE3LDE4LDM4LDM5LDQwLDQxLFwiRW50aXR5XCIsMTQsXCJFbnRpdHkgVGV4dENvbnRlbnRcIiwtMywyNywzMCwzMyxcIlRleHRDb250ZW50IEVudGl0eVwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAyNixcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWdcIiwtNCwyOCwzMSwzNCwzNixcIk9wZW5UYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtodG1sSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOSxcbiAgdG9rZW5EYXRhOiBcIiEjYiFhUiFXT1gka1hZKXNZWilzWl0ka11eKXNecCRrcHEpc3FyJGtycyp6c3Yka3Z3K2R3eDJ5eH0ka30hTzNmIU8hUCRrIVAhUTdfIVEhWyRrIVshXTh1IV0hXiRrIV4hXz5iIV8hYCEhcCFgIWE4VCFhIWMkayFjIX04dSF9I1IkayNSI1M4dSNTI1QkayNUI284dSNvJGYkayRmJGcmUiRnJVckayVXJW84dSVvJXAkayVwJmE4dSZhJmIkayZiMXA4dTFwNFUkazRVNGQ4dTRkNGUkazRlJElTOHUkSVMkSWAkayRJYCRJYjh1JEliJEtoJGskS2glI3Q4dSUjdCYveCRrJi94JkV0OHUmRXQmRlYkayZGVjsnUzh1OydTOzpqPHQ7Omo/JnIkaz8mcj9BaDh1P0FoP0JZJGs/Qlk/TW44dT9Nbn4kayFaJHZjXlBpVyFgYCFicE9YJGtYWiZSWl0ka11eJlJecCRrcHEmUnFyJGtycyZxc3Yka3Z3KVJ3eCdyeCFQJGshUCFRJlIhUSFeJGshXiFfKGshXyFhJlIhYSRmJGskZiRnJlIkZ34kayFSJltWXlAhYGAhYnBPciZScnMmcXN2JlJ3eCdyeCFeJlIhXiFfKGshX34mUnEmeFReUCFicE92JnF3eCdYeCFeJnEhXiFfJ2chX34mcVAnXlJeUE92J1h3IV4nWCFffidYcCdsUSFicE92J2d4fidnYSd5VV5QIWBgT3IncnJzJ1hzdidydyFeJ3IhXiFfKF0hX34ncmAoYlIhYGBPcihdc3YoXXd+KF0hUShyVCFgYCFicE9yKGtycydnc3Yoa3d4KF14fihrVylXWGlXT1gpUlpdKVJecClScXIpUnN3KVJ4IVApUiFRIV4pUiFhJGYpUiRnfilSIWEqT15eUCFgYCFicCFdXk9YJlJYWSlzWVopc1pdJlJdXilzXnAmUnBxKXNxciZScnMmcXN2JlJ3eCdyeCFeJlIhXiFfKGshX34mUiFaK1RUIV9oXlAhYnBPdiZxd3gnWHghXiZxIV4hXydnIV9+JnEhWitrYmlXYSFST1gsc1haLlFaXSxzXV4uUV5wLHNxcixzcnMuUXN0L110dyxzd3guUXghUCxzIVAhUS5RIVEhXSxzIV0hXilSIV4hYS5RIWEkZixzJGYkZy5RJGd+LHMhWix4YmlXT1gsc1haLlFaXSxzXV4uUV5wLHNxcixzcnMuUXN0KVJ0dyxzd3guUXghUCxzIVAhUS5RIVEhXSxzIV0hXi5pIV4hYS5RIWEkZixzJGYkZy5RJGd+LHMhUi5UVE9wLlFxcy5RdCFdLlEhXSFeLmQhXn4uUSFSLmlPXyFSIVoucFhpV18hUk9YKVJaXSlSXnApUnFyKVJzdylSeCFQKVIhUSFeKVIhYSRmKVIkZ34pUiFaL2JhaVdPWDBnWFoxcVpdMGddXjFxXnAwZ3FyMGdyczFxc3cwZ3d4MXF4IVAwZyFQIVExcSFRIV0wZyFdIV4pUiFeIWExcSFhJGYwZyRmJGcxcSRnfjBnIVowbGFpV09YMGdYWjFxWl0wZ11eMXFecDBncXIwZ3JzMXFzdzBnd3gxcXghUDBnIVAhUTFxIVEhXTBnIV0hXjJWIV4hYTFxIWEkZjBnJGYkZzFxJGd+MGchUjF0U09wMXFxIV0xcSFdIV4yUSFefjFxIVIyVk9gIVIhWjJeWGlXYCFST1gpUlpdKVJecClScXIpUnN3KVJ4IVApUiFRIV4pUiFhJGYpUiRnfilSIVozU1UhYXheUCFgYE9yJ3JycydYc3YncnchXidyIV4hXyhdIV9+J3IhXTNxZV5QaVchYGAhYnBPWCRrWFomUlpdJGtdXiZSXnAka3BxJlJxciRrcnMmcXN2JGt2dylSd3gncnh9JGt9IU81UyFPIVAkayFQIVEmUiFRIV4kayFeIV8oayFfIWEmUiFhJGYkayRmJGcmUiRnfiRrIV01X2ReUGlXIWBgIWJwT1gka1haJlJaXSRrXV4mUl5wJGtwcSZScXIka3JzJnFzdiRrdncpUnd4J3J4IVAkayFQIVEmUiFRIV4kayFeIV8oayFfIWAmUiFgIWE2bSFhJGYkayRmJGcmUiRnfiRrIVQ2eFZeUCFgYCFicCFkUU9yJlJycyZxc3YmUnd4J3J4IV4mUiFeIV8oayFffiZSIVg3aFheUCFgYCFicE9yJlJycyZxc3YmUnd4J3J4IV4mUiFeIV8oayFfIWAmUiFgIWE4VCFhfiZSIVg4YFZqVV5QIWBgIWJwT3ImUnJzJnFzdiZSd3gncnghXiZSIV4hXyhrIV9+JlIhYTlVIVlmU2RRXlBpVyFgYCFicE9YJGtYWiZSWl0ka11eJlJecCRrcHEmUnFyJGtycyZxc3Yka3Z3KVJ3eCdyeH0ka30hTzh1IU8hUDh1IVAhUSZSIVEhWzh1IVshXTh1IV0hXiRrIV4hXyhrIV8hYSZSIWEhYyRrIWMhfTh1IX0jUiRrI1IjUzh1I1MjVCRrI1Qjbzh1I28kZiRrJGYkZyZSJGckfSRrJH0lTzh1JU8lVyRrJVclbzh1JW8lcCRrJXAmYTh1JmEmYiRrJmIxcDh1MXA0VTh1NFU0ZDh1NGQ0ZSRrNGUkSVM4dSRJUyRJYCRrJElgJEliOHUkSWIkSmUkayRKZSRKZzh1JEpnJEtoJGskS2glI3Q4dSUjdCYveCRrJi94JkV0OHUmRXQmRlYkayZGVjsnUzh1OydTOzpqPHQ7Omo/JnIkaz8mcj9BaDh1P0FoP0JZJGs/Qlk/TW44dT9Nbn4kayFhPVBlXlBpVyFgYCFicE9YJGtYWiZSWl0ka11eJlJecCRrcHEmUnFyJGtycyZxc3Yka3Z3KVJ3eCdyeCFQJGshUCFRJlIhUSFeJGshXiFfKGshXyFhJlIhYSRmJGskZiRnJlIkZzs9YCRrOz1gPCVsOHU8JWx+JGshUj5pVyFgYCFicE9xKGtxcj9ScnMnZ3N2KGt3eChdeCFhKGshYSFiS2ohYn4oayFSP1laIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXh9KGt9IU8/eyFPIWYoayFmIWdBUiFnI1coayNXI1hHeiNYfihrIVJAU1YhYGAhYnBPcihrcnMnZ3N2KGt3eChdeH0oa30hT0BpIU9+KGshUkByVCFgYCFicCFjUE9yKGtycydnc3Yoa3d4KF14fihrIVJBWVYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCFxKGshcSFyQW8hcn4oayFSQXZWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXghZShrIWUhZkJdIWZ+KGshUkJkViFgYCFicE9yKGtycydnc3Yoa3d4KF14IXYoayF2IXdCeSF3fihrIVJDUVYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCF7KGsheyF8Q2chfH4oayFSQ25WIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXghcihrIXIhc0RUIXN+KGshUkRbViFgYCFicE9yKGtycydnc3Yoa3d4KF14IWcoayFnIWhEcSFofihrIVJEeFchYGAhYnBPckRxcnNFYnN2RHF2d0V2d3hGZnghYERxIWAhYUdiIWF+RHFxRWdUIWJwT3ZFYnZ4RXZ4IWBFYiFgIWFGWCFhfkViUEV5Uk8hYEV2IWAhYUZTIWF+RXZQRlhPelBxRmBRIWJwelBPdidneH4nZ2FGa1YhYGBPckZmcnNFdnN2RmZ2d0V2dyFgRmYhYCFhR1EhYX5GZmFHWFIhYGB6UE9yKF1zdihdd34oXSFSR2tUIWBgIWJwelBPcihrcnMnZ3N2KGt3eChdeH4oayFSSFJWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXgjYyhrI2MjZEhoI2R+KGshUkhvViFgYCFicE9yKGtycydnc3Yoa3d4KF14I1YoayNWI1dJVSNXfihrIVJJXVYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCNoKGsjaCNpSXIjaX4oayFSSXlWIWBgIWJwT3Ioa3JzJ2dzdihrd3goXXgjbShrI20jbkpgI25+KGshUkpnViFgYCFicE9yKGtycydnc3Yoa3d4KF14I2QoayNkI2VKfCNlfihrIVJLVFYhYGAhYnBPcihrcnMnZ3N2KGt3eChdeCNYKGsjWCNZRHEjWX4oayFSS3FXIWBgIWJwT3JLanJzTFpzdktqdndMb3d4TlB4IWFLaiFhIWIhIGchYn5LanFMYFQhYnBPdkxadnhMb3ghYUxaIWEhYk1eIWJ+TFpQTHJSTyFhTG8hYSFiTHshYn5Mb1BNT1JPIWBMbyFgIWFNWCFhfkxvUE1eT3dQcU1jVCFicE92TFp2eExveCFgTFohYCFhTXIhYX5MWnFNeVEhYnB3UE92J2d4fidnYU5VViFgYE9yTlByc0xvc3ZOUHZ3TG93IWFOUCFhIWJOayFifk5QYU5wViFgYE9yTlByc0xvc3ZOUHZ3TG93IWBOUCFgIWEhIFYhYX5OUGEhIF5SIWBgd1BPcihdc3YoXXd+KF0hUiEgblchYGAhYnBPcktqcnNMWnN2S2p2d0xvd3hOUHghYEtqIWAhYSEhVyFhfktqIVIhIWFUIWBgIWJwd1BPcihrcnMnZ3N2KGt3eChdeH4oayFWISF7VmdTXlAhYGAhYnBPciZScnMmcXN2JlJ3eCdyeCFeJlIhXiFfKGshX34mUlwiLFxuICB0b2tlbml6ZXJzOiBbc2NyaXB0VG9rZW5zLCBzdHlsZVRva2VucywgdGV4dGFyZWFUb2tlbnMsIHRhZ1N0YXJ0LCBjb21tZW50Q29udGVudCwgMCwgMSwgMiwgMywgNCwgNV0sXG4gIHRvcFJ1bGVzOiB7XCJEb2N1bWVudFwiOlswLDEzXX0sXG4gIGRpYWxlY3RzOiB7bm9NYXRjaDogMH0sXG4gIHRva2VuUHJlYzogNDc2XG59KTtcblxuZnVuY3Rpb24gZ2V0QXR0cnMoZWxlbWVudCwgaW5wdXQpIHtcbiAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChsZXQgYXR0IG9mIGVsZW1lbnQuZmlyc3RDaGlsZC5nZXRDaGlsZHJlbihcIkF0dHJpYnV0ZVwiKSkge1xuICAgIGxldCBuYW1lID0gYXR0LmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKSwgdmFsdWUgPSBhdHQuZ2V0Q2hpbGQoXCJBdHRyaWJ1dGVWYWx1ZVwiKSB8fCBhdHQuZ2V0Q2hpbGQoXCJVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCIpO1xuICAgIGlmIChuYW1lKSBhdHRyc1tpbnB1dC5yZWFkKG5hbWUuZnJvbSwgbmFtZS50byldID1cbiAgICAgICF2YWx1ZSA/IFwiXCIgOiB2YWx1ZS5uYW1lID09IFwiQXR0cmlidXRlVmFsdWVcIiA/IGlucHV0LnJlYWQodmFsdWUuZnJvbSArIDEsIHZhbHVlLnRvIC0gMSkgOiBpbnB1dC5yZWFkKHZhbHVlLmZyb20sIHZhbHVlLnRvKTtcbiAgfVxuICByZXR1cm4gYXR0cnNcbn1cblxuZnVuY3Rpb24gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCB0YWdzKSB7XG4gIGxldCBhdHRycztcbiAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICBpZiAoIXRhZy5hdHRycyB8fCB0YWcuYXR0cnMoYXR0cnMgfHwgKGF0dHJzID0gZ2V0QXR0cnMobm9kZS5ub2RlLnBhcmVudCwgaW5wdXQpKSkpXG4gICAgICByZXR1cm4ge3BhcnNlcjogdGFnLnBhcnNlcn1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyB0YWdzOiB7XG4vLyAgIHRhZzogXCJzY3JpcHRcIiB8IFwic3R5bGVcIiB8IFwidGV4dGFyZWFcIixcbi8vICAgYXR0cnM/OiAoe1thdHRyOiBzdHJpbmddOiBzdHJpbmd9KSA9PiBib29sZWFuLFxuLy8gICBwYXJzZXI6IFBhcnNlclxuLy8gfVtdXG4gXG5mdW5jdGlvbiBjb25maWd1cmVOZXN0aW5nKHRhZ3MpIHtcbiAgbGV0IHNjcmlwdCA9IFtdLCBzdHlsZSA9IFtdLCB0ZXh0YXJlYSA9IFtdO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGxldCBhcnJheSA9IHRhZy50YWcgPT0gXCJzY3JpcHRcIiA/IHNjcmlwdCA6IHRhZy50YWcgPT0gXCJzdHlsZVwiID8gc3R5bGUgOiB0YWcudGFnID09IFwidGV4dGFyZWFcIiA/IHRleHRhcmVhIDogbnVsbDtcbiAgICBpZiAoIWFycmF5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9ubHkgc2NyaXB0LCBzdHlsZSwgYW5kIHRleHRhcmVhIHRhZ3MgY2FuIGhvc3QgbmVzdGVkIHBhcnNlcnNcIilcbiAgICBhcnJheS5wdXNoKHRhZyk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlTWl4ZWQoKG5vZGUsIGlucHV0KSA9PiB7XG4gICAgbGV0IGlkID0gbm9kZS50eXBlLmlkO1xuICAgIGlmIChpZCA9PSBTY3JpcHRUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzY3JpcHQpXG4gICAgaWYgKGlkID09IFN0eWxlVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgc3R5bGUpXG4gICAgaWYgKGlkID09IFRleHRhcmVhVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgdGV4dGFyZWEpXG4gICAgcmV0dXJuIG51bGxcbiAgfSlcbn1cblxuZXhwb3J0IHsgY29uZmlndXJlTmVzdGluZywgcGFyc2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=