"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_lang-xml_dist_index_js"],{

/***/ "./node_modules/@codemirror/lang-xml/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/lang-xml/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "completeFromSchema": () => (/* binding */ completeFromSchema),
/* harmony export */   "xml": () => (/* binding */ xml),
/* harmony export */   "xmlLanguage": () => (/* binding */ xmlLanguage)
/* harmony export */ });
/* harmony import */ var _lezer_xml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/xml */ "./node_modules/@lezer/xml/dist/index.es.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.js");



function tagName(doc, tag) {
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, name.to) : "";
}
function elementName(doc, tree) {
    let tag = tree && tree.firstChild;
    return !tag || tag.name != "OpenTag" ? "" : tagName(doc, tag);
}
function attrName(doc, tag, pos) {
    let attr = tag && tag.getChildren("Attribute").find(a => a.from <= pos && a.to >= pos);
    let name = attr && attr.getChild("AttributeName");
    return name ? doc.sliceString(name.from, name.to) : "";
}
function findParentElement(tree) {
    for (let cur = tree && tree.parent; cur; cur = cur.parent)
        if (cur.name == "Element")
            return cur;
    return null;
}
function findLocation(state, pos) {
    var _a;
    let at = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(pos, -1), inTag = null;
    for (let cur = at; !inTag && cur.parent; cur = cur.parent)
        if (cur.name == "OpenTag" || cur.name == "CloseTag" || cur.name == "SelfClosingTag" || cur.name == "MismatchedCloseTag")
            inTag = cur;
    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {
        let elt = inTag.parent;
        if (at.name == "TagName")
            return inTag.name == "CloseTag" || inTag.name == "MismatchedCloseTag"
                ? { type: "closeTag", from: at.from, context: elt }
                : { type: "openTag", from: at.from, context: findParentElement(elt) };
        if (at.name == "AttributeName")
            return { type: "attrName", from: at.from, context: inTag };
        if (at.name == "AttributeValue")
            return { type: "attrValue", from: at.from, context: inTag };
        let before = at == inTag || at.name == "Attribute" ? at.childBefore(pos) : at;
        if ((before === null || before === void 0 ? void 0 : before.name) == "StartTag")
            return { type: "openTag", from: pos, context: findParentElement(elt) };
        if ((before === null || before === void 0 ? void 0 : before.name) == "StartCloseTag" && before.to <= pos)
            return { type: "closeTag", from: pos, context: elt };
        if ((before === null || before === void 0 ? void 0 : before.name) == "Is")
            return { type: "attrValue", from: pos, context: inTag };
        if (before)
            return { type: "attrName", from: pos, context: inTag };
        return null;
    }
    else if (at.name == "StartCloseTag") {
        return { type: "closeTag", from: pos, context: at.parent };
    }
    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))
        at = at.parent;
    if (at.name == "Element" || at.name == "Text" || at.name == "Document")
        return { type: "tag", from: pos, context: at.name == "Element" ? at : findParentElement(at) };
    return null;
}
class Element {
    constructor(spec, attrs, attrValues) {
        this.attrs = attrs;
        this.attrValues = attrValues;
        this.children = [];
        this.name = spec.name;
        this.completion = Object.assign(Object.assign({ type: "type" }, spec.completion || {}), { label: this.name });
        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name });
        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 });
        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" });
        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: "text" })) : [];
    }
}
const Identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function attrCompletion(spec) {
    return Object.assign(Object.assign({ type: "property" }, spec.completion || {}), { label: spec.name });
}
function valueCompletion(spec) {
    return typeof spec == "string" ? { label: `"${spec}"`, type: "constant" }
        : /^"/.test(spec.label) ? spec
            : Object.assign(Object.assign({}, spec), { label: `"${spec.label}"` });
}
/**
Create a completion source for the given schema.
*/
function completeFromSchema(eltSpecs, attrSpecs) {
    let allAttrs = [], globalAttrs = [];
    let attrValues = Object.create(null);
    for (let s of attrSpecs) {
        let completion = attrCompletion(s);
        allAttrs.push(completion);
        if (s.global)
            globalAttrs.push(completion);
        if (s.values)
            attrValues[s.name] = s.values.map(valueCompletion);
    }
    let allElements = [], topElements = [];
    let byName = Object.create(null);
    for (let s of eltSpecs) {
        let attrs = globalAttrs, attrVals = attrValues;
        if (s.attributes)
            attrs = attrs.concat(s.attributes.map(s => {
                if (typeof s == "string")
                    return allAttrs.find(a => a.label == s) || { label: s, type: "property" };
                if (s.values) {
                    if (attrVals == attrValues)
                        attrVals = Object.create(attrVals);
                    attrVals[s.name] = s.values.map(valueCompletion);
                }
                return attrCompletion(s);
            }));
        let elt = new Element(s, attrs, attrVals);
        byName[elt.name] = elt;
        allElements.push(elt);
        if (s.top)
            topElements.push(elt);
    }
    if (!topElements.length)
        topElements = allElements;
    for (let i = 0; i < allElements.length; i++) {
        let s = eltSpecs[i], elt = allElements[i];
        if (s.children) {
            for (let ch of s.children)
                if (byName[ch])
                    elt.children.push(byName[ch]);
        }
        else {
            elt.children = allElements;
        }
    }
    return cx => {
        var _a;
        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);
        if (!loc || (loc.type == "tag" && !cx.explicit))
            return null;
        let { type, from, context } = loc;
        if (type == "openTag") {
            let children = topElements;
            let parentName = elementName(doc, context);
            if (parentName) {
                let parent = byName[parentName];
                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;
            }
            return {
                from,
                options: children.map(ch => ch.completion),
                validFor: Identifier
            };
        }
        else if (type == "closeTag") {
            let parentName = elementName(doc, context);
            return parentName ? {
                from,
                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == ">" ? 1 : 0),
                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + ">", type: "type" }],
                validFor: Identifier
            } : null;
        }
        else if (type == "attrName") {
            let parent = byName[tagName(doc, context)];
            return {
                from,
                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,
                validFor: Identifier
            };
        }
        else if (type == "attrValue") {
            let attr = attrName(doc, context, from);
            if (!attr)
                return null;
            let parent = byName[tagName(doc, context)];
            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];
            if (!values || !values.length)
                return null;
            return {
                from,
                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '"' ? 1 : 0),
                options: values,
                validFor: /^"[^"]*"?$/
            };
        }
        else if (type == "tag") {
            let parentName = elementName(doc, context), parent = byName[parentName];
            let closing = [], last = context && context.lastChild;
            if (parentName && (!last || last.name != "CloseTag" || tagName(doc, last) != parentName))
                closing.push(parent ? parent.closeCompletion : { label: "</" + parentName + ">", type: "type", boost: 2 });
            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));
            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {
                let openTag = context.firstChild;
                if (openTag.to > cx.pos - 20 && !/\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))
                    options = options.concat(parent.text);
            }
            return {
                from,
                options,
                validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
            };
        }
        else {
            return null;
        }
    };
}

/**
A language provider based on the [Lezer XML
parser](https://github.com/lezer-parser/xml), extended with
highlighting and indentation information.
*/
const xmlLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LRLanguage.define({
    parser: /*@__PURE__*/_lezer_xml__WEBPACK_IMPORTED_MODULE_0__.parser.configure({
        props: [
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentNodeProp.add({
                Element(context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                }
            }),
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.foldNodeProp.add({
                Element(subtree) {
                    let first = subtree.firstChild, last = subtree.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : subtree.to };
                }
            })
        ]
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/$/
    }
});
/**
XML language support. Includes schema-based autocompletion when
configured.
*/
function xml(conf = {}) {
    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(xmlLanguage, xmlLanguage.data.of({
        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])
    }));
}




/***/ }),

/***/ "./node_modules/@lezer/xml/dist/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/xml/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.js");
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.js");



// This file was generated by lezer-generator. You probably shouldn't edit it.
const StartTag = 1,
  StartCloseTag = 2,
  MissingCloseTag = 3,
  mismatchedStartCloseTag = 4,
  incompleteStartCloseTag = 5,
  commentContent$1 = 35,
  piContent$1 = 36,
  cdataContent$1 = 37,
  Element = 11,
  OpenTag = 13;

/* Hand-written tokenizer for XML tag matching. */

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedInput == input && cachedPos == pos) return cachedName
  while (isSpace(input.peek(offset))) offset++;
  let name = "";
  for (;;) {
    let next = input.peek(offset);
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    offset++;
  }
  cachedInput = input; cachedPos = pos;
  return cachedName = name || null
}

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}

const elementContext = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, _stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  hash(context) { return context ? context.hash : 0 },
  strict: false
});

const startTag = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {
  if (input.next != 60 /* '<' */) return
  input.advance();
  if (input.next == 47 /* '/' */) {
    input.advance();
    let name = tagNameAfter(input, 0);
    if (!name) return input.acceptToken(incompleteStartCloseTag)
    if (stack.context && name == stack.context.name) return input.acceptToken(StartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return input.acceptToken(MissingCloseTag, -2)
    input.acceptToken(mismatchedStartCloseTag);
  } else if (input.next != 33 /* '!' */ && input.next != 63 /* '?' */) {
    return input.acceptToken(StartTag)
  }
}, {contextual: true});

function scanTo(type, end) {
  return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {
    for (let endPos = 0, len = 0;; len++) {
      if (input.next < 0) {
        if (len) input.acceptToken(type);
        break
      } 
      if (input.next == end.charCodeAt(endPos)) {
        endPos++;
        if (endPos == end.length) {
          if (len > end.length) input.acceptToken(type, 1 - end.length);
          break
        }
      } else {
        endPos = input.next == end.charCodeAt(0) ? 1 : 0;
      }
      input.advance();
    }
  })
}

const commentContent = scanTo(commentContent$1, "-->");
const piContent = scanTo(piContent$1, "?>");
const cdataContent = scanTo(cdataContent$1, "]]>");

const xmlHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({
  Text: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,
  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,
  "MismatchedCloseTag/Tagname": [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid],
  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,
  AttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,
  Is: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,
  "EntityReference CharacterReference": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,
  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,
  ProcessingInst: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,
  DoctypeDecl: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.documentMeta,
  Cdata: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: elementContext,
  nodeProps: [
    ["closedBy", 1,"SelfCloseEndTag EndTag",13,"CloseTag MissingCloseTag"],
    ["openedBy", 12,"StartTag StartCloseTag",19,"OpenTag",20,"StartTag"]
  ],
  propSources: [xmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "Az~R!WOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs&tsv$kvw'Uw}$k}!O(q!O!P$k!P!Q*n!Q![$k![!]+z!]!^$k!^!_/s!_!`=i!`!a>U!a!b>q!b!c$k!c!}+z!}#P$k#P#Q?}#Q#R$k#R#S+z#S#T$k#T#o+z#o%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U$k4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$kX$rUVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kP%ZRVPOv%Uw!^%U!_~%UW%iR{WOr%dsv%dw~%d_%{]VP{WyUOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs%Usv$kw!^$k!^!_%d!_~$kZ&{RzYVPOv%Uw!^%U!_~%U~'XTOp'hqs'hst(Pt!]'h!^~'h~'kTOp'hqs'ht!]'h!]!^'z!^~'h~(POW~~(SROp(]q!](]!^~(]~(`SOp(]q!](]!]!^(l!^~(]~(qOX~Z(xWVP{WOr$krs%Usv$kw}$k}!O)b!O!^$k!^!_%d!_~$kZ)iWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a*R!a~$kZ*[U|QVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k]*uWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a+_!a~$k]+hUdSVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k_,V}`S^QVP{WOr$krs%Usv$kw}$k}!O+z!O!P+z!P!Q$k!Q![+z![!]+z!]!^$k!^!_%d!_!c$k!c!}+z!}#R$k#R#S+z#S#T$k#T#o+z#o$}$k$}%O+z%O%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U+z4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Je$k$Je$Jg+z$Jg$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$k_/ZWVP{WOr$krs%Usv$kw!^$k!^!_%d!_;=`$k;=`<%l+z<%l~$kX/xU{WOq%dqr0[sv%dw!a%d!a!b=X!b~%dX0aZ{WOr%dsv%dw}%d}!O1S!O!f%d!f!g1x!g!}%d!}#O5s#O#W%d#W#X:k#X~%dX1XT{WOr%dsv%dw}%d}!O1h!O~%dX1oR}P{WOr%dsv%dw~%dX1}T{WOr%dsv%dw!q%d!q!r2^!r~%dX2cT{WOr%dsv%dw!e%d!e!f2r!f~%dX2wT{WOr%dsv%dw!v%d!v!w3W!w~%dX3]T{WOr%dsv%dw!{%d!{!|3l!|~%dX3qT{WOr%dsv%dw!r%d!r!s4Q!s~%dX4VT{WOr%dsv%dw!g%d!g!h4f!h~%dX4kV{WOr4frs5Qsv4fvw5Qw!`4f!`!a5c!a~4fP5TRO!`5Q!`!a5^!a~5QP5cOiPX5jRiP{WOr%dsv%dw~%dX5xV{WOr%dsv%dw!e%d!e!f6_!f#V%d#V#W8w#W~%dX6dT{WOr%dsv%dw!f%d!f!g6s!g~%dX6xT{WOr%dsv%dw!c%d!c!d7X!d~%dX7^T{WOr%dsv%dw!v%d!v!w7m!w~%dX7rT{WOr%dsv%dw!c%d!c!d8R!d~%dX8WT{WOr%dsv%dw!}%d!}#O8g#O~%dX8nR{WxPOr%dsv%dw~%dX8|T{WOr%dsv%dw#W%d#W#X9]#X~%dX9bT{WOr%dsv%dw#T%d#T#U9q#U~%dX9vT{WOr%dsv%dw#h%d#h#i:V#i~%dX:[T{WOr%dsv%dw#T%d#T#U8R#U~%dX:pT{WOr%dsv%dw#c%d#c#d;P#d~%dX;UT{WOr%dsv%dw#V%d#V#W;e#W~%dX;jT{WOr%dsv%dw#h%d#h#i;y#i~%dX<OT{WOr%dsv%dw#m%d#m#n<_#n~%dX<dT{WOr%dsv%dw#d%d#d#e<s#e~%dX<xT{WOr%dsv%dw#X%d#X#Y4f#Y~%dX=`R!PP{WOr%dsv%dw~%dZ=rUaQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k_>_U[UVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ>xWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a?b!a~$kZ?kU!OQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ@UWVP{WOr$krs%Usv$kw!^$k!^!_%d!_#P$k#P#Q@n#Q~$kZ@uWVP{WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!aA_!a~$kZAhUwQVP{WOr$krs%Usv$kw!^$k!^!_%d!_~$k",
  tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],
  topRules: {"Document":[0,6]},
  tokenPrec: 0
});




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sYW5nLXhtbF9kaXN0X2luZGV4X2pzLjhiMjVhZmY5ZDM3ZGFhMDliYjMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ3lFOztBQUU3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRUFBVTtBQUN2Qix1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLHVCQUF1QixLQUFLLGtCQUFrQjtBQUNwSCw0REFBNEQsc0JBQXNCLHdCQUF3QjtBQUMxRyw2REFBNkQsc0JBQXNCLHlDQUF5QztBQUM1SCxpRUFBaUUsc0JBQXNCLHdCQUF3QjtBQUMvRyxvRUFBb0Usd0JBQXdCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQix1QkFBdUIsS0FBSyxrQkFBa0I7QUFDekc7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLEtBQUs7QUFDdkQ7QUFDQSw0Q0FBNEMsV0FBVyxXQUFXLFdBQVcsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QyxnREFBZ0Qsa0RBQWtEO0FBQ2oyRTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsQ0FBQzs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy14bWwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGxlemVyL3htbC9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci94bWwnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGZvbGROb2RlUHJvcCwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG5mdW5jdGlvbiB0YWdOYW1lKGRvYywgdGFnKSB7XG4gICAgbGV0IG5hbWUgPSB0YWcgJiYgdGFnLmdldENoaWxkKFwiVGFnTmFtZVwiKTtcbiAgICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIG5hbWUudG8pIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSkge1xuICAgIGxldCB0YWcgPSB0cmVlICYmIHRyZWUuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gIXRhZyB8fCB0YWcubmFtZSAhPSBcIk9wZW5UYWdcIiA/IFwiXCIgOiB0YWdOYW1lKGRvYywgdGFnKTtcbn1cbmZ1bmN0aW9uIGF0dHJOYW1lKGRvYywgdGFnLCBwb3MpIHtcbiAgICBsZXQgYXR0ciA9IHRhZyAmJiB0YWcuZ2V0Q2hpbGRyZW4oXCJBdHRyaWJ1dGVcIikuZmluZChhID0+IGEuZnJvbSA8PSBwb3MgJiYgYS50byA+PSBwb3MpO1xuICAgIGxldCBuYW1lID0gYXR0ciAmJiBhdHRyLmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKTtcbiAgICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIG5hbWUudG8pIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSB0cmVlICYmIHRyZWUucGFyZW50OyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChjdXIubmFtZSA9PSBcIkVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTG9jYXRpb24oc3RhdGUsIHBvcykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgYXQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSksIGluVGFnID0gbnVsbDtcbiAgICBmb3IgKGxldCBjdXIgPSBhdDsgIWluVGFnICYmIGN1ci5wYXJlbnQ7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChjdXIubmFtZSA9PSBcIk9wZW5UYWdcIiB8fCBjdXIubmFtZSA9PSBcIkNsb3NlVGFnXCIgfHwgY3VyLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiIHx8IGN1ci5uYW1lID09IFwiTWlzbWF0Y2hlZENsb3NlVGFnXCIpXG4gICAgICAgICAgICBpblRhZyA9IGN1cjtcbiAgICBpZiAoaW5UYWcgJiYgKGluVGFnLnRvID4gcG9zIHx8IGluVGFnLmxhc3RDaGlsZC50eXBlLmlzRXJyb3IpKSB7XG4gICAgICAgIGxldCBlbHQgPSBpblRhZy5wYXJlbnQ7XG4gICAgICAgIGlmIChhdC5uYW1lID09IFwiVGFnTmFtZVwiKVxuICAgICAgICAgICAgcmV0dXJuIGluVGFnLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGluVGFnLm5hbWUgPT0gXCJNaXNtYXRjaGVkQ2xvc2VUYWdcIlxuICAgICAgICAgICAgICAgID8geyB0eXBlOiBcImNsb3NlVGFnXCIsIGZyb206IGF0LmZyb20sIGNvbnRleHQ6IGVsdCB9XG4gICAgICAgICAgICAgICAgOiB7IHR5cGU6IFwib3BlblRhZ1wiLCBmcm9tOiBhdC5mcm9tLCBjb250ZXh0OiBmaW5kUGFyZW50RWxlbWVudChlbHQpIH07XG4gICAgICAgIGlmIChhdC5uYW1lID09IFwiQXR0cmlidXRlTmFtZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhdHRyTmFtZVwiLCBmcm9tOiBhdC5mcm9tLCBjb250ZXh0OiBpblRhZyB9O1xuICAgICAgICBpZiAoYXQubmFtZSA9PSBcIkF0dHJpYnV0ZVZhbHVlXCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImF0dHJWYWx1ZVwiLCBmcm9tOiBhdC5mcm9tLCBjb250ZXh0OiBpblRhZyB9O1xuICAgICAgICBsZXQgYmVmb3JlID0gYXQgPT0gaW5UYWcgfHwgYXQubmFtZSA9PSBcIkF0dHJpYnV0ZVwiID8gYXQuY2hpbGRCZWZvcmUocG9zKSA6IGF0O1xuICAgICAgICBpZiAoKGJlZm9yZSA9PT0gbnVsbCB8fCBiZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlZm9yZS5uYW1lKSA9PSBcIlN0YXJ0VGFnXCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9wZW5UYWdcIiwgZnJvbTogcG9zLCBjb250ZXh0OiBmaW5kUGFyZW50RWxlbWVudChlbHQpIH07XG4gICAgICAgIGlmICgoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlLm5hbWUpID09IFwiU3RhcnRDbG9zZVRhZ1wiICYmIGJlZm9yZS50byA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImNsb3NlVGFnXCIsIGZyb206IHBvcywgY29udGV4dDogZWx0IH07XG4gICAgICAgIGlmICgoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlLm5hbWUpID09IFwiSXNcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiYXR0clZhbHVlXCIsIGZyb206IHBvcywgY29udGV4dDogaW5UYWcgfTtcbiAgICAgICAgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiYXR0ck5hbWVcIiwgZnJvbTogcG9zLCBjb250ZXh0OiBpblRhZyB9O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXQubmFtZSA9PSBcIlN0YXJ0Q2xvc2VUYWdcIikge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNsb3NlVGFnXCIsIGZyb206IHBvcywgY29udGV4dDogYXQucGFyZW50IH07XG4gICAgfVxuICAgIHdoaWxlIChhdC5wYXJlbnQgJiYgYXQudG8gPT0gcG9zICYmICEoKF9hID0gYXQubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZS5pc0Vycm9yKSlcbiAgICAgICAgYXQgPSBhdC5wYXJlbnQ7XG4gICAgaWYgKGF0Lm5hbWUgPT0gXCJFbGVtZW50XCIgfHwgYXQubmFtZSA9PSBcIlRleHRcIiB8fCBhdC5uYW1lID09IFwiRG9jdW1lbnRcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YWdcIiwgZnJvbTogcG9zLCBjb250ZXh0OiBhdC5uYW1lID09IFwiRWxlbWVudFwiID8gYXQgOiBmaW5kUGFyZW50RWxlbWVudChhdCkgfTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIGF0dHJzLCBhdHRyVmFsdWVzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5hdHRyVmFsdWVzID0gYXR0clZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLm5hbWUgPSBzcGVjLm5hbWU7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwidHlwZVwiIH0sIHNwZWMuY29tcGxldGlvbiB8fCB7fSksIHsgbGFiZWw6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5vcGVuQ29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21wbGV0aW9uKSwgeyBsYWJlbDogXCI8XCIgKyB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuY2xvc2VDb21wbGV0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBsZXRpb24pLCB7IGxhYmVsOiBcIjwvXCIgKyB0aGlzLm5hbWUgKyBcIj5cIiwgYm9vc3Q6IDIgfSk7XG4gICAgICAgIHRoaXMuY2xvc2VOYW1lQ29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21wbGV0aW9uKSwgeyBsYWJlbDogdGhpcy5uYW1lICsgXCI+XCIgfSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHNwZWMudGV4dENvbnRlbnQgPyBzcGVjLnRleHRDb250ZW50Lm1hcChzID0+ICh7IGxhYmVsOiBzLCB0eXBlOiBcInRleHRcIiB9KSkgOiBbXTtcbiAgICB9XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC87XG5mdW5jdGlvbiBhdHRyQ29tcGxldGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwicHJvcGVydHlcIiB9LCBzcGVjLmNvbXBsZXRpb24gfHwge30pLCB7IGxhYmVsOiBzcGVjLm5hbWUgfSk7XG59XG5mdW5jdGlvbiB2YWx1ZUNvbXBsZXRpb24oc3BlYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogYFwiJHtzcGVjfVwiYCwgdHlwZTogXCJjb25zdGFudFwiIH1cbiAgICAgICAgOiAvXlwiLy50ZXN0KHNwZWMubGFiZWwpID8gc3BlY1xuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNwZWMpLCB7IGxhYmVsOiBgXCIke3NwZWMubGFiZWx9XCJgIH0pO1xufVxuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIHNvdXJjZSBmb3IgdGhlIGdpdmVuIHNjaGVtYS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21TY2hlbWEoZWx0U3BlY3MsIGF0dHJTcGVjcykge1xuICAgIGxldCBhbGxBdHRycyA9IFtdLCBnbG9iYWxBdHRycyA9IFtdO1xuICAgIGxldCBhdHRyVmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzIG9mIGF0dHJTcGVjcykge1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IGF0dHJDb21wbGV0aW9uKHMpO1xuICAgICAgICBhbGxBdHRycy5wdXNoKGNvbXBsZXRpb24pO1xuICAgICAgICBpZiAocy5nbG9iYWwpXG4gICAgICAgICAgICBnbG9iYWxBdHRycy5wdXNoKGNvbXBsZXRpb24pO1xuICAgICAgICBpZiAocy52YWx1ZXMpXG4gICAgICAgICAgICBhdHRyVmFsdWVzW3MubmFtZV0gPSBzLnZhbHVlcy5tYXAodmFsdWVDb21wbGV0aW9uKTtcbiAgICB9XG4gICAgbGV0IGFsbEVsZW1lbnRzID0gW10sIHRvcEVsZW1lbnRzID0gW107XG4gICAgbGV0IGJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcyBvZiBlbHRTcGVjcykge1xuICAgICAgICBsZXQgYXR0cnMgPSBnbG9iYWxBdHRycywgYXR0clZhbHMgPSBhdHRyVmFsdWVzO1xuICAgICAgICBpZiAocy5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5jb25jYXQocy5hdHRyaWJ1dGVzLm1hcChzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbEF0dHJzLmZpbmQoYSA9PiBhLmxhYmVsID09IHMpIHx8IHsgbGFiZWw6IHMsIHR5cGU6IFwicHJvcGVydHlcIiB9O1xuICAgICAgICAgICAgICAgIGlmIChzLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0clZhbHMgPT0gYXR0clZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJWYWxzID0gT2JqZWN0LmNyZWF0ZShhdHRyVmFscyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWxzW3MubmFtZV0gPSBzLnZhbHVlcy5tYXAodmFsdWVDb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJDb21wbGV0aW9uKHMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZWx0ID0gbmV3IEVsZW1lbnQocywgYXR0cnMsIGF0dHJWYWxzKTtcbiAgICAgICAgYnlOYW1lW2VsdC5uYW1lXSA9IGVsdDtcbiAgICAgICAgYWxsRWxlbWVudHMucHVzaChlbHQpO1xuICAgICAgICBpZiAocy50b3ApXG4gICAgICAgICAgICB0b3BFbGVtZW50cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIGlmICghdG9wRWxlbWVudHMubGVuZ3RoKVxuICAgICAgICB0b3BFbGVtZW50cyA9IGFsbEVsZW1lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHMgPSBlbHRTcGVjc1tpXSwgZWx0ID0gYWxsRWxlbWVudHNbaV07XG4gICAgICAgIGlmIChzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChieU5hbWVbY2hdKVxuICAgICAgICAgICAgICAgICAgICBlbHQuY2hpbGRyZW4ucHVzaChieU5hbWVbY2hdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdC5jaGlsZHJlbiA9IGFsbEVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjeCA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHsgZG9jIH0gPSBjeC5zdGF0ZSwgbG9jID0gZmluZExvY2F0aW9uKGN4LnN0YXRlLCBjeC5wb3MpO1xuICAgICAgICBpZiAoIWxvYyB8fCAobG9jLnR5cGUgPT0gXCJ0YWdcIiAmJiAhY3guZXhwbGljaXQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb20sIGNvbnRleHQgfSA9IGxvYztcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJvcGVuVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRvcEVsZW1lbnRzO1xuICAgICAgICAgICAgbGV0IHBhcmVudE5hbWUgPSBlbGVtZW50TmFtZShkb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gYnlOYW1lW3BhcmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbikgfHwgYWxsRWxlbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgb3B0aW9uczogY2hpbGRyZW4ubWFwKGNoID0+IGNoLmNvbXBsZXRpb24pLFxuICAgICAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50TmFtZSA9IGVsZW1lbnROYW1lKGRvYywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50TmFtZSA/IHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBjeC5wb3MgKyAoZG9jLnNsaWNlU3RyaW5nKGN4LnBvcywgY3gucG9zICsgMSkgPT0gXCI+XCIgPyAxIDogMCksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogWygoX2EgPSBieU5hbWVbcGFyZW50TmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZU5hbWVDb21wbGV0aW9uKSB8fCB7IGxhYmVsOiBwYXJlbnROYW1lICsgXCI+XCIsIHR5cGU6IFwidHlwZVwiIH1dLFxuICAgICAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiYXR0ck5hbWVcIikge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGJ5TmFtZVt0YWdOYW1lKGRvYywgY29udGV4dCldO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYXR0cnMpIHx8IGdsb2JhbEF0dHJzLFxuICAgICAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJhdHRyVmFsdWVcIikge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyTmFtZShkb2MsIGNvbnRleHQsIGZyb20pO1xuICAgICAgICAgICAgaWYgKCFhdHRyKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGJ5TmFtZVt0YWdOYW1lKGRvYywgY29udGV4dCldO1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9ICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmF0dHJWYWx1ZXMpIHx8IGF0dHJWYWx1ZXMpW2F0dHJdO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZXMgfHwgIXZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG86IGN4LnBvcyArIChkb2Muc2xpY2VTdHJpbmcoY3gucG9zLCBjeC5wb3MgKyAxKSA9PSAnXCInID8gMSA6IDApLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgICB2YWxpZEZvcjogL15cIlteXCJdKlwiPyQvXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ0YWdcIikge1xuICAgICAgICAgICAgbGV0IHBhcmVudE5hbWUgPSBlbGVtZW50TmFtZShkb2MsIGNvbnRleHQpLCBwYXJlbnQgPSBieU5hbWVbcGFyZW50TmFtZV07XG4gICAgICAgICAgICBsZXQgY2xvc2luZyA9IFtdLCBsYXN0ID0gY29udGV4dCAmJiBjb250ZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lICYmICghbGFzdCB8fCBsYXN0Lm5hbWUgIT0gXCJDbG9zZVRhZ1wiIHx8IHRhZ05hbWUoZG9jLCBsYXN0KSAhPSBwYXJlbnROYW1lKSlcbiAgICAgICAgICAgICAgICBjbG9zaW5nLnB1c2gocGFyZW50ID8gcGFyZW50LmNsb3NlQ29tcGxldGlvbiA6IHsgbGFiZWw6IFwiPC9cIiArIHBhcmVudE5hbWUgKyBcIj5cIiwgdHlwZTogXCJ0eXBlXCIsIGJvb3N0OiAyIH0pO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBjbG9zaW5nLmNvbmNhdCgoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbikgfHwgKGNvbnRleHQgPyBhbGxFbGVtZW50cyA6IHRvcEVsZW1lbnRzKSkubWFwKGUgPT4gZS5vcGVuQ29tcGxldGlvbikpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3BlblRhZyA9IGNvbnRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZy50byA+IGN4LnBvcyAtIDIwICYmICEvXFxTLy50ZXN0KGN4LnN0YXRlLnNsaWNlRG9jKG9wZW5UYWcudG8sIGN4LnBvcykpKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQocGFyZW50LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdmFsaWRGb3I6IC9ePFxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIFhNTFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL3htbCksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgeG1sTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChzdWJ0cmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHN1YnRyZWUuZmlyc3RDaGlsZCwgbGFzdCA9IHN1YnRyZWUubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGZpcnN0Lm5hbWUgIT0gXCJPcGVuVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0Lm5hbWUgPT0gXCJDbG9zZVRhZ1wiID8gbGFzdC5mcm9tIDogc3VidHJlZS50byB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcIjwhLS1cIiwgY2xvc2U6IFwiLS0+XCIgfSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccyo8XFwvJC9cbiAgICB9XG59KTtcbi8qKlxuWE1MIGxhbmd1YWdlIHN1cHBvcnQuIEluY2x1ZGVzIHNjaGVtYS1iYXNlZCBhdXRvY29tcGxldGlvbiB3aGVuXG5jb25maWd1cmVkLlxuKi9cbmZ1bmN0aW9uIHhtbChjb25mID0ge30pIHtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydCh4bWxMYW5ndWFnZSwgeG1sTGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgIGF1dG9jb21wbGV0ZTogY29tcGxldGVGcm9tU2NoZW1hKGNvbmYuZWxlbWVudHMgfHwgW10sIGNvbmYuYXR0cmlidXRlcyB8fCBbXSlcbiAgICB9KSk7XG59XG5cbmV4cG9ydCB7IGNvbXBsZXRlRnJvbVNjaGVtYSwgeG1sLCB4bWxMYW5ndWFnZSB9O1xuIiwiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBTdGFydFRhZyA9IDEsXG4gIFN0YXJ0Q2xvc2VUYWcgPSAyLFxuICBNaXNzaW5nQ2xvc2VUYWcgPSAzLFxuICBtaXNtYXRjaGVkU3RhcnRDbG9zZVRhZyA9IDQsXG4gIGluY29tcGxldGVTdGFydENsb3NlVGFnID0gNSxcbiAgY29tbWVudENvbnRlbnQkMSA9IDM1LFxuICBwaUNvbnRlbnQkMSA9IDM2LFxuICBjZGF0YUNvbnRlbnQkMSA9IDM3LFxuICBFbGVtZW50ID0gMTEsXG4gIE9wZW5UYWcgPSAxMztcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplciBmb3IgWE1MIHRhZyBtYXRjaGluZy4gKi9cblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjFcbn1cblxuZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT0gOSB8fCBjaCA9PSAxMCB8fCBjaCA9PSAxMyB8fCBjaCA9PSAzMlxufVxuXG5sZXQgY2FjaGVkTmFtZSA9IG51bGwsIGNhY2hlZElucHV0ID0gbnVsbCwgY2FjaGVkUG9zID0gMDtcbmZ1bmN0aW9uIHRhZ05hbWVBZnRlcihpbnB1dCwgb2Zmc2V0KSB7XG4gIGxldCBwb3MgPSBpbnB1dC5wb3MgKyBvZmZzZXQ7XG4gIGlmIChjYWNoZWRJbnB1dCA9PSBpbnB1dCAmJiBjYWNoZWRQb3MgPT0gcG9zKSByZXR1cm4gY2FjaGVkTmFtZVxuICB3aGlsZSAoaXNTcGFjZShpbnB1dC5wZWVrKG9mZnNldCkpKSBvZmZzZXQrKztcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZnNldCk7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgb2Zmc2V0Kys7XG4gIH1cbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDsgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgfHwgbnVsbFxufVxuXG5mdW5jdGlvbiBFbGVtZW50Q29udGV4dChuYW1lLCBwYXJlbnQpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuaGFzaCA9IHBhcmVudCA/IHBhcmVudC5oYXNoIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB0aGlzLmhhc2ggKz0gKHRoaXMuaGFzaCA8PCA0KSArIG5hbWUuY2hhckNvZGVBdChpKSArIChuYW1lLmNoYXJDb2RlQXQoaSkgPDwgOCk7XG59XG5cbmNvbnN0IGVsZW1lbnRDb250ZXh0ID0gbmV3IENvbnRleHRUcmFja2VyKHtcbiAgc3RhcnQ6IG51bGwsXG4gIHNoaWZ0KGNvbnRleHQsIHRlcm0sIHN0YWNrLCBpbnB1dCkge1xuICAgIHJldHVybiB0ZXJtID09IFN0YXJ0VGFnID8gbmV3IEVsZW1lbnRDb250ZXh0KHRhZ05hbWVBZnRlcihpbnB1dCwgMSkgfHwgXCJcIiwgY29udGV4dCkgOiBjb250ZXh0XG4gIH0sXG4gIHJlZHVjZShjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm0gPT0gRWxlbWVudCAmJiBjb250ZXh0ID8gY29udGV4dC5wYXJlbnQgOiBjb250ZXh0XG4gIH0sXG4gIHJldXNlKGNvbnRleHQsIG5vZGUsIF9zdGFjaywgaW5wdXQpIHtcbiAgICBsZXQgdHlwZSA9IG5vZGUudHlwZS5pZDtcbiAgICByZXR1cm4gdHlwZSA9PSBTdGFydFRhZyB8fCB0eXBlID09IE9wZW5UYWdcbiAgICAgID8gbmV3IEVsZW1lbnRDb250ZXh0KHRhZ05hbWVBZnRlcihpbnB1dCwgMSkgfHwgXCJcIiwgY29udGV4dCkgOiBjb250ZXh0XG4gIH0sXG4gIGhhc2goY29udGV4dCkgeyByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuaGFzaCA6IDAgfSxcbiAgc3RyaWN0OiBmYWxzZVxufSk7XG5cbmNvbnN0IHN0YXJ0VGFnID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgIT0gNjAgLyogJzwnICovKSByZXR1cm5cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBpZiAoaW5wdXQubmV4dCA9PSA0NyAvKiAnLycgKi8pIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKGluY29tcGxldGVTdGFydENsb3NlVGFnKVxuICAgIGlmIChzdGFjay5jb250ZXh0ICYmIG5hbWUgPT0gc3RhY2suY29udGV4dC5uYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRDbG9zZVRhZylcbiAgICBmb3IgKGxldCBjeCA9IHN0YWNrLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnBhcmVudCkgaWYgKGN4Lm5hbWUgPT0gbmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKE1pc3NpbmdDbG9zZVRhZywgLTIpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcpO1xuICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgIT0gMzMgLyogJyEnICovICYmIGlucHV0Lm5leHQgIT0gNjMgLyogJz8nICovKSB7XG4gICAgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0VGFnKVxuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBzY2FuVG8odHlwZSwgZW5kKSB7XG4gIHJldHVybiBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICAgIGZvciAobGV0IGVuZFBvcyA9IDAsIGxlbiA9IDA7OyBsZW4rKykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICAgIGlmIChsZW4pIGlucHV0LmFjY2VwdFRva2VuKHR5cGUpO1xuICAgICAgICBicmVha1xuICAgICAgfSBcbiAgICAgIGlmIChpbnB1dC5uZXh0ID09IGVuZC5jaGFyQ29kZUF0KGVuZFBvcykpIHtcbiAgICAgICAgZW5kUG9zKys7XG4gICAgICAgIGlmIChlbmRQb3MgPT0gZW5kLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChsZW4gPiBlbmQubGVuZ3RoKSBpbnB1dC5hY2NlcHRUb2tlbih0eXBlLCAxIC0gZW5kLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUG9zID0gaW5wdXQubmV4dCA9PSBlbmQuY2hhckNvZGVBdCgwKSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIH1cbiAgfSlcbn1cblxuY29uc3QgY29tbWVudENvbnRlbnQgPSBzY2FuVG8oY29tbWVudENvbnRlbnQkMSwgXCItLT5cIik7XG5jb25zdCBwaUNvbnRlbnQgPSBzY2FuVG8ocGlDb250ZW50JDEsIFwiPz5cIik7XG5jb25zdCBjZGF0YUNvbnRlbnQgPSBzY2FuVG8oY2RhdGFDb250ZW50JDEsIFwiXV0+XCIpO1xuXG5jb25zdCB4bWxIaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBUZXh0OiB0YWdzLmNvbnRlbnQsXG4gIFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBFbmRUYWcgU2VsZkNsb3NlRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ25hbWVcIjogW3RhZ3MudGFnTmFtZSwgdGFncy5pbnZhbGlkXSxcbiAgQXR0cmlidXRlTmFtZTogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSXM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBcIkVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2VcIjogdGFncy5jaGFyYWN0ZXIsXG4gIENvbW1lbnQ6IHRhZ3MuYmxvY2tDb21tZW50LFxuICBQcm9jZXNzaW5nSW5zdDogdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gIERvY3R5cGVEZWNsOiB0YWdzLmRvY3VtZW50TWV0YSxcbiAgQ2RhdGE6IHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZylcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIsU09RT2FPT09yT3hPJyNDZk96T3BPJyNDaU8hdE9hTycjQ2dPT09QJyNDZycjQ2dPIXtPck8nI0NyTyNUT3RPJyNDc08jXU9wTycjQ3RPT09QJyNEUycjRFNPT09QJyNDdicjQ3ZRUU9hT09PT09XJyNDdycjQ3dPI2VPeE8sNTlRT09PUCw1OVEsNTlRT09PTycjQ3gnI0N4TyNtT3BPLDU5VE8jdU8hYk8sNTlUT09PUCcjQ3snI0N7TyRUT2FPLDU5Uk8kW09wTycjQ29PT09QLDU5Uiw1OVJPT09RJyNDfCcjQ3xPJGRPck8sNTleT09PUCw1OV4sNTleT09PUycjQ30nI0N9TyRsT3RPLDU5X09PT1AsNTlfLDU5X08kdE9wTyw1OWBPJHxPcE8sNTlgT09PUC1FNnQtRTZ0T09PVy1FNnUtRTZ1T09PUDFHLmwxRy5sT09PTy1FNnYtRTZ2TyVVTyFiTzFHLm9PJVVPIWJPMUcub08lZE9wTycjQ2tPJWxPIWJPJyNDeU8lek8hYk8xRy5vT09PUDFHLm8xRy5vT09PUDFHLncxRy53T09PUC1FNnktRTZ5T09PUDFHLm0xRy5tTyZWT3BPLDU5Wk8mX09wTyw1OVpPT09RLUU2ei1FNnpPT09QMUcueDFHLnhPT09TLUU2ey1FNntPT09QMUcueTFHLnlPJmdPcE8xRy56TyZnT3BPMUcuek9PT1AxRy56MUcuek8mb08hYk83KyRaTyZ9TyFiTzcrJFpPT09QNyskWjcrJFpPT09QNyskYzcrJGNPJ1lPcE8sNTlWTydiT3BPLDU5Vk8nak8hYk8sNTllT09PTy1FNnctRTZ3Tyd4T3BPMUcudU8neE9wTzFHLnVPT09QMUcudTFHLnVPKFFPcE83KyRmT09PUDcrJGY3KyRmTyhZTyFiTzw8R3VPT09QPDxHdTw8R3VPT09QPDxHfTw8R31PJ2JPcE8xRy5xTydiT3BPMUcucU8oZU8jdE8nI0NuT09PTzFHLnExRy5xTyhzT3BPNyskYU9PT1A3KyRhNyskYU9PT1A8PEhRPDxIUU9PT1BBTj1hQU49YU9PT1BBTj1pQU49aU8nYk9wTzcrJF1PT09PNyskXTcrJF1PT09PJyNDeicjQ3pPKHtPI3RPLDU5WU9PT08sNTlZLDU5WU9PT1A8PEd7PDxHe09PT088PEd3PDxHd09PT08tRTZ4LUU2eE9PT08xRy50MUcudFwiLFxuICBzdGF0ZURhdGE6IFwiKVp+T1BRT1NWT1RXT1ZXT1dXT1hXT2lYT3hQT31UTyFQVU9+T3VaT3ddT35PXmBPeV5Pfk9QUU9RY09TVk9UV09WV09XV09YV094UE99VE8hUFVPfk9SZE9+UCFTT3NlT3xnT35PdGhPIU9qT35PXmxPeV5Pfk91Wk93b09+T15xT3leT35PW3ZPYHNPZHdPeV5Pfk9SeU9+UCFTT157T3leT35Pc2VPfH1Pfk90aE8hTyFQT35PXiFRT3leT35PWyFTT3leT35PWyFWT2BzT2QhV095Xk9+T2EhWU95Xk9+T3leT1ttWGBtWGRtWH5PWyFWT2BzT2QhV09+T14hXU95Xk9+T1shX095Xk9+T1shYU95Xk9+T1shY09gc09kIWRPeV5Pfk9bIWNPYHNPZCFkT35PYSFlT3leT35PeV5PeiFnT35PeV5PW21hYG1hZG1hfk9bIWpPeV5Pfk9bIWtPeV5Pfk9bIWxPYHNPZCFtT35PVyFwT1ghcE96IXJPeyFwT35PWyFzT3leT35PVyFwT1ghcE96IXZPeyFwT35PXCIsXG4gIGdvdG86IFwiJVt3UFBQUFBQUFBQUHh4UCFPUCFVUFAhXyFpUCFveHh4UCF1IXsjUiRaJGokcCR2JHxQUFBQJVNYV09SWWJYUk9SWWJfdGBxcnUhVCFVIWJRIWghWVMhbyFlIWZSIXQhblFkUlJ5YlhTT1JZYlFZT1JtWVFbUFJuW1FfUVFrVmpwX2tyeiFSIVQhWCFaIV4hYCFmIWkhblFyYFF6Y1EhUmxRIVRxUSFYc1EhWnRRIV57USFgIVFRIWYhWVEhaSFdUiFuIWVRdWBTIVVxclUhW3UhVSFiUiFiIVRRIXEhZ1IhdSFxUWJSUnhiUWZUUnxmUWlVUiFPaVNYT1lUYVJiXCIsXG4gIG5vZGVOYW1lczogXCLimqAgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBNaXNzaW5nQ2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIERvY3VtZW50IFRleHQgRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZSBDZGF0YSBFbGVtZW50IEVuZFRhZyBPcGVuVGFnIFRhZ05hbWUgQXR0cmlidXRlIEF0dHJpYnV0ZU5hbWUgSXMgQXR0cmlidXRlVmFsdWUgQ2xvc2VUYWcgU2VsZkNsb3NlRW5kVGFnIFNlbGZDbG9zaW5nVGFnIENvbW1lbnQgUHJvY2Vzc2luZ0luc3QgTWlzbWF0Y2hlZENsb3NlVGFnIERvY3R5cGVEZWNsXCIsXG4gIG1heFRlcm06IDQ3LFxuICBjb250ZXh0OiBlbGVtZW50Q29udGV4dCxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiY2xvc2VkQnlcIiwgMSxcIlNlbGZDbG9zZUVuZFRhZyBFbmRUYWdcIiwxMyxcIkNsb3NlVGFnIE1pc3NpbmdDbG9zZVRhZ1wiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAxMixcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWdcIiwxOSxcIk9wZW5UYWdcIiwyMCxcIlN0YXJ0VGFnXCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbeG1sSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOCxcbiAgdG9rZW5EYXRhOiBcIkF6flIhV09YJGtYWSVyWVolclpdJGtdXiVyXnAka3BxJXJxciRrcnMmdHN2JGt2dydVd30ka30hTyhxIU8hUCRrIVAhUSpuIVEhWyRrIVshXSt6IV0hXiRrIV4hXy9zIV8hYD1pIWAhYT5VIWEhYj5xIWIhYyRrIWMhfSt6IX0jUCRrI1AjUT99I1EjUiRrI1IjUyt6I1MjVCRrI1Qjbyt6I28lVyRrJVclbyt6JW8lcCRrJXAmYSt6JmEmYiRrJmIxcCt6MXA0VSRrNFU0ZCt6NGQ0ZSRrNGUkSVMreiRJUyRJYCRrJElgJEliK3okSWIkS2gkayRLaCUjdCt6JSN0Ji94JGsmL3gmRXQreiZFdCZGViRrJkZWOydTK3o7J1M7OmovUzs6aj8mciRrPyZyP0FoK3o/QWg/Qlkkaz9CWT9Nbit6P01ufiRrWCRyVVZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFffiRrUCVaUlZQT3YlVXchXiVVIV9+JVVXJWlSe1dPciVkc3YlZHd+JWRfJXtdVlB7V3lVT1gka1hZJXJZWiVyWl0ka11eJXJecCRrcHElcnFyJGtycyVVc3Yka3chXiRrIV4hXyVkIV9+JGtaJntSellWUE92JVV3IV4lVSFffiVVfidYVE9wJ2hxcydoc3QoUHQhXSdoIV5+J2h+J2tUT3AnaHFzJ2h0IV0naCFdIV4neiFefidofihQT1d+fihTUk9wKF1xIV0oXSFefihdfihgU09wKF1xIV0oXSFdIV4obCFefihdfihxT1h+Wih4V1ZQe1dPciRrcnMlVXN2JGt3fSRrfSFPKWIhTyFeJGshXiFfJWQhX34ka1opaVdWUHtXT3Ika3JzJVVzdiRrdyFeJGshXiFfJWQhXyFgJGshYCFhKlIhYX4ka1oqW1V8UVZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFffiRrXSp1V1ZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFfIWAkayFgIWErXyFhfiRrXStoVWRTVlB7V09yJGtycyVVc3Yka3chXiRrIV4hXyVkIV9+JGtfLFZ9YFNeUVZQe1dPciRrcnMlVXN2JGt3fSRrfSFPK3ohTyFQK3ohUCFRJGshUSFbK3ohWyFdK3ohXSFeJGshXiFfJWQhXyFjJGshYyF9K3ohfSNSJGsjUiNTK3ojUyNUJGsjVCNvK3ojbyR9JGskfSVPK3olTyVXJGslVyVvK3olbyVwJGslcCZhK3omYSZiJGsmYjFwK3oxcDRVK3o0VTRkK3o0ZDRlJGs0ZSRJUyt6JElTJElgJGskSWAkSWIreiRJYiRKZSRrJEplJEpnK3okSmckS2gkayRLaCUjdCt6JSN0Ji94JGsmL3gmRXQreiZFdCZGViRrJkZWOydTK3o7J1M7OmovUzs6aj8mciRrPyZyP0FoK3o/QWg/Qlkkaz9CWT9Nbit6P01ufiRrXy9aV1ZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFfOz1gJGs7PWA8JWwrejwlbH4ka1gveFV7V09xJWRxcjBbc3YlZHchYSVkIWEhYj1YIWJ+JWRYMGFae1dPciVkc3YlZHd9JWR9IU8xUyFPIWYlZCFmIWcxeCFnIX0lZCF9I081cyNPI1clZCNXI1g6ayNYfiVkWDFYVHtXT3IlZHN2JWR3fSVkfSFPMWghT34lZFgxb1J9UHtXT3IlZHN2JWR3fiVkWDF9VHtXT3IlZHN2JWR3IXElZCFxIXIyXiFyfiVkWDJjVHtXT3IlZHN2JWR3IWUlZCFlIWYyciFmfiVkWDJ3VHtXT3IlZHN2JWR3IXYlZCF2IXczVyF3fiVkWDNdVHtXT3IlZHN2JWR3IXslZCF7IXwzbCF8fiVkWDNxVHtXT3IlZHN2JWR3IXIlZCFyIXM0USFzfiVkWDRWVHtXT3IlZHN2JWR3IWclZCFnIWg0ZiFofiVkWDRrVntXT3I0ZnJzNVFzdjRmdnc1UXchYDRmIWAhYTVjIWF+NGZQNVRSTyFgNVEhYCFhNV4hYX41UVA1Y09pUFg1alJpUHtXT3IlZHN2JWR3fiVkWDV4VntXT3IlZHN2JWR3IWUlZCFlIWY2XyFmI1YlZCNWI1c4dyNXfiVkWDZkVHtXT3IlZHN2JWR3IWYlZCFmIWc2cyFnfiVkWDZ4VHtXT3IlZHN2JWR3IWMlZCFjIWQ3WCFkfiVkWDdeVHtXT3IlZHN2JWR3IXYlZCF2IXc3bSF3fiVkWDdyVHtXT3IlZHN2JWR3IWMlZCFjIWQ4UiFkfiVkWDhXVHtXT3IlZHN2JWR3IX0lZCF9I084ZyNPfiVkWDhuUntXeFBPciVkc3YlZHd+JWRYOHxUe1dPciVkc3YlZHcjVyVkI1cjWDldI1h+JWRYOWJUe1dPciVkc3YlZHcjVCVkI1QjVTlxI1V+JWRYOXZUe1dPciVkc3YlZHcjaCVkI2gjaTpWI2l+JWRYOltUe1dPciVkc3YlZHcjVCVkI1QjVThSI1V+JWRYOnBUe1dPciVkc3YlZHcjYyVkI2MjZDtQI2R+JWRYO1VUe1dPciVkc3YlZHcjViVkI1YjVztlI1d+JWRYO2pUe1dPciVkc3YlZHcjaCVkI2gjaTt5I2l+JWRYPE9Ue1dPciVkc3YlZHcjbSVkI20jbjxfI25+JWRYPGRUe1dPciVkc3YlZHcjZCVkI2QjZTxzI2V+JWRYPHhUe1dPciVkc3YlZHcjWCVkI1gjWTRmI1l+JWRYPWBSIVBQe1dPciVkc3YlZHd+JWRaPXJVYVFWUHtXT3Ika3JzJVVzdiRrdyFeJGshXiFfJWQhX34ka18+X1VbVVZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFffiRrWj54V1ZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFfIWAkayFgIWE/YiFhfiRrWj9rVSFPUVZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFffiRrWkBVV1ZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFfI1AkayNQI1FAbiNRfiRrWkB1V1ZQe1dPciRrcnMlVXN2JGt3IV4kayFeIV8lZCFfIWAkayFgIWFBXyFhfiRrWkFoVXdRVlB7V09yJGtycyVVc3Yka3chXiRrIV4hXyVkIV9+JGtcIixcbiAgdG9rZW5pemVyczogW3N0YXJ0VGFnLCBjb21tZW50Q29udGVudCwgcGlDb250ZW50LCBjZGF0YUNvbnRlbnQsIDAsIDEsIDIsIDNdLFxuICB0b3BSdWxlczoge1wiRG9jdW1lbnRcIjpbMCw2XX0sXG4gIHRva2VuUHJlYzogMFxufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9